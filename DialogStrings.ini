;; DialogStrings.ini - 所有 TestStand 对话框的字符串，包括序列编辑器。
;;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"


;;通用对话框字符串

[COMMON_DLG]
OK_BTN_LABEL = "确定"
&ok = "确定"			
ok="确定"
;;CANCEL没有加速器。另见 //TestStand/WebPages/TestCases/StandardTest/Dialogs.html
CANCEL_BTN_LABEL = "取消"
CANCEL = "取消"
YES_BTN_LABEL = "是"
NO_BTN_LABEL = "否"
YES_TO_ALL_BTN_LABEL = "全部同意"
NO_TO_ALL_BTN_LABEL = "全部拒绝"
HELP_BTN_LABEL = "帮助"
&HELP = "帮助"
HELP = "帮助"
BROWSE_BTN_LABEL = "浏览..."
ACCEPT_BTN_LABEL = "接受"
HELP_QUESTION_MARK = "?"
OVERWRITE_EXISTING_FILE = "文件 '%1' 已经存在。覆盖它吗？"
FILE_CREATED_SUCCESSFULLY = "'%1' 已成功创建。"
CLOSE_BTN_LABEL = "关闭"
DONE_BTN_LABEL = "完成"
CREATE_BTN_LABEL = "创建"
REFRESH_BTN_LABEL = "刷新"
FILE_BROWSE = "文件浏览"
FIND_NEXT = "查找下一个 (Ctrl+G)"
FIND_PREVIOUS = "查找上一个 (Ctrl+Shift+G)"
EXPR_BROWSE = "表达式浏览"
TYPEDEF = "从结构创建类型"

EDIT_FIRST_SUBSTEP_HOTKEY = "Ctrl+E"

INI_FILES = "INI 文件"
ALL_FILES = "所有文件"
CSV_FILES = "逗号分隔值文件"
SEQUENCE_FILES = "序列文件"
DLL_FILES = "DLL 文件"
EXECUTABLE_FILES = "可执行文件"
COMMAND_FILES = "命令文件"
BATCH_FILES = "批处理文件"
WORKSPACE_FILES = "TestStand 工作区文件"
PROJECT_FILES = "TestStand 项目文件"
CODE_MODULE_FILES = "代码模块"
TESTSTAND_FILES = "测试站文件"
XSL_STYLESHEET_FILES = "样式表文件"
NI_TESTSTAND_ALL_FILES 	= "测试台文件"
TS_ENVIRONMENT_FILES 	= "TestStand 环境文件"

PROGRAM_INFO_FILES = "程序信息文件"

EMPTY_FILE_NAME_FULL_PATH_TEXT = "（未指定文件）"
EMPTY_DIRECTORY_NAME_FULL_PATH_TEXT = "（未指定目录）"
FILE_NOT_FOUND_FULL_PATH_TEXT = "（未找到文件）"
DIRECTORY_NOT_FOUND_FULL_PATH_TEXT = "（未找到目录）"
SEARCHING_FOR_PATH_TEXT = "（正在搜索文件...）"
SEQFILE_LOAD_ERROR_PATH_TEXT = "%1 [错误加载文件]"

[WORKSPACE_BROWSER]
CODE_MODULE_INDICATOR = " [代码模块]"
FILE_NOT_CHECKED_OUT = "文件未签出。无法继续操作。"
FILE_RELOADED_OPERATION_CANNOT_CONTINUE = "文件已重新加载。无法继续操作。\n您需要重复操作。"
PROMPT_TO_CHECKOUT_TITLE = "签出文件？"
CHECKOUT_FILE = "该文件受源代码控制。您要检查它吗？"
NO_PROVIDER_SELECTED_MENU_ITEM = "SCC"
NOT_IN_SCC = "不在源代码控制中"
CHECKED_IN = "签入"
CHECKED_OUT = "签出"
CHECKED_OUT_BY_YOU_AND_OTHERS = "由你和其他人签出"
CHECKED_OUT_BY_OTHER = "已被其他人签出"
CHECKED_OUT_BY_OTHERS = "已被其他人签出"
REMOVING_FROM_SCC_WARNING = "警告 - 一些提供商会删除文件的本地副本。\n\n你想继续吗？"
ADD_NEW_FILES_TO_SCC = "你想将以下新添加的文件置于源代码控制之下吗？\n\n"
CHECKOUT_PROJECT_FILE = "项目文件受源代码控制并且具有只读属性。\n\n你想检查它吗？"
CHECKOUT_WORKSPACE_FILE = "工作区文件受源代码控制并且具有只读属性。\n\n你想检查它吗？"
PROJECT_NOT_CHECKED_OUT = "项目文件未签出。无法继续操作。"
PROJECT_IS_CHECKED_IN = "您选择插入文件的项目已签入。\n签出该项目或进行其他选择。"
WORKSPACE_FILE_NOT_CHECKED_OUT = "工作区文件未签出。无法继续操作。"
CHECKOUT_FILES = "以上文件受源代码控制并具有只读属性。\n\n你想检查它们吗？"
FILES_ARE_CHECKED_IN = "\n上述文件受源代码控制并具有只读属性。\n它们将不会被处理。"
FILES_NOT_CHECKED_OUT = "文件未签出，将不会被处理。"
FILES_NOT_SAVED = "保存以下文件时出错。\n文件可能是只读的。\n\n"
RESET_PROJECT_NAME = "\nTestStand 会将项目名称重置为空。"
CANNOT_ADD_FILE_TO_WORKSPACE_TITLE = "无法将文件添加到工作区"
CANNOT_OPEN_SCC_PROJECT = "无法打开文件 '%1' 的源代码控制项目。\n请确认网络连接以及源代码控制服务器正在运行。\n注意：当你尝试将文件添加到源时，你也会收到此消息代码控制\n 位于提供商配置区域之外的位置。"
SCC_MSG_WARNING = "警告："
SCC_MSG_ERROR = "错误："

NOTE_RELOADING_WORKSPACE_FILE Line0001 = "注意：重新加载工作区文件也会重新加载所有项目。\n"
NOTE_RELOADING_WORKSPACE_FILE Line0002 = "对项目所做的任何更改都将丢失。"

ADD_ALL_FILES_TITLE = "添加所有文件"
ADD_ALL_FILES = "你想将文件夹中的所有文件添加到工作区吗？"
CLOSE_ALL_OPEN_DOCUMENTS = "你想关闭所有打开的文档窗口吗？"

SAVE_FILE_BEFORE_SCC_OP Line0001 = "该文件已在序列编辑器中修改，尚未保存到磁盘。\n您必须在执行源代码控制操作之前保存该文件。\n\n"
SAVE_FILE_BEFORE_SCC_OP Line0002 = "你现在要保存文件吗？\n"
OVERWRITE_FILE_ON_DISK = "该文件已在序列编辑器中修改，尚未保存到磁盘。执行源代码控制操作将覆盖磁盘上的文件。\n\n您要继续吗？"

SAVE_FILES_BEFORE_SCC_OP Line0001 = "以下文件已在序列编辑器中修改，尚未保存到磁盘。\n如果不保存文件，则无法继续源代码控制操作。\n"
SAVE_FILES_BEFORE_SCC_OP Line0002 = "你想现在保存文件并继续吗？\n\n"
OVERWRITE_FILES_ON_DISK = "以下文件已在序列编辑器中修改，尚未保存到磁盘。执行源代码控制操作将覆盖磁盘上的文件。\n您要继续吗？\n\n"

OPTIONS_FILE_WARNING_TITLE = "工作区信息"
CANT_INIT_OPTIONS_FILE = "无法初始化工作区选项文件。"
CANT_WRITE_SCC_INFO_TO_OPTIONS_FILE = "无法保存工作区源代码控制信息。\n不会保存更改。"
CANT_WRITE_OPTIONS_FILE = "无法保存工作区信息。\n不会保存更改。"
CANT_WRITE_PERSISTENCE_FILE = "无法保存对断点和监视表达式的更改。"

SCC_PROVIDER_NOT_FOUND_TITLE = "未找到源代码控制提供程序"
SCC_PROVIDER_NOT_FOUND Line0001 = "工作区 '%1' 无法找到并连接到源代码控制提供程序 '%2'。\n 此计算机上可能未安装此提供程序。"
SCC_PROVIDER_NOT_FOUND Line0002 = "\n\n您可以在工作区对象属性对话框中更改提供者。"

;; TestStand 引擎对话框

[ADAPTER_CFG_DLG]
CAPTION = "适配器配置"
CFG_BTN = "配置..."
CFGABLE_ADP_LBL = "可配置适配器&"
SEL_ADP_LBL = "&Selected 适配器："
ADAPTER_NAME = "适配器"
ADAPTER_SELECTED = "已选择"
ADAPTER_HIDDEN = "隐藏"

[ADD_FILE_TO_PROJECT_DLG]
DLG_TITLE = "添加文件到工作区"
SELECT_PROJECT = "&Select Location to Insert File:"
WORKSPACE_NOTE = "注意：您只能将文件添加到项目文件。在将文件添加到工作区之前，必须先将项目添加到工作区。"

[ARRAY_BOUNDS_DLG]
DLG_TITLE = "数组边界"
DIMENSIONS_STRING_LABEL = "尺寸字符串："
NUM_DIMENSIONS_LABEL = "维数："
INITIAL_EMPTY_LABEL = "空"
LOWER_BOUNDS_LABEL = "下界："
UPPER_BOUNDS_LABEL = "上限："
DIMENSIONS_OUT_OF_RANGE = "数组维度 %1 超出范围 (%2-%3)。"
LOWER_BOUNDS_GREATER_THAN_UPPER_BOUNDS = "下限不能大于上限。"
ARRAY_TOO_BIG = "超出最大数组大小。数组不能包含超过 %1 个元素。National Instruments 建议您将元素的实际数量保持得低得多，以避免耗尽虚拟内存。"
APPLY_TO_ALL_INSTANCES_LABEL = "将边界应用于该类型的所有已加载实例(&I)"
LARGE_ARRAY_WARNING = "您指定的维度超过 %1 个元素。创建如此大的数组时存在内存或地址空间不足的风险。您仍要调整数组大小吗？"

[BREAKPOINT_DLG]
PASSCOUNT_LABEL = "通过计数："
CONDITION_LABEL = "条件："
ISSET_LABEL = "断点设置"
ENABLED_LABEL = "断点启用"
DLG_TITLE = "断点设置"

[BROWSE_LVLIBP_DLG]
DLG_TITLE_VI = "从 LabVIEW 打包项目库中选择一个 VI"
DLG_TITLE_CLASS = "从 LabVIEW 打包项目库中选择一个类"
QUALIFIED_NAME_COLUMN_HDR= "LVLIBP 中包含的导出文件"
PATH_COLUMN_HDR= "路径"
YES ="是"

[BROWSE_LLB_DLG]
DLG_TITLE_VI = "选择一个 VI"
DLG_TITLE_CLASS = "选择职业"
COLUMN_HDR = "LLB 中包含的文件"
IS_TOPLEVEL_COLUMN_HDR = "是顶级"
LAST_MODIFIED_COLUMN_HDR = "修改日期"
YES ="是"
MUST_SEL_CLASS_OR_CANCEL_MSG = "你必须选择一个职业或点击CANCEL。"
MUST_SEL_VI_OR_CANCEL_MSG = "您必须选择一个 VI 或单击CANCEL。"
FILE_NOT_FOUND_IN_LLB = "'%1'\n在 LLB 中找不到文件。\n请验证文件名是否正确。"
FILE_FILTERS_LBL = "显示文件类型："
FF_VIS_ONLY = "仅限 VI (*.vi)"
FF_LVCLASS_ONLY = "仅限 LVCLASS (*.lvclass)"
FF_ALL_FILES = "所有文件 (*.*)"

[CHOOSE_CODE_TEMPLATE_DLG]
CHOOSE_CODE_TMPLT_DLG_TITLE = "选择代码模板"
CHOOSE_CODE_TMPLT_DLG_EXPLANATION Line0001 = "为该步骤类型配置了多个代码模板。选择"
CHOOSE_CODE_TMPLT_DLG_EXPLANATION Line0002 = "用于此步骤的代码模板。"
CODE_TMPLT_DESCRIPTION_COLUMN_HEAD = "描述"
CODE_TMPLT_NAME_COLUMN_HEAD = "名称"
SELECT_CODE_TMPLT_MSG = "选择代码模板。"

[COMBINE_STEP_TYPES_RESULTS_DLG]
TITLE = "合并的步骤类型"
MESSAGE_TOP = "步骤类型 '%1' 和 '%2' 已合并为新的步骤类型。执行了以下操作:\r\n\r\n"
SPECIAL_ACTIONS = "添加了来自两种步骤类型的子步骤和代码模板（如果有的话）。前置表达式和后置表达式已连接。无法连接状态表达式。使用了 '%1' 中的状态表达式。\r\ n\r\n"
PROPS_ADDED = "添加了 '%1' 中不存在于 '%2' 中的以下属性:\r\n"
PROPS_CHANGED = "以下属性具有不同的值和/或标志。使用了 '%1' 中的值和标志:\r\n"

[CONFIRM_DLG]
DLG_TITLE = "确认"

[CONFIRM_MULTIPLE_DELETE_DLG]
CONFIRM_DELETE_TITLE = "确认删除"
CONFIRM_DELETE_MSG = "你想删除'%1'吗？"
YES = "是"
NO = "否"
YES_TO_ALL = "全部同意"
CANCEL = "取消"

[CREATE_STEP_DLG]
DLG_TITLE = "创建新步骤"
ADAPTER_LABEL = "适配器："
STEP_TYPE_LABEL = "步骤类型："
NO_STEP_TYPES_AVAILIABLE_MSG = "没有可用的步骤类型"

[EDIT_CODE_TEMPLATE_DLG]
DLG_TITLE = "编辑代码模板"
CODE_TMPLT_DESCRIPTION_LABEL = "描述："
PASS_CVI_SEQCONTEXT_CHECK_LABEL = "需要序列和上下文（仅限 LabVIEW 和 LabWindows/CVI 标准原型）"
PARAM_VALUE_MAPPINGS_GROUP_LABEL = "参数名称/值映射"
PARAMETER_NAME_COLUMN_HEADER = "参数名称"
VALUE_COLUMN_HEADER = "值表达式"
RESULT_ACTION_COLUMN_HEADER = "结果操作"
SET_ERROR_CODE_TO_VALUE_COLUMN_HEADER = "设置错误代码"
ADD_MAPPING_LABEL = "添加"
DELETE_MAPPING_LABEL = "删除"
PARAMETER_NAME_EDIT_LABEL = "参数名称："
VALUE_EDIT_LABEL = "值表达式："
RESULT_ACTION_LABEL = "结果行动："
TEMPLATE_PATH_LABEL = "路径："
TEMPLATE_TYPE_LABEL = "类型："
EDIT_CODE_LABEL = "编辑代码"
OPEN_FOLDER_LABEL = "打开文件夹"
SET_ERROR_CODE_TO_VALUE_LABEL = "&Set Error.Code to Value"
DLG_DESCRIPTION Line0001 = "使用此对话框编辑代码模板属性。TestStand 使用代码模板描述"
DLG_DESCRIPTION Line0002 = "帮助序列开发人员决定在生成代码时使用哪个模板。"
DLG_DESCRIPTION2 Line0001 = "TestStand 使用映射自动为序列开发人员填充值信息"
DLG_DESCRIPTION2 Line0002 = "从该模板生成代码时。"
INVALID_MAPPING_MSG Line0001 = "你指定了一个或多个重复的参数名称。\n"
INVALID_MAPPING_MSG Line0002 = "每个名称只能映射到一个值。您必须删除所有重复项。"
INVALID_MAPPING_MSG_TITLE = "无效的参数名称映射"
SYNTAX_ERR_PARAM = "参数 '%1' 的值存在语法错误："
SOURCE_FILE_NOT_EXISTS = "无法打开源文件，因为文件不存在。"

[EDIT_PATHS_DLG]
DLG_TITLE = "编辑路径"
PATH_IS_FILE_COLUMN_TEXT = ""
PATH_IS_DIR_COLUMN_TEXT = "目录"
PATH_NOT_FOUND_COLUMN_TEXT = "未找到"
INVALID_PATH_COLUMN_TEXT = "无效"
EMPTY_PATH_COLUMN_TEXT = "空"
PATH_LIST_LABEL = "路径："
FULL_PATH_LABEL = "完整路径："
REVERT_BUTTON_LABEL = "恢复"
REPLACE_BUTTON_LABEL = "替换..."
BROWSE_BUTTON_LABEL = "更改..."
BROWSE_DLG_TITLE = "改变路径"
PATH_COLUMN_LABEL = "路径"
PATH_NOT_FOUND_COLUMN_LABEL = "状态"
FILE_COLUMN_LABEL = "文件"
SEQUENCE_COLUMN_LABEL = "位置"
STEP_COLUMN_LABEL = "步骤"
PROPERTY_COLUMN_LABEL = "财产"
CLEANUP_STEPS_TEXT = "（清理）"
SETUP_STEPS_TEXT = "（设置）"
MAIN_STEPS_TEXT = ""
SUBSTEP_TEXT = "（子步骤）"
FIND_WHAT_LABEL = "替换："
REPLACE_WITH_LABEL = "&With:"
REPLACE_ALL_BUTTON_LABEL = "全部替换"
CASE_SENSITIVE_CHECK_LABEL = "区分大小写"
REPLACE_MESSAGE = "替换了 %2 条路径中的 %1 处。"
REPLACE_READONLY_MESSAGE = "%1 路径未更改，因为您没有必要的权限。"
REPLACE_DLG_TITLE = "替换所有路径中的文本"
REPLACE_BROWSE_DLG_TITLE = "选择替换文本的路径"

[ENGINE_OPTIONS_SHEET]
NUMBER_OF_STATION_GLOBALS_BACKUPS_ON_START = "启动时为站点全局文件保存的最大备份数"
NUMBER_OF_STATION_GLOBALS_BACKUPS_ON_SAVE = "保存时为空间站全局文件保存的最大备份数"
SHEET_TITLE = "站点选项"

RTE_OPTION_LABEL = "运行时错误:"
RTE_OPTION_SHOW_DLG = "显示对话框"
RTE_OPTION_RUN_CLEANUP = "运行清理"
RTE_OPTION_IGNORE = "忽略"
RTE_OPTION_ABORT = "立即中止（不清理）"
SHOW_HIDDEN_PROPS_LABEL = "&显示隐藏属性"
EXE_PAGE_TITLE = "执行"
ENABLE_BREAKPOINTS_LABEL = "&启用断点："
BREAK_WHILE_TERMINATING_LABEL = "终止时荣誉断点"
ALLOW_BREAK_WHILE_IN_CODE_MODULES = "允许在代码模块中中断"
ENABLE_TRACING_LABEL = "启用跟踪："
TRACE_SPEED_SLOW_LABEL = "速度：   慢"
TRACE_SPEED_FAST_LABEL = "快"
TRACE_INTO_SETUP_CLEANUP_LABEL = "允许跟踪设置/清理"
TRACE_INTO_PRE_POST_CALLBACKS_LABEL = "允许跟踪到前/后步骤和回调"
TRACE_INTO_POST_ACTION_CALLBACKS_LABEL = "允许追踪到 Post &Action 回调"
TRACE_INTO_SEPARATE_EXECUTION_CALLBACKS_LABEL = "追踪到单独的执行回调"
TRACE_INTO_ENTRY_POINTS_LABEL = "追踪入口点"
TRACE_INTO_SEQUENCE_CALLS_MARKED_AS_TRACING_OFF_LABEL = "允许跟踪序列调用&标记为跟踪\"禁用\""
TRACE_WHILE_TERMINATING_LABEL = "终止时允许跟踪"
GOTO_CLEANUP_ON_SEQUENCE_FAILURE_LABEL = "序列失败时立即转到清理"
DISABLE_RESULTS_LABEL = "&Disable Result Recording for All Sequences"
INTERACTIVE_EXECUTION_GROUP_LABEL = "交互式执行："
INT_EXE_RECORD_RESULTS_LABEL = "记录结果"
INT_EXE_RUN_SETUP_CLEANUP_LABEL = "运行安装和清理"
INT_EXE_EVAL_PRECOND_LABEL = "评估先决条件"
INT_EXE_PROPAGATE_STATUS_LABEL = "将失败和错误从嵌套交互执行传播到调用执行"

INT_EXE_BRANCHING_MODE_LABEL = "分支模式："
INT_EXE_BRANCHING_MODE_NONE = "忽略所有分支"
INT_EXE_BRANCHING_MODE_IGNORE = "忽略未选择步骤的分支"
INT_EXE_BRANCHING_MODE_GOTOEND = "在分支上结束到未选择的步骤"
INT_EXE_BRANCHING_MODE_RAISERTE = "将分支上的错误提升到未选择的步骤"
INT_EXE_BRANCHING_MODE_ALLOWALL = "允许所有分支"

TIME_LIMITS_PAGE_TITLE = "时间限制"
TIME_LIMIT_SETTINGS_FOR_LABEL = "设置for:"
TIME_LIMIT_SETTINGS_LABEL = "时限设置："
TIME_LIMIT_LABEL = "时间限制："
TIME_LIMIT_SECONDS_LABEL = "秒"
TIME_LIMIT_SET_TIME_LIMIT_LABEL = "为该操作设置时间限制"
TIME_LIMIT_ACTION_LABEL = "时间结束时："
TIME_LIMIT_ACTION_PROMPT_LABEL = "行动提示"
TIME_LIMIT_ACTION_TERMINATE_LABEL = "终止执行"
TIME_LIMIT_ACTION_ABORT_LABEL = "中止执行"
TIME_LIMIT_ACTION_KILL_THREADS_LABEL = "结束执行线程"
TIME_LIMIT_KILL_THREADS_WARNING = "警告 - 终止线程会使 TestStand 处于不可靠状态。"
TIME_LIMIT_SETTINGS_FOR_NORMAL_EXECUTION = "正常执行"
TIME_LIMIT_SETTINGS_FOR_EXITING = "退出"
TIME_LIMIT_SETTING_WHEN_EXECUTING = "执行时"
TIME_LIMIT_SETTING_TERMINATING = "终止时"
TIME_LIMIT_SETTING_ABORTING = "中止时"

PREFERENCES_PAGE_TITLE = "首选项"
INVALID_TESTSTAND_MODEL_OPTIONS_TITLE = "无效的空间站模型选项"

PREFERENCES_ERROR_1 Line0001 = "您不能更改站模型选项。以下顺序\n"
PREFERENCES_ERROR_1 Line0002 = "文件需要站模型以外的特定模型：'%1'。\n"
PREFERENCES_ERROR_1 Line0003 = "你必须启用允许其他模型选项或卸载这些\n"
PREFERENCES_ERROR_1 Line0004 = "在您可以更改空间站模型选项之前的序列文件。"

PREFERENCES_ERROR_2 Line0001 = "您不能更改站模型选项。以下顺序\n"
PREFERENCES_ERROR_2 Line0002 = "文件需要特定型号。\n"
PREFERENCES_ERROR_2 Line0003 = "你必须启用允许其他模型选项或卸载这些\n"
PREFERENCES_ERROR_2 Line0004 = "在您可以更改空间站模型选项之前的序列文件。"

PREFERENCES_ERROR_3 Line0001 = "您不能更改站模型选项。以下顺序\n"
PREFERENCES_ERROR_3 Line0002 = "文件需要站模型以外的特定模型：'%1'。\n"
PREFERENCES_ERROR_3 Line0003 = "您必须启用允许其他模型选项或设置站点\n"
PREFERENCES_ERROR_3 Line0004 ="模型到‘%2’或卸载这些序列文件\n"
PREFERENCES_ERROR_3 Line0005 = "在您可以更改站模型选项之前。"

PREFERENCES_ERROR_4 Line0001 = "您不能更改站模型选项。以下顺序\n"
PREFERENCES_ERROR_4 Line0002 = "文件需要特定型号。\n"
PREFERENCES_ERROR_4 Line0003 = "您必须启用允许其他模型选项，启用使用站\n"
PREFERENCES_ERROR_4 Line0004 = "模型选项并将站模型设置为'%1'，或卸载\n"
PREFERENCES_ERROR_4 Line0005 = "这些序列文件在您可以更改站模型选项之前。"

PROMPT_TO_FIND_FILES_LABEL = "提示查找文件"
PROMPT_TO_SET_FGROUND_WINDOW_TIMEOUT_LABEL = "提示更改系统设置前台窗口行为"
USE_COMPUTER_FOR_STATION_ID = "为工作站 ID 使用计算机名称"
STATION_ID_LABEL = "站号："
CONFIGURE_DIRECTORY = "配置和目录："
CONFIGURE_DIRECTORY_IS_NOT_ABSOLUTE = "配置目录必须是绝对路径。"
CONFIGURE_DIRECTORY_COPY_ON_CLOSE = "您更改了配置目录设置。\n在 TestStand 可以使用新的配置目录位置之前，您必须重新启动应用程序。\n\n您希望 TestStand 在您退出应用程序时将配置设置复制到新目录吗？"
CONFIGURE_DIRECTORY_COPY_ON_CLOSE_TITLE = "复制配置设置"
CONFIGURE_DIRECTORY_TS_DEFAULT = "<测试台默认位置>"
CONFIGURE_DIRECTORY_SPECIFIED_BY_ENVIRONMENT = "<由环境指定>"
STATION_ID_CANNOT_BE_EMPTY = "站点 ID 不能为空。"
RELOAD_LAST_WS_AT_STARTUP = "重新加载上次启动时的工作区"
RELOAD_DOCS_WHEN_OPENING_WS = "打开工作区时重新加载文档"
EXPRESSION_EDITOR_OPTIONS = "表达编辑选项..."
USE_STEP_ID_IN_EXPRESSIONS = "在表达式中指定步骤："
USE_STEP_ID_OPTION_YES = "通过唯一步骤 ID"
USE_STEP_ID_OPTION_NO = "按步骤名称"
USE_STEP_ID_OPTION_ASK = "询问"
DEFAULT_CPU_AFFINITY_FOR_&THREADS = "&Threads 的默认 CPU 关联："
ERR_THREAD_AFFINITY_NOT_UINT64 = "线程的默认 CPU 亲和性不是 64 位整数。"
ERR_THREAD_AFFINITY_NO_CPUS = "线程的默认 CPU 亲和性没有指定任何 CPU。"
ERR_THREAD_AFFINITY_INVALID_CPU = "验证线程的默认 CPU 相关性时发生以下错误：\n\n%1\n\n你想使用这个值吗？"
ERR_THREAD_AFFINITY_32BIT_MASK = "用于 64 位应用程序的 32 位线程关联掩码。"
&PRELOAD_PROGRESS_DIALOG_BOX_DELAY = "&Preload 进度对话框延迟："
ERR_PRELOAD_PROGRESS_DELAY_NOT_NUMBER = "预加载进度对话框延迟不是一个数字。"
DEBUG_OPTIONS = "调试选项&g..."
CLEAR_PASSWORD_CACHE_BUTTON = "清除文件密码缓存"

FILE_OPTION_PAGE_TITLE = "文件"
ALLOW_AUTO_TYPE_RESOLVE_OPTION = "允许自动解决类型冲突:"
ALLOW_AUTO_TYPE_RESOLVE_ALWAYS = "始终（与 TestStand 4.0.x 及更早版本相同）"
ALLOW_AUTO_TYPE_RESOLVE_ONLY_IF_TYPE_PALETTES_WILL_NOT_BE_MODIFIED = "仅当不修改类型调色板文件时（默认）"
ALLOW_AUTO_TYPE_RESOLVE_ONLY_IF_TYPE_PALETTE_HAS_HIGHER_VERSION = "仅当类型调色板文件具有更高版本时"
ALLOW_AUTO_TYPE_RESOLVE_NEVER = "从不"
AUTO_INCREMENT_FILE_VERSION = "自动递增序列文件版本(&A)"
VERSION_NUMBER_TO_INCREMENT = "&要增加的版本号："
VERSION_MAJOR = "主要"
VERSION_MINOR = "次要"
VERSION_REVISION = "修订版"
VERSION_BUILD = "构建"
AUTO_INCREMENT_TYPE_VERSION = "在保存修改类型之前："
AUTO_INCREMENT_TYPE_VERSION_YES = "自动递增类型版本"
AUTO_INCREMENT_TYPE_VERSION_NO = "不增加类型版本"
AUTO_INCREMENT_TYPE_VERSION_PROMPT = "提示增加类型版本"
TYPE_VERSION_NUMBER_TO_INCREMENT = "要增加的版本号:"
FILE_MODIFICATION_INDICATOR_POLICY_EXCLUDE_TESTSTAND_VERSION_UPGRADE = "如果修改仅由自动 TestStand 版本升级引起，则不将文件标记为已修改"
FILE_FORMAT_OPTIONS = "&文件格式选项..."
FILE_FORMAT_OPTIONS_CAPTION = "文件格式选项"
DEFAULT_FILE_FORMAT_LBL = "新文件的文件格式："
FILE_FORMAT_SPECIAL_FILES_LABEL Line0001 = "要更改序列文件的每个文件设置，请使用序列文件属性对话框。"
FILE_FORMAT_SPECIAL_FILES_LABEL Line0002 = "要更改其他文件的每个文件设置，请选择下面列表中的文件。"
FILE_FORMAT_SPECIAL_FILE_SETTING_LABEL = "文件 '%1' 的格式设置："
FILE_FORMAT_FILE_NAME_COLUMN = "文件"
FILE_FORMAT_CURRENT_SETTING_COLUMN = "当前设置"
FILE_FORMAT_MIGHT_REQUIRE_ADMIN_WARNING Line0001 = "无法打开您选择的文件进行写入。您很可能无法保存此格式更改后的文件。如果您以标准用户身份运行，可能会发生这种情况。"
FILE_FORMAT_MIGHT_REQUIRE_ADMIN_WARNING Line0002 = "并且该文件位于受保护的目录中，例如 Program Files 目录。您必须以管理员权限启动 TestStand 才能更改此格式。"

USER_OPTIONS_PAGE_TITLE = "用户管理器"
CHECK_USER_PRIVILEGES_LABEL = "检查用户及权限"
USERS_FILE_GROUP_LABEL = "用户管理器文件："
CURRENT_USERS_FILE_LABEL = "&当前用户管理器文件："
USERS_FILE_CONFIG_LABEL = "配置："
USERS_FILE_USE_DEFAULT_CHECK = "使用默认值"
USERS_FILE_LABEL = "用户管理器文件："
USERS_FILE_BROWSE_DLG_TITLE = "选择用户管理器文件"
USER_CONFIG_INFO_TEXT = "（更改在您重新启动 TestStand 之前不会生效。）"
AUTO_LOGIN_SYSTEM_USER_LABEL = "自动登录 Windows 系统用户"
REQUIRE_LOGIN_CHECK_LABEL = "需要用户登录"
LOGIN_ON_START_CHECK_LABEL = "登录并开始"

MODEL_OPTIONS_PAGE_TITLE = "模型"

TESTSTAND_MODEL_LABEL = "空间站&型号："
USE_TESTSTAND_MODEL_CHECK = "&使用站模型"
ALLOW_OTHER_MODELS_CHECK = "&Allow 其他模型"
TESTSTAND_MODEL_BROWSE_DLG_TITLE = "选择空间站模型"


LANGUAGE_PAGE_TITLE = "本地化"
LANGUAGE_LABEL = "选择语言:"
DECIMAL_LABEL = "使用本地化小数点"
MBCS_LABEL = "引擎启动时的代码页："

REMOTE_OPTION_PAGE_TITLE = "远程执行"
ENABLE_REMOTE_CHECK = "允许来自远程计算机的序列调用在此计算机上运行(&R)"
DCOM_AUTHENTICATE_CHECK = "允许所有用户从远程计算机访问\n（启用此选项允许来自任何计算机的任何用户启动和访问此计算机上的 TestStand 远程引擎。）"
TRAY_ICON_CHECK = "当 TestStand 远程引擎在此计算机上处于活动状态时显示系统托盘图标"
FIX_DCOM_SETTINGS_BUTTON = "修复注册表设置(&F)"
NEED_TO_REBOOT = "重新启动计算机以使这些设置生效。"
DCOM_SETTINGS_WARNING_MSG = "警告：以下注册表设置与远程执行不兼容：\n\n%1\n\n要自动更改这些设置，请单击修复注册表设置按钮。您需要管理员权限才能更改这些设置。"

WORKSPACE_PAGE_TITLE = "源代码控制"
USE_SELECTION_DIALOG_FOR_SC_OPERATION = "使用选择对话框进行源代码控制操作"
USE_DIALOG_FOR_CHECKOUT = "使用文件检出对话框(&D)"
PROMPT_ADD_FILES_TO_SCC = "将文件插入到工作区时提示添加到源代码控制"
INCLUDE_ONLY_SELECTED_FILES = "在源代码控制对话框中仅显示选定文件(&S)"
CHECKOUT_WHEN_EDITED = "编辑时签出源文件(&E)"
SYSTEM_DEFAULT_SCC_PROVIDER = "&系统默认源代码控制提供程序：\n（更改会影响其他应用程序）"
SCC_PROVIDER_CHANGE_WARNING = "更改系统默认的源代码控制提供程序会影响这台计算机上的所有应用程序。"
SCC_PROVIDER_CHANGE_FROMTO_MESSAGE = "将系统默认源代码控制提供程序从 %1 更改为 %2？"
SCC_PROVIDER_CHANGE_TO_MESSAGE = "将系统默认的源代码控制提供商更改为 %2？"
SCC_PROVIDER_NONE = "无"
SCC_PROVIDER_CHANGE_FAILED_ERROR = "无法更新默认源代码控制提供程序。"

[DEBUG_OPTIONS_DLG]
DEBUG_OPTIONS_TITLE = "调试选项"
STACK_CHECK_LABEL = "&Stack Checking - 检测代码模块何时错误地改变了堆栈。"
BUFFER_CHECK_LABEL = "&Buffer Checking - 检测代码模块何时错误地更新参数的缓冲存储器。"
CVIUP_CHECK_LABEL = "&User Protection - 将参数的附加用户保护信息传递给使用 LabWindows/CVI 创建的可调试代码模块。"
LEAK_CHECK_LABEL = "&Report Object Leaks - 在关闭过程中，启动一个对话框，其中包含所有具有未发布引用的顶级属性对象的列表。"
OUTMSG_CHECK_LABEL = "将输出和消息发送到调试器 - 将 TestStand 输出消息发送到调试器的输出窗口。"
KNOWNOS_COMPONENT_CHECK_LABEL = "报告&Known OS and Component Problems - 在关闭期间，启动一个对话框，其中包含操作系统和组件相关问题的列表，例如那些可能导致 TestStand 中的资源泄漏（内存、GDI 和用户对象）的问题"

[EXPORT_TOOL_MENU_DLG]
DLG_TITLE = "导出工具菜单"
BROWSE_DLG_TITLE = "选择文件名"
MOVE_UP_BUTTON_LABEL = "向上移动(&U)"
MOVE_DOWN_BUTTON_LABEL = "向下移动(&D)"
MENU_ITEMS_LABEL = "&勾选你想导出的菜单项"
FILENAME_LABEL = "文件名称："
EMPTY_FILENAME_MSG = "您必须指定一个带有 .ini 扩展名的有效文件名。"
EMPTY_FILENAME_TITLE = "无效文件名"
COMMENTS_FOR_USER Line0001 = "要将这些工具菜单项导入到另一个 TestStand 安装中，请将您使用此对话框创建的文件复制到 "
COMMENTS_FOR_USER Line0002 = "目标计算机上的 <TestStand Public>\\Setup\\ToolMenusToInstall 目录。"
FILE_ALREADY_EXISTS = "你指定的文件已经存在。\n你想覆盖它吗？"
FILE_ALREADY_EXISTS_TITLE = "保存"
FILE_ALREADY_EXISTS_UNABLEDELETE = "无法覆盖文件 '%1'"
ABSOLUTE_PATH_REQUIRED_TITLE = "导出"
ABSOLUTE_PATH_REQUIRED = "无法导出设置。您必须指定一个绝对路径。"

[EXPRESSION_EDIT_OPTIONS_DLG]
EXPRESSION_EDITOR_OPTIONS = "表达式编辑选项"
TEXT_&ELEMENT = "文字&元素"
&BOLD = "&粗体"
&ITALIC = "&斜体"
&UNDERLINE = "&下划线"
STRIKE&THROUGH = "删除线&直通"
AUTO_COMPLETION = "自动完成"
O&N = "否"
&ALPHABETIZE_ITEMS = "&Alphabetize 项目"
&CATEGORIZE_ITEMS = "&分类项目"
HOT_KEYS = "热键"
&MENU_ITEM = "菜单项"
ENTER_NEW_HOT&KEY: = "输入新热键:"
OTHER_OPTIONS = "其他选项"
&WORD_WRAP = "自动换行"
WANT_&RETURN = "想要返回"
AUTOMATICALLY_PREFI&X_VARIABLES = "自动前缀变量"
UNDO_&LIMIT: = "撤消限制:"
FUNCTION_TIP = "函数提示"
&PROTOTYPE = "原型"
&SUMMARY = "总结"
&DETAILS = "详情"
SHOW_AUTOMATICALL&Y = "自动显示"
FONT_SI&ZE: = "字体大小:"
NORMAL = "正常"
LARGE = "大"
EXTRA_LARGE = "特大号"
PRE&VIEW = "预览视图"
OPERATOR="操作员"
STRING = "字符串"
NUMBER = "数字"
SYMBOLIC_CONSTANT = "符号常量"
IDENTIFIER = "标识符"
COMMENT = "描述"
SYNTAX_ERROR = "语法错误"
EVALUATION_ERROR = "评估错误"
EVALUATION_WARNING = "评估警告"
RESET_VALUES_TO_DE&FAULTS = "将值重置为默认值"
INT64 = "64 位整数"

[EXTERNAL_REPORT_CONFIGURE_DLG]
DLG_TITLE = "配置外部查看器"

DESCRIPTION Line0001 = "要为特定文件格式明确指定外部查看器，请在以下查看器列表中添加一个条目。"
" DESCRIPTION Line0002 = " 格式列表不包括使用 Microsoft Windows 与格式的文件扩展名相关联的默认应用程序。
DESCRIPTION Line0003 = "要自动启动未在此对话框中指定的外部查看器，"
DESCRIPTION Line0004 = "启用自动启动默认外部查看器选项。"

VIEWERS_STATIC_LABEL = "查看者："
ADD_BTN_LABEL = "添加..."
DELETE_BTN_LABEL = "删除"
VIEWER_STATIC_LABEL = "&查看器："
ARGUMENTS_STATIC_LABEL = "参数："
FORMAT_STATIC_LABEL = "格式："
VIEW_HEADER = "查看器"
FORMAT_HEADER = "格式"
ARGS_HEADER = "参数"
AUTO_LAUNCH_VIEWER = "自动启动查看器(&U)"
AUTO_LAUNCH_OS_EXT_VIEWERS = "自动启动默认外部查看器(&L)"

VIEWER_PATH_CANT_BE_EMPTY_MSG = "查看器路径不能为空。"
VIEWER_FORMAT_CANT_BE_EMPTY_MSG = "查看器格式不能为空。"
ERROR_MESSAGE_TITLE = "配置外部查看器"
DUPLICATE_FORMAT_MSG = "格式 '%1' 存在多个查看器。\nTestStand 仅使用为该格式列出的第一个查看器。"

[EXTERNAL_REPORT_VIEWER_FORMAT]
TXT = ".txt"
DOC = ".doc"
HTML = ".html"

[FIND_FILE_DLG]
DLG_TITLE = "找到 %1"
INVALID_FILE_SELECTED_MSG = "%1\n无效路径。\n您选择的文件路径必须以 '%2' 结尾。"
INVALID_CMD_FILE_EXTENSION_MSG = "%1\n文件扩展名无效。\n您选择的文件必须以命令扩展名之一结尾：%2"

ADD_DIR_TO_SEARCH_DIR_LABEL = "添加&目录到搜索目录列表"

CURRENT_FOLDER_COMBO_LABEL = "查找并进入："
FILE_LIST_LABEL = "文件"
FILE_NAME_EDIT_LABEL = "文件名："
FILE_TYPE_FILTER_COMBO_LABEL = "文件类型："
READ_ONLY_CHECK_LABEL = "以只读方式打开"

[LOGIN_DLG]
DLG_TITLE = "登录"
LOGIN_NAME_LABEL = "用户名："
PASSWORD_LABEL = "密码："
INVALID_LOGIN_UPPERCASE_MESSAGE = "无效密码。密码区分大小写。"
INVALID_LOGIN_TITLE = "登录"
INVALID_LOGIN_NAME_MESSAGE = "无效的用户名。"
INVALID_LOGIN_NAME_TITLE = "登录"

[LOOP_ON_STEPS_DLG]
DLG_TITLE = "循环选择的步骤"

LOOP_COUNT_PAGE_TITLE = "循环次数"
INFINITE_CHECK_LABEL = "无限循环"
LOOP_COUNT_LABEL = "循环计数："
INFINITE_COUNT_TEXT = "<无限>"
USE_ENTRY_POINT_LABEL = "使用入口点："
DONT_USE_ENTRY_POINT = "<无>"
STOP_ON_LABEL = "&停止条件:"
STOP_ON_ERROR_TEXT = "步骤错误"
STOP_ON_FAILURE_TEXT = "步骤失败"
STOP_ON_PASS_TEXT = "步骤通过"
STOP_ON_NONE_TEXT = "<无>"
CUSTOM_EXPR_TEXT = "<自定义停止表达式>"
INVALID_LOOP_COUNT_ERROR_MESSAGE = "循环计数无效。您必须输入一个大于 0 的整数。"
INVALID_LOOP_COUNT_ERROR_TITLE = "在选定步骤上循环"

STOP_ON_PAGE_TITLE = "停止表达"
CUSTOMIZE_LOOP_EXPR_CHECK = "指定自定义停止表达式(&C)"
STOP_ON_EXPR_LABEL = "停止表达式："
STOP_ON_SYNTAX_ERROR_MESSAGE = "停止表达式"

[MODIFY_VALUE_DLG]
STRING_DLG_TITLE = "修改字符串值"
NUMBER_DLG_TITLE = "修改数值"
BOOLEAN_DLG_TITLE = "修改布尔值"
REF_DLG_TITLE = "修改参考值"
NAME_LABEL = "姓名："
STRING_VALUE_LABEL = "字符串 & 值："
NUMERIC_VALUE_LABEL = "数值&值："
BOOLEAN_VALUE_LABEL = "布尔值&值："
REF_VALUE_LABEL = "参考&值："
REF_RELEASE_VALUE_BTN_LABEL = "&Release"
APPLY_TO_ALL_INSTANCES_LABEL = "将值应用于该类型的所有已加载实例"

SURROUNDING_QUOTES_WARNING = "输入新字符串时不需要使用引号\n。字符串的值将包括引号。"

EXPR_ERROR = "表达式"

[NEW_EXTERNAL_REPORT_VIEWER_DLG]
DLG_TITLE = "新外部查看器"
VIEWER_STATIC_LABEL = "查看器："
FORMAT_STATIC_LABEL = "格式："

VIEWER_BROWSER_DLG_TITLE = "选择外部查看器"

VIEWER_PATH_CANT_BE_EMPTY_MSG = "查看器路径不能为空。"
VIEWER_FORMAT_CANT_BE_EMPTY_MSG = "查看器格式不能为空。"

[NEW_USER_DLG]
EDIT_USER_DLG_TITLE = "新用户"
LOGIN_NAME_LABEL = "用户名："
FULL_NAME_LABEL = "全名："
COMMENT_LABEL = "描述："
PASSWORD_LABEL = "密码："
CONFIRM_PASSWORD_LABEL = "确认密码："
USER_TEMPLATE_LABEL = "从组中复制特权："
PASSWORD_NOT_CONFIRMED_MESSAGE = "密码未确认。请重新输入密码。"
OK_BTN = "确定"
CANCEL_BTN = "取消"

[NUMERIC_FORMAT_DLG]
DLG_TITLE = "数字格式"
NOT_SET = "自动"

EXPONENT_NO = "否"
EXPONENT_YES = "是"
EXPONENT_AUTO = "自动"

SIGN_MINUS_ONLY = "只有减号"
SIGN_PLUS_OR_MINUS = "加号或减号"
SIGN_SPACE_OR_MINUS_SIGN = "空格或减号"

TYPE_DEFAULT = "<使用默认值>"
TYPE_REAL = "真实"
TYPE_INTEGER = "整数"
TYPE_UNSIGNED_INTEGER = "无符号整数"
TYPE_HEX = "十六进制"
TYPE_OCTAL = "八进制"
TYPE_BINARY = "二进制"

FORMATTED_NUMBER_LABEL = "格式化数字："
SAMPLE_LABEL = "样本:"
TYPE_LABEL = "类型:"
FRACTIONAL_DIGITS_LABEL = "小数位数&数字："
MAX_SIGNICANT_DIGITS_LABEL = "有效数字的最大数目："
MINIMUM_NUMBER_OF_DIGITS_LABEL = "最小位数："
FIELD_WIDTH_LABEL = "最小字段宽度："
SIGN_LABEL = "签名:"
SHOW_EXPONENT_LABEL = "指数："
DISPLAY_TRAILING_ZEROS_LABEL = "显示尾随零点"
ALIGN_LEFT_LABEL = "左对齐"
FILL_WIDTH_WITH_ZEROS_LABEL = "用前导零填充宽度"
SHOW_DECIMAL_POINT_LABEL = "始终显示小数点"
SHOW_TYPE_PREFIX_LABEL = "基数前缀"
USE_UPPERCASE_LETTERS_LABEL = "使用大写字母"
FORMAT_LABEL = "格式："
CUSTOM_LABEL = "自定义"
CHECK_FORMAT_LABEL = "检查格式"

VALUE_TOO_LARGE = "该字段的最大值为 %1。"

NUMERIC_FORMAT_IS_CUSTOM = "您不能禁用自定义复选框，因为数字格式字符串包含不属于格式的额外字符。"
NUMERIC_FORMAT_OK = "没有发现数字格式错误。"
INVALID_NUMERIC_FORMAT_TITLE = "无效的数字格式"
INVALID_NUMERIC_FORMAT_EMPTY = "数字格式不能为空。\n\n"
INVALID_NUMERIC_FORMAT_INVALID_CHAR = "您输入的数字格式无效。\n错误发生在字符编号 %1 (\'%2\')。\n\n"
INVALID_NUMERIC_FORMAT_EXPLAIN Line0001 = "使用以下格式：\n%[Flags][Width][.Precision]<Type>\n"
INVALID_NUMERIC_FORMAT_EXPLAIN Line0002 = "Flags:\t-,+,$,0,#,(blank)' '\n宽度：\t0...15\n精度：\t0..15\n类型：\td,i,u, x,X,o,O,b,B,e,E,f,g,G\n"
INVALID_NUMERIC_FORMAT_EXPLAIN_INT64 Line0001 = "使用以下格式：\n%[Flags][Width][.Precision]<Type>\n"
INVALID_NUMERIC_FORMAT_EXPLAIN_INT64 Line0002 = "Flags:\t-,+,$,0,#,(blank)' '\n宽度：\t0...15\n精度：\t0..15\n类型：\td,i,u, x,X,o,O,b,B\n"

[OBJECT_FLAGS_DLG]
DLG_TITLE = "编辑旗帜"
WARNING = "警告 - 更改属性对象标志可能会产生不良影响。"
FLAGS_GROUP = "标志:"
OLD_FLAGS_LABEL = "&旧标志："
NEW_FLAGS_LABEL = "&新旗帜："
INVALID_FLAGS_MSG = "无效标志。输入十六进制或整数值。"
APPLY_TO_ALL_INSTANCES_LABEL = "&Apply Changes to Flags and Type Flags to all Loaded instances of the Type"
ADVANCED_BUTTON_LABEL = "&类型标志..."
TYPE_INSTANCE_WARNING_MSG = "您不能更改 '%1' 标志的值。属性的类型指定该类型必须为该类型的任何实例确定该标志的值。"

;;OBJECT_FLAGS_ADVANCED_DLG
DLG_ADVANCED_TITLE = "编辑数据类型标志（仅限类型）"
TYPE_FLAGS_GROUP = "类型标志："
OLD_TYPE_FLAGS_LABEL = "旧标志："
NEW_TYPE_FLAGS_LABEL = "标志帜："
FLAGS_FOR_INSTANCES_GROUP = "实例默认标志(&F)："
OLD_FLAGS_FOR_INSTANCES_LABEL = "O&ld 旗帜："
NEW_FLAGS_FOR_INSTANCES_LABEL = "新标志："
INSTANCE_OVERRIDE_FLAGS_GROUP = "标志在实例中不可编辑："
OLD_INSTANCE_OVERRIDE_FLAGS_LABEL = "标志："
NEW_INSTANCE_OVERRIDE_FLAGS_LABEL = "标志帜："

[OPEN_FILE_DLG]
DLG_TITLE = "打开"
SAVE_DLG_TITLE = "保存"
SELECT_DIR_DLG_TITLE = "选择目录"
USE_ABSOLUTE_PATH_CHECK_LABEL = "使用绝对路径"
BROWSE_LLB_CHECK_LABEL = "浏览 LLB 文件"
DIR_PATH_LABEL = "导演:"
APPLY_TO_ALL_BUTTON_LABEL = "应用到所有"
SUBSTITUTE_PATH_MACROS_BUTTON_LABEL = "替换路径宏"
SUBSTITUTE_ABSOLUTE_PATH_MACROS_BUTTON_LABEL = "&替换路径宏（仅限绝对路径）"
NO_PLATFORM_DIRS_IN_PATH = "&替换路径宏（路径中没有平台目录）"
ADD_BUTTON_LABEL = "添加"
REMOVE_BUTTON_LABEL = "删除"
REMOVE_ALL_BUTTON_LABEL = "全部移除(&M)"
DIRECTORY_HISTORY_COMBO_LABEL = "&目录历史："
SELECTED_PATHS_LIST_CTRL_LABEL = "&Selected 路径："
READ_ONLY_CHECK_LABEL = "以只读方式打开(&R)"
FILE_NAME_EDIT_LABEL = "文件名："
FILE_TYPE_FILTER_COMBO_LABEL = "文件类型："

FOLDER_DOES_NOT_EXIST = "%1\n文件夹不存在。"
FILE_ALREADY_EXISTS = "%1\n文件已经存在。\n你必须使用不同的文件名。"
FILE_NOT_FOUND_DLG_TITLE = "找不到文件 %1"
DIR_NOT_FOUND_DLG_TITLE = "找不到目录 %1"
DIR_NOT_ACCESSIBLE_MSG = "目录 '%1' 不存在或不可访问。"
FILE_NOT_FOUND_MSG_TEXT = "您选择的文件不在任何搜索目录中。选择以下选项之一来解析路径。"
DIR_NOT_FOUND_MSG_TEXT = "您选择的目录不在任何搜索目录中。选择以下选项之一来解析路径。"


ADD_TO_SEARCHDIR_RADIO_LABEL = "将包含你选择的文件的目录添加到搜索目录列表中"

DIR_ADD_TO_SEARCHDIR_RADIO_LABEL = "将包含你选择的目录的目录添加到搜索目录列表中"

USE_ABSOLUTE_PATH_RADIO_LABEL = "为您选择的文件使用绝对路径(&B):"
DIR_USE_ABSOLUTE_PATH_RADIO_LABEL = "为您选择的目录使用一个绝对路径(&B)："
USE_RELATIVE_PATH_RADIO_LABEL = "为你选择的文件使用相对路径:"
DIR_USE_RELATIVE_PATH_RADIO_LABEL = "使用你选择的目录的相对路径："

DIFF_FILE_FOUND_DLG_TITLE = "文件冲突"
DIFF_DIR_FOUND_DLG_TITLE = "目录冲突"

DIFF_FILE_FOUND_MSG_TEXT = "在以下位置的搜索目录中找到了一个与您选择的文件同名的文件："
DIFF_DIR_FOUND_MSG_TEXT = "在以下位置的搜索目录中找到了一个与您选择的目录同名的目录："
DIFF_FILE_FOUND_CHOOSE_TEXT = "选择以下选项之一："

USE_ENGINE_PATH_RADIO_LABEL = "为上面显示的 &file 使用相对路径。"
DIR_USE_ENGINE_PATH_RADIO_LABEL = "为上面显示的 &directory 使用相对路径。"

TESTSTAND_DIR_HISTORY_TEXT = "<TestStand 目录>"
TESTSTAND_PUBLIC_DIR_HISTORY_TEXT = "<TestStand 公共目录>"

CURRENT_FOLDER_BUTTON_LABEL = "当前文件夹"

[PERSISTED_OPTION_DLG]
DLG_TITLE = "编辑断点/观察表达式"
BREAK_DLG_TITLE = "编辑断点"
WATCH_DLG_TITLE = "编辑监视表达式"
DONE_BTN = "完成"
EDIT_BTN = "编辑"
ADD_BTN = "添加"
OPEN_BTN = "11转到"
EXPAND_BTN = "扩展&xpand"
EXPAND_ALL_BTN = "全部展开"
DELETE_BTN = "删除"
DELETE_ALL_BTN = "删除A&ll"
COLLAPSE_ALL_BTN = "&Collapse All"
BREAKPOINT_PAGE_TITLE = "断点"
WATCHEXPRESSION_PAGE_TITLE = "观看表达式"
BREAK_AT = "断点："
ENABLED="启用"
EXPRESSION = "观察表达式："
BREAKPOINT = "断点"
GLOBAL_WATCH_EXPRESSIONS = "全局监视表达式"
MISMATCHED_STEP_NAME = "无法在序列文件中找到与索引 %1 处的断点关联的步骤。"
BREAKTYPE_NONE_BTN_LABEL = "无"
BREAKTYPE_VALUE_BTN_LABEL = "改变"
BREAKTYPE_CONDITION_BTN_LABEL = "为真时"

[PRECOND_BUILDER_DLG]
DLG_TITLE = "先决条件"
PRECOND_LABEL = "条件："
SYNTAX_ERROR_IN_EXPR_TEXT = "表达式"

[PRECOND_EDIT_DLG]
DLG_TITLE = "先决条件 - %1"
SEQUENCE_LABEL = "步骤分组："
PRECOND_LABEL = "先决条件："
COND_LABEL = "条件："
PRECOND_LABEL_WITH_STEP = "‘%1’的先决条件&条件："

INSERT_EXPR_BUTTON_LABEL = "&插入新表达式"
INSERT_ANYOF_BUTTON_LABEL = "插入一个&yOf"
INSERT_ALLOF_BUTTON_LABEL = "插入一个&llOf"
UNGROUP_BUTTON_LABEL = "&CANCEL分组"
INSERT_STEP_PASS_BUTTON_LABEL = "插入步骤"
INSERT_STEP_FAIL_BUTTON_LABEL = "插入步骤失败"
INSERT_STEP_EXECUTED_BUTTON_LABEL = "插入步骤 E&X"
INSERT_STEP_ERROR_BUTTON_LABEL = "插入步骤&错误"
EDIT_STEP_LABEL = "&步骤："

CHANGE_GROUP_BUTTON_LABEL = "更改组"
CHANGE_TO_ALL_OF_BUTTON_LABEL = "更改为 AllOf"
CHANGE_TO_ANY_OF_BUTTON_LABEL = "更改为 AnyOf(&H)"

EDIT_EXPR_GROUP_LABEL = "编辑/&查看表达式"
INSERT_STEP_GROUP_LABEL = "插入步骤状态"
INSERT_NEGATE_CHECK = "&否定"
PRECOND_ANYOF_TEXT = "AnyOf"
PRECOND_ALLOF_TEXT = "全部"
PRECOND_BEGIN_GROUP_FORMAT = "%1:"
PRECOND_END_GROUP_FORMAT = "结束22 %1"
PRECOND_STEP_STATUS_FORMAT = "%1 %2"
PRECOND_NEGATE_STATUS_FORMAT = "不是 %1 %2"
PRECOND_EXPR_FORMAT = "%1"
PRECOND_PASS_TEXT = "通过"
PRECOND_FAIL_TEXT = "失败"
PRECOND_ERROR_TEXT = "错误"
PRECOND_EXECUTED_TEXT = "已执行"
DELETE_GROUP_WARNING_TEXT = "你想删除组中的所有项目吗？"
DELETE_GROUP_WARNING_TITLE = "先决条件编辑器"
SYNTAX_ERROR_IN_EXPR_TEXT = "步骤 %1 的前置条件表达式"
INSERT_GROUP_DIALOG_TITLE = "先决条件编辑器"
INSERT_GROUP_DIALOG_TEXT = "你想如何将这个条件与前一个条件分组？"
CUT_BUTTON_LABEL = "剪切"
COPY_BUTTON_LABEL = "复制"
PASTE_BUTTON_LABEL = "粘贴"

[PTR_OBJ_DLG]
STRING_DLG_TITLE = "修改字符串值"
NUMBER_DLG_TITLE = "修改数值"
BOOLEAN_DLG_TITLE = "修改布尔值"
REF_DLG_TITLE = "修改参考值"
NAME_LABEL = "名称："
STRING_VALUE_LABEL = "字符串 & 值："
NUMERIC_VALUE_LABEL = "数值&值："
BOOLEAN_VALUE_LABEL = "布尔值&值："
REF_VALUE_LABEL = "参考&值："
REF_RELEASE_VALUE_BTN_LABEL = "&Release"

[RECONCILE_TYPE_OPTION_DLG]
UNLOCK_TYPE_DEF_TO_RECONCILE_TITLE = "解锁类型以解决冲突"
UNLOCK_TYPE_DEF_TO_RECONCILE_MSG Line0001 = "位于 '%2' 中的类型 '%1' 当前已锁定，不能因类型冲突而被替换 "
UNLOCK_TYPE_DEF_TO_RECONCILE_MSG Line0002 = "解决方案，除非你解锁它。如果你想继续，请输入密码来解锁这种类型。"
UNLOCK_TYPE_DEF_TO_RECONCILE_MSG_RENAME Line0001 = "位于 '%2' 中的类型 '%1' 当前已锁定，无法通过类型冲突重命名 "
UNLOCK_TYPE_DEF_TO_RECONCILE_MSG_RENAME Line0002 = "除非你解锁它才能解决。如果你想继续，请输入密码来解锁这种类型。"
UNLOCK_TYPE_DEF_TO_RECONCILE_MSG_UNKNOWN_LOCATION = "<未知>"
DLG_TITLE = "文件类型冲突"
OPTIONS_STATIC = "选项："
RENAME_TYPE_IN_FILE_LABEL = "在 %1 中重命名类型"
RENAME_LOCAL_TYPE_LABEL = "重命名正在读取的类型(&R)"
RENAME_TYPE_IN_TESTSTAND_LABEL = "重新命名当前加载的类型(&A)"
NOT_AVAILABLE_WHILE_RUNNING = "（运行时不可用）"
USE_TYPEDEF_FROM_FILE = "&使用来自 %1 的类型"
USE_LOCAL_TYPEDEF = "&Use 正在读取的类型"
USE_TYPEDEF_FROM_TESTSTAND = "使用当前加载的类型(&S)"
DLG_MESSAGE Line0001 = "%3 (%4) 中的类型 '%1' 与当前加载的类型 '%2' 不同。\n"
DLG_MESSAGE Line0002 = "\n"
DLG_MESSAGE Line0003 = "当前加载类型\n"
DLG_MESSAGE Line0004 = "版本 %5\n"
DLG_MESSAGE Line0005 = "最后修改：%7 (%9)\n"
DLG_MESSAGE Line0006 = "类别：%11\n"
DLG_MESSAGE Line0007 = "位置：%12\n"
DLG_MESSAGE Line0008 = "\n"
DLG_MESSAGE Line0009 = "输入文件\n"
DLG_MESSAGE Line0010 = "版本 %6\n"
DLG_MESSAGE Line0011 = "最后修改：%8 (%10)\n"
DLG_MESSAGE Line0012 = "类别：%13\n"
DLG_MESSAGE Line0013 = "位置：%14\n"
DLG_MESSAGE Line0014 = "\n"
DLG_MESSAGE Line0015 = "差异汇总：\n"
DLG_MESSAGE Line0016 = "\n"
DLG_MESSAGE Line0017 = "%15"
DLG_MESSAGE_NO_FILE Line0001 = "正在读取的类型 '%1' 与当前加载的类型 '%2' 不同。\n"
DLG_MESSAGE_NO_FILE Line0002 = "\n"
DLG_MESSAGE_NO_FILE Line0003 = "当前加载类型\n"
DLG_MESSAGE_NO_FILE Line0004 = "版本 %5\n"
DLG_MESSAGE_NO_FILE Line0005 = "最后修改：%7 (%9)\n"
DLG_MESSAGE_NO_FILE Line0006 = "类别：%11\n"
DLG_MESSAGE_NO_FILE Line0007 = "位置：%12\n"
DLG_MESSAGE_NO_FILE Line0008 = "\n"
DLG_MESSAGE_NO_FILE Line0009 = "冲突类型\n"
DLG_MESSAGE_NO_FILE Line0010 = "版本 %6\n"
DLG_MESSAGE_NO_FILE Line0011 = "最后修改：%8 (%10)\n"
DLG_MESSAGE_NO_FILE Line0012 = "类别：%13\n"
DLG_MESSAGE_NO_FILE Line0013 = "\n"
DLG_MESSAGE_NO_FILE Line0014 = "差异汇总：\n"
DLG_MESSAGE_NO_FILE Line0015 = "\n"
DLG_MESSAGE_NO_FILE Line0016 = "%15"
MODIFIED_VERSION_FMT = "%1（已修改）"
NEWER = "较新"
OLDER="年长"
SAMETIME = "两种类型相同"
ONLY_IN_NEWER_TYPE = "%1（已添加）"
ONLY_IN_OLDER_TYPE = "%1（已删除）"
DIFFERS_BETWEEN_TYPES = "%1（值、标志或表示差异）"
OUT_OF_ORDER = "%1（已移动）"
INVALID_IDENTIFIER = "'%1' 不是有效的类型名称。类型名称只能包含字母、数字和下划线，不能包含空格或以数字开头。"
RENAME_TYPE = "使用不同的类型名称。"
RENAME_TYPE_IN_TESTSTAND_TO_EXISTING_TYPE_IN_TESTSTAND = "类型 '%1' 已经存在。\n你想将类型 '%2' 的所有实例\n转换为使用类型 '%3'吗？"
RENAME_TYPE_IN_FILE_TO_EXISTING_TYPE_IN_TESTSTAND = "类型 '%1' 已经存在。\n你想转换类型 '%2' 的所有实例\n %3 以使用现有类型 '%4'吗？"
RENAME_LOCAL_TYPE_TO_EXISTING_TYPE_IN_TESTSTAND = "类型 '%1' 已经存在。\n你想转换正在读取的对象中类型 '%2' 的所有实例\n以使用现有类型 '%4'吗？"
APPLY_TO_ALL = "将选项应用于文件中的所有冲突(&A)"
EXECUTION_RUNNING_WARNING Line0001 = "更新类型无法自动加载，因为执行正在运行。"
EXECUTION_RUNNING_WARNING Line0002 = "您可以通过选择CANCEL来加载类型，终止所有执行，然后手动加载包含较新类型的文件。\n\n"
[RENGINE_ABOUT_DLG]
ABOUT_TITLE = "关于 TestStand 远程引擎"
ABOUT_TEXT_1 = "NI TestStand 远程引擎"
ABOUT_TEXT_2 = "美国国家仪器公司"
OK = "确定"

[RTE_DLG]
DLG_TITLE = "运行时错误"
OPTIONS = "处理当前错误"
RUN_CLEANUP = "运行清理"
CONTINUE_CLEANUP = "继续 "
IGNORE_ERROR = "&忽略"
RETRY="重试"
ABORT_IMMEDIATELY = "&立即中止（不清理）"
MORE_INFO = "&更多信息..."
COPY_TEXT = "&复制"
BREAK = "&中断"
SUPPRESS_DLG_FOR_THIS_EXE = "不再为这次执行显示对话框(&A)"
详细信息 = "详细信息："
ERROR_CODE = "错误代码："
LOCATION="位置："
SUPPRESS_DLG_FOR_BATCH = "不再为该批次显示对话框(&D)"

[SAVE_CONFLICT_DLG]
GENERIC_MESSAGE = "文件 %1 的内存内容在此会话中已更改。\n\n与此同时，另一个应用程序已将不同的更改写入 %2。\n\n您是否要："
STATION_GLOBALS_MESSAGE = "站点全局变量已在此会话中更改。\n\n与此同时，另一个应用程序已将不同的更改写入文件 %1。\n\n您是否要："
STATION_TEMPLATES_MESSAGE = "此会话中的模板已更改。\n\n与此同时，另一个应用程序已将不同的更改写入模板文件 %1。\n\n您是否要："
SAVE_BTN_LABEL = "&Save changes and overwrite %1"
DONT_SAVE_BTN_LABEL = "&不保存更改并保留 %1"
TITLE = "解决文件保存冲突"

[SCC_OPERATIONS_DLG]
ADD_DLG_TITLE = "添加到源代码控制"
CHECKOUT_DLG_TITLE = "签出文件"
CHECKIN_DLG_TITLE = "签入文件"
UNDO_CHECKOUT_DLG_TITLE = "撤消检出"
GET_LATEST_VERSION_DLG_TITLE = "获取最新版本"
REMOVE_FROM_SCC_DLG_TITLE = "从源代码控制中移除"
SELECT_ALL_BTN_LABEL = "选择 A&LL"
ADVANCED_BTN_LABEL = "高级..."
DIFFERENCES_BTN_LABEL = "&差异..."
FILE_LIST_LABEL = "&文件:"
KEEP_CHECKOUT_LABEL = "&保持签出"
COMMENT_LABEL = "&评论"

[SEARCH_DIR]
TE_DIR_DISPLAY_STRING = "TestStand 目录 (%1)"
TESTSTAND_PUBDOC_DIR_DISPLAY_STRING = "TestStand 公共目录 (%1)"
TE_BIN_DIR_DISPLAY_STRING = "TestStand bin 目录 (%1)"
ADAPTER_SUPPORT_DIR_DISPLAY_STRING = "适配器支持目录 (%1)"
GUI_EXE_DIR_DISPLAY_STRING = "应用程序目录 (%1)"
INIT_WORKING_DIR_DISPLAY_STRING = "初始工作目录 (%1)"
WINDOWS_SYSTEM_DIR_DISPLAY_STRING = "Windows 系统目录 (%1)"
WINDOWS_DIR_DISPLAY_STRING = "Windows 目录 (%1)"
PATH_ENV_VAR_DIR_DISPLAY_STRING = "路径环境变量"
CURRENT_SEQFILE_DIR_DISPLAY_STRING = "当前序列文件目录"
CURRENT_WORKSPACE_DIR_DISPLAY_STRING = "当前工作区目录（%1）"
CURRENT_WORKSPACE_DIR_NONE_DISPLAY_STRING = "<未加载>"
CONTAINING_PROJECT_DIR_DISPLAY_STRING = "包含项目目录"

USER_COMPONENTS_DIR_DISPLAY_STRING = "公共组件目录 (%1)"
NI_COMPONENTS_DIR_DISPLAY_STRING = "TestStand 组件目录 (%1)"

[SEARCH_DIR_DLG]
DLG_TITLE = "编辑搜索目录"
PATH_COLUMN_LABEL = "路径"
DIR_NOT_FOUND_COLUMN_LABEL = "状态"
SEARCH_SUBDIRS_COLUMN_LABEL = "子目录"
EXCLUDE_HIDDEN_SUBDIRS_COLUMN_LABEL = "排除隐藏"
FILE_EXT_RESTRICTIONS_COLUMN_LABEL = "文件扩展名"
MOVE_DOWN_BUTTON_LABEL = "向下移动(&D)"
MOVE_UP_BUTTON_LABEL = "向上移动(&U)"
SEARCH_SUBDIR_CHECK_LABEL = "搜索子目录&b"
EXCLUDE_HIDDEN_SUBDIRS_CHECK_LABEL = "排除隐藏子目录(&I)"
EXCLUDE_FILE_EXT_CHECK_LABEL = "E&xclude"
DELETE_BUTTON_LABEL = "&删除"
ADD_BUTTON_LABEL = "&添加..."
EDIT_BUTTON_LABEL = "更改..."
FILE_EXT_GROUP_LABEL = "&文件扩展名限制"
LIST_LABEL = "搜索目录："
SEARCH_SUB_DIRS_COLUMN_TEXT = "子目录"
DIR_NOT_FOUND_COLUMN_TEXT = "未找到"
STEP_MODULES_LOADED_WARNING_MESSAGE = "一个或多个步骤已加载模块。在重新加载模块之前，对搜索目录的更改不会影响这些步骤的执行。"
MESSAGE_BOX_TITLE = "搜索目录"
INVALID_FILE_EXT_MESSAGE = "无效的文件扩展名列表。\n用逗号 (,) 或分号 (;) 分隔扩展名。每个文件扩展名不得超过 %1 个字符。"
FILE_EXT_EXCLUDE_PREFIX_TEXT = "~"

[SELECT_TEFILES_DLG]
DLG_TITLE = "编辑文件中的路径"
FILE_LIST_LABEL = "选择包含您要编辑的路径的文件："
ADD_FILES_BUTTON_LABEL = "&添加文件..."

[SELECT_DIR_DLG]
DLG_TITLE = "选择目录"
DIR_PATH_LABEL = "目录："

[SEQFILE_CALLBACK_DLG]
DLG_TITLE = "选择 %1 回调"
CALLBACK_NAME_HEADER = "回调名称"
CALLBACK_TYPE_HEADER = "回调类型"
CALLBACK_PRESENT_HEADER = "现在"
RESERVED_CALLBACK_TYPE = "引擎回调"
MODEL_CALLBACK_TYPE = "模型回调"

[PASSWORD_PROTECT_TYPES_DLG]
DLG_TITLE = "密码保护类型"
CLEAR_PASSWORD_HISTORY = "清除密码历史"
NEW_PASSWORD_LABEL = "新密码："
REENTER_PASSWORD_LABEL = "重新输入密码："
ENABLE_PASSWORD_PROTECTION_CHECKBOX = "启用密码保护"
MULTIPLE_PASSWORD_VALUES = "<多个值>"
INCORRECT_PASSWORD_TITLE = "密码不正确"
PASSWORD_MISMATCH = "重新输入的密码与新密码不匹配。"

[SEQFILE_PROP_DLG]
FILE_FORMAT_LBL = "文件格式："
DLG_TITLE = "%1 属性"
GENERAL_PAGE_TITLE = "一般"
ADVANCED_PAGE_TITLE = "高级"
COMMENT_LABEL = "&评论："
ADVANCED_BUTTON_LABEL = "高级..."
VERSION_LABEL = "&版本:"
LOAD_OPTION_USE_STEP_OPTION = "使用分步加载选项"
UNLOAD_OPTION_USE_STEP_OPTION = "使用分步卸载选项"
LOAD_OPTION_LABEL = "&加载选项："
UNLOAD_OPTION_LABEL = "&卸载选项："
SFGLOBALS_SCOPE_OPTION_LABEL = "序列文件和全局变量："
SFGLOBALS_SCOPE_OPT_PER_EXECUTION = "为每次执行分离文件全局"
SFGLOBALS_SCOPE_OPT_SHARED = "所有执行共享同一个文件全局"
TYPE_LABEL = "&类型:"
MODEL_FILE_LABEL = "型号和文件："
BROWSE_DLG_TITLE = "选择模型文件"
NORMAL_TYPE_TEXT = "正常"
MODEL_TYPE_TEXT = "模型"
FRONTEND_CALLBACKS_TYPE_TEXT = "前端回调"
TESTSTAND_CALLBACKS_TYPE_TEXT = "站点回调"
TEMPLATE_TYPE_TEXT = "保留"
FULL_PATH_LABEL = "完整路径："
FILE_SIZE_LABEL = "尺寸："
DATE_SAVED_LABEL = "已保存："
MODEL_OPTION_LABEL = "&模型选项："
USE_TESTSTAND_MODEL_OPTION_TEXT = "使用站模型"
NO_MODEL_OPTION_TEXT = "无模型"
REQUIRE_SPECIFIC_MODEL_OPTION_TEXT = "需要特定型号"
REQUIRED_MODEL_NOT_TESTSTAND_MODEL_MSG Line0001 = "无法将模型设置为指定的文件。您必须启用允许其他模型选项\n"
REQUIRED_MODEL_NOT_TESTSTAND_MODEL_MSG Line0002 = "或在站选项对话框中将站模型更改为'%1'。"
REQUIRED_MODEL_NOT_FOUND_AND_NOT_TESTSTAND_MODEL_MSG = "无法将模型设置为指定的文件。您必须在站点选项对话框中启用允许其他模型选项。"
REQUIRED_EDIT_PROCESS_MODEL_PRIVILEGE_MSG Line0001 = "无法将序列文件的类型更改为 '%1'。\n您没有必要的权限来编辑 '%2' 文件。"

REQUIRED_MODEL_NOT_TESTSTAND_MODEL_TITLE = "无效模型文件"
REQUIRED_EDIT_PROCESS_MODEL_PRIVILEGE_TITLE = "权限不足"

PASSWORD_TITLE = "密码不正确"
PASSWORD_CANNOT_LOCK = "无法锁定文件，因为重新输入的密码与新密码不匹配。"
PASSWORD_CANNOT_UNLOCK = "无法解锁文件，因为密码不正确。"
PASSWORD_MISMATCH = "密码已更改。重新输入的密码与新密码不匹配。"
PASSWORD_PROTECTION_LABEL = "密码保护(&P)"
PROTECTION_DISABLED_TEXT = "禁用"
PROTECTION_NOT_EDITABLE_TEXT = "不可编辑"
PROTECTION_NOT_VIEWABLE_TEXT = "不可见"
LOCK_BUTTON_TEXT = "锁定"
UNLOCK_BUTTON_TEXT = "解锁"
PASSWORD_LABEL = "密码："
NEW_PASSWORD_LABEL = "新密码："
REENTER_PASSWORD_LABEL = "重新输入密码："

&ATTRIBUTES = "&属性..."

INVALID_VERSION_TITLE = "无效值"
INVALID_VERSION_MSG = "%1 不是有效的文件版本。\n格式应为 \"#.#.#.#\"。\n\n是否要修复版本？\n（选择 \"No\" 恢复前一个值）"
OLDER_VERSION_TITLE = "版本较旧"
OLDER_VERSION_MSG Line0001 = "您输入的版本 (%1) 比当前文件版本 (%2) 旧。\n\n"
OLDER_VERSION_MSG Line0002 = "你想更改文件以使用旧版本吗？"
SAME_VERSION_TITLE = "版本相同"
SAME_VERSION_MSG Line0001 = "您输入的版本 (%1) 等同于当前文件版本 (%2)。\n\n"
SAME_VERSION_MSG Line0002 = "确认您输入了正确的版本。"
CONFIRM_VERSION_TITLE = "确认新版本"
CONFIRM_VERSION_MSG = "此文件的版本将从 '%1' 更新到 '%2'。这是否正确？"

;;同步页面
SYNC_PAGE_TITLE = "同步"
BATCH_SYNC_OPT_LBL = "&Batch Synchronization:\n（仅在使用批处理模型执行序列时使用此设置。）"
BATCH_SYNC_USE_BATCH = "使用模型设置"
BATCH_SYNC_DONT_SYNC = "无同步"
BATCH_SYNC_SERIAL = "串行（一次一个线程）"
BATCH_SYNC_PAR = "并行（所有线程同时进入）"
BATCH_SYNC_ONE_THREAD_ONLY = "只有一个线程（第一个线程执行步骤，其余线程跳过）"

[SEQUENCE_PROP_DLG]
DLG_TITLE = "%1 属性"
GENERAL_PAGE_TITLE = "一般"
ADVANCED_PAGE_TITLE = "模型"
COMMENT_LABEL = "评论："
ADVANCED_BUTTON_LABEL = "高级..."
PRECOND_EDIT_BUTTON_LABEL = "先决条件..."
STEP_FAILURE_ACTION_LABEL = "步骤失败："
STEP_FAILURE_ACTION_NONE = "无操作"
STEP_FAILURE_ACTION_GOTO_CLEANUP = "转到清理"
STEP_FAILURE_ACTION_USE_STATION_OPTION = "使用站选项"
OPTIMIZE_NON_REENTRANT_CALLS_LABEL = "优化&mize 对此序列的非重入调用"
OPTIMIZE_NON_REENTRANT_CALLS_WARNING = "（如果序列依赖于您在序列执行期间更改的初始步骤属性值，请不要启用此选项。）"
DISABLE_RESULTS_LABEL = "禁用所有步骤的结果记录(&D)"
TYPE_LABEL = "类型:"
ENTRY_POINT_LABEL = "入口点 名称表达式："
ENTRY_POINT_ENABLE_LABEL = "入口点启用表达式："
NORMAL_TYPE_TEXT = "正常"
CALLBACK_TYPE_TEXT = "回调"
EDIT_ENTRY_POINT_TYPE_TEXT = "编辑入口点"
EXEC_ENTRY_POINT_TYPE_TEXT = "执行入口点"
DEBUG_ENTRY_POINT_TYPE_TEXT = "调试入口点"
CONFIG_ENTRY_POINT_TYPE_TEXT = "配置入口点"
CONVERT_ENTRY_POINT_TYPE_TEXT = "转换入口点"
ENTRY_POINT_NAME_EXPR_ERROR = "入口点名称表达式"
ENTRY_POINT_ENABLE_EXPR_ERROR = "入口点启用表达式"
ENTRY_POINT_MENU_HINT_LABEL = "&菜单提示："
COPY_STEPS_ON_OVERRIDING_CHECK = "创建覆盖序列时复制步骤和局部变量(&C)"

IGNORE_CLIENT_LABEL = "入口点 &Ignores 客户端文件"
INITIALLY_HIDDEN_LABEL = "隐藏入口点执行"
CHECK_TO_SAVE_TITLED_FILES_LABEL = "执行前保存修改后的序列文件"

SHOW_ENTRY_POINT_FOR_FILE_WIN_LABEL = "客户端文件窗口激活时显示入口点(&C)"
SHOW_ENTRY_POINT_FOR_EXE_WIN_LABEL = "执行窗口处于活动状态时显示入口点"
SHOW_ENTRY_POINT_ALWAYS_LABEL = "显示所有窗口的入口点(&A)"
SHOW_ENTRY_POINT_FOR_EDITOR_ONLY_LABEL = "仅在编辑器中显示入口点(&D)"
ALLOW_INTERACTIVE_EXE_OF_ENTRY_POINT_LABEL = "入口点的交互执行&l"

[SIMPLE_OBJECT_PROP_SHEET]
TESTOBJECT_TITLE = "一般"
TESTOBJECT_TYPE = "类型："
TESTOBJECT TYPE TEXT = "**在此处输入对象类型名称**"
TESTOBJECT_VALUE = "这个属性对象没有值。"
NUMOBJ_TITLE = "一般"
NUMOBJ_TYPE = "类型："
NUMOBJ_VALUE = "值:"
FORMATTED_NUM = "格式化值："
NUMOBJ_APPLY_TO_INSTANCES = "将值应用于该类型的所有已加载实例(&I)"
ENUMOBJ_TITLE = "一般"
ENUMOBJ_TYPE = "类型："
ENUMOBJ_VALUE = "值:"
FORMATTED_ENUM = "格式化值："
ENUMOBJ_APPLY_TO_INSTANCES = "将值应用于该类型的所有已加载实例(&I)"
STROBJ_TITLE = "一般"
STROBJ_TYPE = "类型："
STROBJ_VALUE = "值:"
STROBJ_APPLY_TO_INSTANCES = "将值应用于该类型的所有已加载实例(&I)"
BOOLOBJ_TITLE = "一般"
BOOLOBJ_TYPE = "类型："
BOOLOBJ_VALUE = "值:"
BOOLOBJ_APPLY_TO_INSTANCES = "将值应用于该类型的所有加载实例(&I)"
REFOBJ_TITLE = "一般"
REFOBJ_TYPE = "类型："
REFOBJ_VALUE = "值:"
REFOBJ_RELEASE = "&Release"
ARRAYBOUNDS_TITLE = "边界"
ARRAYBOUNDS_DIMENSION_STRING = "尺寸字符串："
ARRAYBOUNDS_NUM_DIMENSIONS = "维数："
ARRAYBOUNDS_INITIAL_EMPTY = "空"
ARRAYBOUNDS_LOWER_BOUND = "下限："
ARRAYBOUNDS_UPPER_BOUND = "上限："
ARRAYBOUNDS_APPLY_TO_INSTANCES = "将边界应用于该类型的所有已加载实例(&I)。"
ARRAYBOUNDS_DIMENSIONS_OUT_OF_RANGE = "数组维度 %1 超出范围 (%2-%3)。"
ARRAYBOUNDS_LOWER_BOUNDS_GREATER_THAN_UPPER_BOUNDS = "下限不能大于上限。"
ATTACH_TO_FILE_LABEL = "附加到这个文件(如果你不附加类型，只有当这个文件包含类型的实例时，TestStand 才会将类型和文件一起保存。)"
COMMENT_LABEL = "评论："
&ADVANCED = "高级"
&FLAGS = "标志..."
&ATTRIBUTES = "属性..."
EDIT_NUM_FORMAT_BUTTON_LABEL = "数字格式..."

[ADDITIONAL_RESULTS_DLG]
DLG_TITLE = "配置附加结果"

[STEP_PROP_DLG]
STEP_HAS_NO_PARENT = "无法显示不属于序列和序列文件的步骤的属性对话框。"
DLG_TITLE = "%1 步骤属性"
GENERAL_PAGE_TITLE = "一般"
COMMENT_LABEL = "&评论："
DESCRIPTION_LABEL = "描述："
ADAPTER_LABEL = "适配器："
STEP_TYPE_LABEL = "类型："
PRECOND_BUTTON_LABEL = "&先决条件..."
ADDITIONAL_RESULTS_BUTTON_LABEL = "额外的结果..."
CHANGE_TYPE_BUTTON_LABEL = "改变步骤&类型"
SPECIFY_MODULE_BUTTON_LABEL = "指定模块..."
ADVANCED_BUTTON_LABEL = "高级..."
HAS_MODULE_LABEL = "有模块"
POSTACTION_PAGE_TITLE = "发布操作"
ONFAIL_LABEL = "开启失败："
ONPASS_LABEL = "通过并通过："
CUSTOM_TRUE_LABEL = "条件为真："
CUSTOM_FALSE_LABEL = "条件错误&lse:"
CUSTOM_CONDITION_CHECK_LABEL = "&指定自定义条件"
CUSTOM_CONDITION_EDIT_LABEL = "自定义条件表达式&xpression："
GOTO_STEP_LABEL = "&Destination Step (ID or Name):"
CALLBACK_STEP_LABEL = "顺序(&Q):"
ACTION_GOTO_STEP = "转到目的地"
ACTION_TERMINATE_EXECUTION = "终止执行"
ACTION_GOTO_NEXT = "转到下一步"
ACTION_CALLBACK = "调用顺序"
ACTION_BREAK = "中断"

RUNOPTION_PAGE_TITLE = "运行选项"
LOAD_OPTION_LABEL = "&加载选项："
UNLOAD_OPTION_LABEL = "&卸载选项："
RUN_MODE_LABEL = "运行&模式："
BREAKPOINT_LABEL = "断点设置(&B)"
BREAKPOINT_CHECKBOX_LABEL = "&设置断点"
CONFIGURE_BREAKPOINT_BUTTON_LABEL = "&配置"
STEP_FAIL_CAUSES_SEQ_FAIL_LABEL = "步骤失败导致序列失败"
EVAL_PRECOND_FOR_INT_EXE_LABEL = "交互模式下的先决条件评估："
EVAL_PRECOND_USE_STATION_OPTION = "使用站选项"
EVAL_PRECOND_DO_EVAL = "评估先决条件"
EVAL_PRECOND_DONT_EVAL = "不评估前提条件"
RESULT_RECORDING_OPTION_DISABLED = "禁用"
RESULT_RECORDING_OPTION_ENABLED = "启用"
RESULT_RECORDING_OPTION_ENABLED_OVERRIDE_SEQUENCE_SETTING = "启用 - 覆盖序列设置"
RESULT_RECORDING_OPTION_LABEL = "&结果记录："
IGNORE_RTE_LABEL = "&忽略运行时错误"
IGNORE_TERMINATION_LABEL = "忽略终止(&I)"
LOAD_OPTION_PRELOAD_WHEN_OPEN = "打开序列文件时预加载"
LOAD_OPTION_PRELOAD_WHEN_EXEC = "执行开始时预加载"
LOAD_OPTION_DYNAMIC = "动态加载"
UNLOAD_OPTION_ON_PRECOND_FAIL = "前提条件失败时卸载"
UNLOAD_OPTION_AFTER_STEP_EXEC = "步骤执行后卸载"
UNLOAD_OPTION_AFTER_SEQ_EXEC = "序列执行后卸载"
UNLOAD_OPTION_WHEN_CLOSED = "序列文件关闭时卸载"
UNLOAD_OPTION_NEVER = "从不卸载"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0001 = "您对此步骤的加载选项所做的更改无效"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0002 = "因为序列文件加载选项覆盖了步进加载选项。"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0003 = "使用序列文件属性对话框更改序列文件加载选项。"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0001 = "您对此步骤的卸载选项所做的更改无效"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0002 = "因为序列文件卸载选项覆盖了步骤卸载选项。"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0003 = "使用序列文件属性对话框更改序列文件卸载选项。"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0001 = "您对此序列调用步骤的加载选项所做的更改无效"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0002 = "因为仅在运行时计算的表达式指定了模块。"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0003 = "使用指定模块对话框更改指定模块的方式。"
IMMEDIATE_UNLOAD_SEQ_FILE_MESSAGE Line0001 = "如果你启用优化非重入调用到这个序列选项 "
IMMEDIATE_UNLOAD_SEQ_FILE_MESSAGE Line0002 = "对于调用的序列，包含该序列的序列文件执行"
IMMEDIATE_UNLOAD_SEQ_FILE_MESSAGE Line0003 = "直到执行结束才卸载。"
CHANGE_BUTTON_LABEL = "更改(&C)"
RUN_MODE_NORMAL = "正常"
RUN_MODE_SKIP = "跳过"
RUN_MODE_FORCE_PASS = "强制通过"
RUN_MODE_FORCE_FAIL = "强制失败"
WINDOW_ACTIVATION_LABEL = "&TestStand 窗口激活："
WIN_ACT_NONE = "不激活"
WIN_ACT_ACTIVATE_WHEN_STEP_COMPLETES = "步骤完成时激活"
WIN_ACT_IF_INITIALLY_ACTIVE_REACTIVATE = "如果最初激活，则在步骤完成时重新激活"
TRACE_LEAVE_ASIS = "使用当前轨迹设置"
TRACE_TURN_ON = "按顺序启用跟踪"
TRACE_TURN_OFF = "按顺序禁用跟踪"
TRACE_USE_EXE_DEFAULT = "使用初始执行设置"
SEQCALL_TRACE_LABEL = "序列调用跟踪设置(&A):"
LOOP_PAGE_TITLE = "循环选项"
LOOP_TYPE_LABEL = "循环&类型："
RECORD_ITER_RESULT_LABEL = "记录每次迭代的结果"
PASS_FAIL_TEXT1 = "Sto&p after"
PASS_FAIL_TEXT2 = "迭代"
PASS_FAIL_TEXT3 = "或在一个 &maximum 之后"
PASS_FAIL_TEXT4 = "迭代。"
FIXED_LOOP_NUM_LABEL = "&循环次数："
FIXED_RESULT_TEXT1 = "如果循环结果为&Fail"
FIXED_RESULT_TEXT2 = "% 的迭代通过。"
LOOP_WHILE_LABEL = "循环&While 表达式："
LOOP_RESULT_LABEL = "循环&状态表达式："
LOOP_INCREMENT_LABEL = "循环递增表达式(&I):"
LOOP_INITIALIZE_LABEL = "循环初始化表达式："
LOOP_TYPE_NONE = "无"
LOOP_TYPE_FIXED_NUMBER = "固定循环次数"
LOOP_TYPE_PASS_FAIL_COUNT = "通过/失败计数"
LOOP_TYPE_CUSTOM = "自定义"
LOOP_RESULT_PASS = "通过"
LOOP_RESULT_FAIL = "失败"
PASS_FAIL_RESULT = "如果 %2 %3 在 %4 次迭代中，循环结果为 %1。"
FIXED_PERCENT_ERR_MESSAGE = "百分比值无效。您必须输入 0 到 100 之间的有效数字。"

LOOP_WHILE_ERROR = "循环 while 表达式"
LOOP_RESULT_ERROR = "循环状态表达式"
LOOP_INCREMENT_ERROR = "循环增量表达式"
LOOP_INITIALIZE_ERROR = "循环初始化表达式"
FIXED_LOOP_NUM_ERR_MESSAGE = "无效循环计数。"
PASSFAIL_MAX_NUM_ERR_MESSAGE = "最大循环次数无效。"
PASSFAIL_FAIL_NUM_ERR_MESSAGE = "无效循环计数。"

POST_CUSTOM_ERROR = "自定义条件表达式"
PRECOND_EDIT_BUTTON_LABEL = "前提编辑器(&P)..."
ADVANCED_PAGE_TITLE = "表达式"
PRE_EXPR_LABEL = "&Pre-Expression:"
POST_EXPR_LABEL = "Pos&t-表达式："
STATUS_EXPR_LABEL = "&状态表达式："
PRE_EXPR_ERROR = "前表达式"
POST_EXPR_ERROR = "后表达式"
STATUS_EXPR_ERROR = "状态表达式"
GOTO_DESTINATION_ERROR = "目标表达式"
CALLBACK_ERROR = "序列表达式"

;;同步页面
SYNC_PAGE_TITLE = "同步"
MUTEX_CHECK_LABEL = "&Use Lock 一次只允许一个线程执行该步骤"
MUTEX_CHECK_COMMENT = "（锁在先决条件评估期间无效。）"
MUTEX_NAME_OR_REF_LBL = "&Lock Name or Reference Expression:\n（传递一个数组以在单个操作中锁定多个锁\n或者留空以使用该步骤独有的锁。）"
BATCH_SYNC_OPT_LBL = "&Batch Synchronization:\n（仅在使用批处理模型执行序列时使用此设置。）"
BATCH_SYNC_USE_SEQ_FILE = "使用序列文件设置"
BATCH_SYNC_USE_BATCH = "使用模型设置"
BATCH_SYNC_DONT_SYNC = "无同步"
BATCH_SYNC_SERIAL = "串行（一次一个线程）"
BATCH_SYNC_PAR = "并行（所有线程同时进入）"
BATCH_SYNC_ONE_THREAD_ONLY = "只有一个线程（第一个线程执行步骤，其余线程跳过）"
MUTEX_NAME_OR_REF_SYNTAX_ERROR = "锁定名称或引用表达式"

;;切换执行页面
SWITCH_PAGE_TITLE = "正在切换"
ENABLE_SWITCHING = "启用切换(&E)"
WAIT_FOR_DEBOUNCE = "&Wait for Debounce before Executing Step"
SE_VIRT_DEV = "&Switch Executive\n虚拟设备"
OPERATION = "操作&操作"
ROUTE_GROUP_TO_CONNECT = "路由\n到&Connect"
ROUTE_GROUP_TO_DISCONNECT = "路由\n到断开连接"
OPERATON_ORDER = "操作命令&r"
MULTICONNECT_MODE = "&多连接模式"
CONNECTION_LIFE_TIME = "连接和生命周期"
OPERATION_CONNECT = "连接"
OPERATION_DISCONNECT = "断开连接"
OPERATION_DISCONNECT_ALL = "全部断开连接"
OPERATION_CONNECT_DISCONNECT = "连接/断开连接"
OPERATION_FIND_ROUTE = "寻找路线"
CONNLIFETIME_MANUAL = "手动"
CONNLIFETIME_EXECUTION = "执行"
CONNLIFETIME_THREAD = "线程"
CONNLIFETIME_SEQUENCE = "序列"
CONNLIFETIME_STEP = "步骤"
BREAK_BEFORE_MAKE = "连接前断开"
BREAK_AFTER_MAKE = "连接后断开"
NO_MULTICONNECT = "没有多重连接"
MULTICONNECT_ROUTES = "多连接路由"
DEFAULT_MULTICONNECT_MODE = "为路由使用默认设置"
VIRTUAL_DEVICE_SYNTAX_ERROR = "虚拟设备表达式"
ROUTE_GROUP_CONNECT_SYNTAX_ERROR = "连接表达式"
ROUTE_GROUP_DISCONNECT_SYNTAX_ERROR = "断开表达式"

;;要求页面
REQ_PAGE_TITLE = "要求"
REQ_PAGE_REQ_LIST_LABEL = "需求列表："
REQ_PAGE_CLICK_TO_INSERT = "<插入新项目>"
REQ_PAGE_CANNOT_BE_EMPTY = "需求值不能为空。"

[STEP_TYPE_MENU_EDITOR]
DUPLICATE_STEP_TYPE_GROUPS = "无效的步骤类型组信息。检测到并删除了重复的步骤类型组。"
STEP_TYPE_MENU_EDITOR_TITLE = "步骤类型菜单编辑器"
PREVIEW = "&预览菜单"
TREE_LABEL = "&Groups and Step Types:"
NO_TEXT = ""
GROUP_SETTINGS_LABEL = "群组设置"
STEP_TYPE_SETTINGS_LABEL = "步骤类型设置"
MOVE_UP = "移动&上"
MOVE_DOWN = "向下移动(&D)"
ADD_GROUP = "&添加群组"
REMOVE_GROUP = "移除群组&ve"
REMOVE_TYPE = "删除类型(&V)"
RENAME_GROUP = "重新命名群组&#"
SEPARATOR = "&分隔符"
SUBMENU = "子菜单&b"
GROUP_NAME_EXPR = "子菜单显示名称表达式&xpression"
HELP = "帮助"
HIDDEN = "隐藏"
OK = "确定"
CANCEL = "取消"
NEW_GROUP_NAME_FORMAT = "组%1"
EMPTY_SUBMENU = "<空>"
CANNOT_RENAME_GROUP = "你不能重命名这个组。"
GROUP_NAME_EXISTS = "这个组名已经存在。"
CANNOT_REMOVE_GROUP = "你不能删除这个组。"
CANNOT_REMOVE_NONEMPTY_GROUP = "你不能删除这个组，因为它不是空的。"
CANNOT_REMOVE_TYPE = "您不能删除此类型，因为它仍在加载。您只能删除不再使用的类型。"

[BLOCK_STRUCTURE_DLG]
BLOCK_STRUCTURE = "块结构"
IS_BLOCK_STRUCTURE_STEP = "步进影响序列块结构"
BLOCK_START_STEP_TYPES = "阻止和启动步骤类型："
BLOCK_END_STEP_TYPES = "阻止结束步骤类型："
CAN_ENCAPSULATE_STEP = "可以围绕选择的步骤"
OK = "确定"
CANCEL = "取消"
HELP = "帮助"

[STEP_TYPE_PROP_DLG]
DLG_TITLE = "%1 步骤类型属性"
GENERAL_PAGE_TITLE = "一般"
DESIGNATE_ICON_CHECK = "指定一个&Icon："
DEFAULT_NAME_FORMAT_LABEL = "默认步骤名称表达式："
DESCRIPTION_FORMAT_LABEL = "步骤描述表达式："
DESIGNATE_ADAPTER_CHECK = "指定一个&适配器："
BROWSE = "浏览..."
SPECIFY_MODULE = "默认模块..."
PRECONDITIONS = "先决条件..."
ADVANCED = "高级..."
&FLAGS = "标志..."
&ATTRIBUTES = "&属性..."
&BLOCK_STRUCTURE = "&方块结构..."
DEFAULT_ADDITIONAL_&RESULTS = "默认附加结果..."
CONFIGURE_DEFAULT_ADDITIONAL_RESULTS = "配置默认附加结果"
&PRECONFIGURED_ADDITIONAL_RESULTS = "&Preconfigured 附加结果..."
CONFIGURE_PRECONFIGURED_ADDITIONAL_RESULTS = "配置预配置的附加结果"
COMMENT_LABEL = "&评论："
ATTACH_TO_FILE_LABEL = "附加到这个文件(&T) (如果你不附加类型，只有当这个文件包含类型的实例时，TestStand 才会将类型和文件一起保存。)"
CAN_BE_SUBSTEP_LABEL = "&可以是子步骤"
CAN_ONLY_BE_SUBSTEP_LABEL = "只能是子步骤&n"
BAD_FLAGS_FOR_STEP_TYPE_TITLE = "不可接受的旗帜"
BAD_FLAGS_FOR_STEP_TYPE_MSG = "只有步骤类型的属性可以共享或非结构化。这些标志已在步骤类型中清除。"
POSTACTION_PAGE_TITLE = "默认帖子操作"
ONFAIL_LABEL = "开启&失败："
ONPASS_LABEL = "通过并通过："
CUSTOM_TRUE_LABEL = "条件为真："
CUSTOM_FALSE_LABEL = "条件错误&lse:"
CUSTOM_CONDITION_CHECK_LABEL = "&指定自定义条件"
CUSTOM_CONDITION_EDIT_LABEL = "自定义条件表达式&xpression："
GOTO_STEP_LABEL = "&Destination Step (ID or Name):"
CALLBACK_STEP_LABEL = "顺序(&Q):"
ACTION_GOTO_STEP = "转到目的地"
ACTION_TERMINATE_EXECUTION = "终止执行"
ACTION_GOTO_NEXT = "转到下一步"
ACTION_CALLBACK = "调用顺序"
ACTION_BREAK = "中断"
RUNOPTION_PAGE_TITLE = "默认运行选项"
LOAD_OPTION_LABEL = "&加载选项："
UNLOAD_OPTION_LABEL = "&卸载选项："
RUN_MODE_LABEL = "运行&模式："
BREAKPOINT_LABEL = "&断点"
STEP_FAIL_CAUSES_SEQ_FAIL_LABEL = "步骤失败导致序列失败"
IGNORE_RTE_LABEL = "&忽略运行时错误"
IGNORE_TERMINATION_LABEL = "忽略终止(&I)"
LOAD_OPTION_PRELOAD_WHEN_OPEN = "打开序列文件时预加载"
LOAD_OPTION_PRELOAD_WHEN_EXEC = "执行开始时预加载"
LOAD_OPTION_DYNAMIC = "动态加载"
RESULT_RECORDING_OPTION_DISABLED = "禁用"
RESULT_RECORDING_OPTION_ENABLED = "启用"
RESULT_RECORDING_OPTION_ENABLED_OVERRIDE_SEQUENCE_SETTING = "启用 - 覆盖序列设置"
RESULT_RECORDING_OPTION_LABEL = "&结果记录"
UNLOAD_OPTION_ON_PRECOND_FAIL = "前提条件失败时卸载"
UNLOAD_OPTION_AFTER_STEP_EXEC = "步骤执行后卸载"
UNLOAD_OPTION_AFTER_SEQ_EXEC = "序列执行后卸载"
UNLOAD_OPTION_WHEN_CLOSED = "序列文件关闭时卸载"
UNLOAD_OPTION_NEVER = "从不卸载"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0001 = "你对这一步的加载选项所做的更改无效\n"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0002 = "因为序列文件加载选项覆盖了步进加载选项。\n"
LOAD_OPTION_FROM_SEQFILE_MESSAGE Line0003 = "使用序列文件属性对话框更改序列文件加载选项。"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0001 = "你对这一步的卸载选项所做的更改无效，因为\n"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0002 = "序列文件卸载选项覆盖此步骤的卸载选项。使用\n"
UNLOAD_OPTION_FROM_SEQFILE_MESSAGE Line0003 = "序列文件属性对话框更改序列文件卸载选项。"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0001 = "您对此序列调用步骤的加载选项所做的更改无效\n"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0002 = "因为仅在运行时计算的表达式指定了模块。\n"
LOAD_OPTION_FROM_SEQCALL_MESSAGE Line0003 = "使用指定模块对话框更改此步骤的模块规格。"
CHANGE_BUTTON_LABEL = "更改"
RUN_MODE_NORMAL = "正常"
RUN_MODE_SKIP = "跳过"
RUN_MODE_FORCE_PASS = "强制通过"
RUN_MODE_FORCE_FAIL = "强制失败"
TRACE_LEAVE_ASIS = "使用当前轨迹设置"
TRACE_TURN_ON = "按顺序启用跟踪"
TRACE_TURN_OFF = "按顺序禁用跟踪"
TRACE_USE_EXE_DEFAULT = "使用初始执行设置"
WINDOW_ACTIVATION_LABEL = "测试台&窗口激活："
WIN_ACT_NONE = "不激活"
WIN_ACT_ACTIVATE_WHEN_STEP_COMPLETES = "步骤完成时激活"
WIN_ACT_IF_INITIALLY_ACTIVE_REACTIVATE = "如果最初激活，则在步骤完成时重新激活"
EVAL_PRECOND_FOR_INT_EXE_LABEL = "交互模式下的先决条件评估："
EVAL_PRECOND_USE_STATION_OPTION = "使用站选项"
EVAL_PRECOND_DO_EVAL = "评估先决条件"
EVAL_PRECOND_DONT_EVAL = "不评估前提条件"
SEQCALL_TRACE_LABEL = "序列调用跟踪设置(&A):"
LOOP_PAGE_TITLE = "默认循环选项"
LOOP_TYPE_LABEL = "循环&类型："
RECORD_ITER_RESULT_LABEL = "记录每次迭代的结果"
PASS_FAIL_TEXT1 = "Sto&p after"
PASS_FAIL_TEXT2 = "迭代"
PASS_FAIL_TEXT3 = "或在一个 &maximum 之后"
PASS_FAIL_TEXT4 = "迭代。"
FIXED_LOOP_NUM_LABEL = "&循环次数："
FIXED_RESULT_TEXT1 = "如果循环结果为&Fail"
FIXED_RESULT_TEXT2 = "% 的迭代通过。"
LOOP_WHILE_LABEL = "循环&While 表达式："
LOOP_RESULT_LABEL = "循环&状态表达式："
LOOP_INCREMENT_LABEL = "循环递增表达式(&I):"
LOOP_INITIALIZE_LABEL = "循环初始化表达式："
LOOP_TYPE_NONE = "无"
LOOP_TYPE_FIXED_NUMBER = "固定循环次数"
LOOP_TYPE_PASS_FAIL_COUNT = "通过/失败计数"
LOOP_TYPE_CUSTOM = "自定义"
LOOP_RESULT_PASS = "通过"
LOOP_RESULT_FAIL = "失败"
PASS_FAIL_RESULT = "如果 %2 %3 在 %4 次迭代中，循环结果为 %1。"
DEFAULT_NAME_ERROR = "默认步骤名称表达式"
DESCRIPTION_FORMAT_ERROR = "步骤描述表达式"
ITEM_NAME_ERROR = "物品名称表达式"
SUBMENU_NAME_ERROR = "子菜单名称表达式"
SING_ITEM_NAME_ERROR = "单个物品名称表达式"
MENU_ITEM_NAME_ERROR = "菜单项名称表达式"
EMPTY_EXPR_ERROR = "%1 不能为空。"
LOOP_WHILE_ERROR = "循环 while 表达式"
LOOP_RESULT_ERROR = "循环状态表达式"
POST_CUSTOM_ERROR = "自定义条件表达式"
GOTO_DESTINATION_ERROR = "目标表达式"
CALLBACK_ERROR = "序列表达式"

ADVANCED_PAGE_TITLE = "默认表达式"
PRE_EXPR_LABEL = "&Pre-Expression:"
POST_EXPR_LABEL = "Pos&t-表达式："
STATUS_EXPR_LABEL = "&状态表达式："
PRE_EXPR_ERROR = "前表达式"
POST_EXPR_ERROR = "后表达式"
STATUS_EXPR_ERROR = "状态表达式"
MENU_PAGE_TITLE = "菜单"
ITEM_NAME_LABEL = "物品 &名称表达："
GROUP_LABEL = "组&p:"
EDIT_STEP_TYPE_MENU = "&编辑步骤类型菜单..."
SUBSTEPS_PAGE_TITLE = "子步骤"
SUBSTEP_ADAPTER_COMBO_LABEL = "适配器&pter："
SUBSTEP_NAME_LABEL = "姓名"
SUBSTEP_TYPE_LABEL = "类型"
SUBSTEP_DETAILS_LABEL = "详细信息"
SUBSTEP_ADD_BUTTON_LABEL = "&添加..."
SUBSTEP_DELETE_BUTTON_LABEL = "&删除"
SUBSTEP_SPECIFY_MODULE_BUTTON_LABEL = "&指定模块..."
SUBSTEP_RENAME_BUTTON_LABEL = "&重命名"
SUBSTEP_MOVE_UP_BUTTON_LABEL = "向上移动(&U)"
SUBSTEP_MOVE_DOWN_BUTTON_LABEL = "移动&wn"
SUBSTEP_TYPE_INFO_LABEL = "子步骤信息"
EDIT_SUBSTEP_MENU_ITEM_NAME_LABEL = "菜单项&名称表达："
EDIT_SUBSTEP_SUPPORTS_READONLY_LABEL = "支持只读编辑&&"
DISABLE_PROPS_PAGE_TITLE = "禁用属性"
DISABLE_PROPS_LABEL = "&Select Properties to Disable from the Following List:\n"
DISABLE_NOTE_PROPS_LABEL Line0001 = "注意：当您更改这些步骤类型属性的值时，"
DISABLE_NOTE_PROPS_LABEL Line0002 = "这些值不会自动传播到这一步"
DISABLE_NOTE_PROPS_LABEL Line0003 = "类型。有关详细信息，请参阅 NI TestStand 帮助。"
APPLY_TO_INSTANCES_LABEL = "将此对话框中的更改应用于此类型的所有加载步骤(&Y)。"
CODE_TMPLTS_PROPS_PAGE_TITLE = "代码模板"
CREATE_CODE_TMPLT_LABEL = "创建..."
ADD_CODE_TMPLT_LABEL = "&添加..."
REMOVE_CODE_TMPLT_LABEL = "&删除"
EDIT_CODE_TMPLT_LABEL = "编辑..."
TEMPLATE_NAME_COLUMN_LABEL = "名称"
TEMPLATE_TYPE_COLUMN_LABEL = "类型"
TEMPLATE_NOT_FOUND_TYPE = "<未找到>"
MOVE_UP_LABEL = "向上移动(&U)"
MOVE_DOWN_LABEL = "向下移动(&D)"
CODE_TMPLT_DESCRIPTION_LABEL = "描述&ption:"
ADD_CODE_TMPLT_SELECTION_REQD_MSG = "你必须选择一个现有的代码模板。\n使用创建按钮创建一个新模板。"
NO_CODE_TMPLTS_TO_ADD_MSG Line0001 = "找不到任何尚未与此步骤类型关联的代码模板。\n"
NO_CODE_TMPLTS_TO_ADD_MSG Line0002 = "使用创建按钮从现有代码模板创建新代码模板。"
NO_CODE_TMPLTS_TO_CREATE_FROM_MSG Line0001 = "无法在此计算机上找到代码模板。\n"
NO_CODE_TMPLTS_TO_CREATE_FROM_MSG Line0002 = "你必须使用现有模板来创建新模板。\n"
NO_CODE_TMPLTS_TO_CREATE_FROM_MSG Line0003 = "确认 NI TestStand 安装。\n"

ADD_CODE_TMPLTS_DLG_TITLE = "选择要添加到步骤类型的代码模板"
CREATE_CODE_TMPLTS_DLG_TITLE = "创建代码模板"
NEW_CODE_TMPLT_NAME_LABEL = "新代码模板 &名称："
NEW_CODE_TMPLT_DESC_LABEL = "新代码模板&描述："
BASE_CODE_TMPLT_LIST_LABEL = "&Base 新模板基于："
TEMPLATE_TYPE_COMBO_LABEL = "新代码模板&类型："
VALID_CODE_TMPLT_NAME_REQD_MSG Line0001 = "你必须输入一个有效的代码模板名称。\n"
VALID_CODE_TMPLT_NAME_REQD_MSG Line0002 = "有效的代码模板名称不能包含目录名称中无效的字符。"
BASE_CODE_TMPLT_REQD_MSG = "你必须选择一个现有的代码模板作为新代码模板的基础。"
CANNOT_CREATE_DUPLICATE_CODE_TMPLT_PROMPT = "新模板名称必须不同于基本模板名称。"
OVERWRITE_CODE_TMPLT_PROMPT = "代码模板 '%1' 已经存在。覆盖它？"
CREATE_DUPLICATE_CODE_TMPLT_PROMPT Line0001 = "代码模板'%1'已经存在于搜索路径中：\n'%2'\n"
CREATE_DUPLICATE_CODE_TMPLT_PROMPT Line0002 = "如果你继续，TestStand 会创建一个新的代码模板：\n'%3'\n"
CREATE_DUPLICATE_CODE_TMPLT_PROMPT Line0003 = "TestStand 使用的实例取决于搜索路径优先级。\n"
CREATE_DUPLICATE_CODE_TMPLT_PROMPT Line0004 = "你想继续吗？"

;;同步页面
SYNC_PAGE_TITLE = "默认同步"
MUTEX_CHECK_LABEL = "&Use Lock 一次只允许一个线程执行该步骤"
MUTEX_CHECK_COMMENT = "（锁在先决条件评估期间无效。）"
MUTEX_NAME_OR_REF_LBL = "&Lock Name or Reference Expression:\n（传递一个数组以在单个操作中锁定多个锁\n或者留空以使用该步骤独有的锁。）"
BATCH_SYNC_OPT_LBL = "&Batch Synchronization:\n（仅在使用批处理模型执行序列时使用此设置。）"
BATCH_SYNC_USE_SEQ_FILE = "使用序列文件设置"
BATCH_SYNC_USE_BATCH = "使用模型设置"
BATCH_SYNC_DONT_SYNC = "无同步"
BATCH_SYNC_SERIAL = "串行（一次一个线程）"
BATCH_SYNC_PAR = "并行（所有线程同时进入）"
BATCH_SYNC_ONE_THREAD_ONLY = "只有一个线程（第一个线程执行步骤，其余线程跳过）"
MUTEX_NAME_OR_REF_SYNTAX_ERROR = "锁定名称或引用表达式"

;;切换执行页面
SWITCHEXEC_PAGE_TITLE = "默认切换"
ENABLE_SWITCHING = "启用切换(&E)"
WAIT_FOR_DEBOUNCE = "&Wait for Debounce before Executing Step"
SE_VIRT_DEV = "切换执行\n&虚拟设备"
OPERATION = "操作"
ROUTE_GROUP_TO_CONNECT = "路由\n到&Connect"
ROUTE_GROUP_TO_DISCONNECT = "路由\n到断开连接"
OPERATON_ORDER = "操作订单&r"
MULTICONNECT_MODE = "&多连接模式"
CONNECTION_LIFE_TIME = "连接和生命周期"
OPERATION_CONNECT = "连接"
OPERATION_DISCONNECT = "断开连接"
OPERATION_DISCONNECT_ALL = "全部断开连接"
OPERATION_CONNECT_DISCONNECT = "连接/断开连接"
CONNLIFETIME_MANUAL = "手动"
CONNLIFETIME_EXECUTION = "执行"
CONNLIFETIME_THREAD = "线程"
CONNLIFETIME_SEQUENCE = "序列"
CONNLIFETIME_STEP = "步骤"
BREAK_BEFORE_MAKE = "连接前断开"
BREAK_AFTER_MAKE = "连接后断开"
NO_MULTICONNECT = "没有多重连接"
MULTICONNECT_ROUTES = "多连接路由"
DEFAULT_MULTICONNECT_MODE = "为路由使用默认设置"

;;查看更改按钮和消息对话框
VIEW_CHANGES_BTN_LABEL = "查看变化&ges..."
VIEW_CHANGES_TITLE = "对 %1 %2 属性的更改"
VIEW_CHANGES_MESSAGE = "以下属性已在此步骤类型中修改：\r\n\r\n%1"
VIEW_CHANGES_NO_CHANGES_MESSAGE = "没有对此步骤类型进行任何更改。"
VIEW_CHANGES_DISABLED_PROPERTY = "禁用 %1"
VIEW_CHANGES_ENABLED_PROPERTY = "启用 %1"
VIEW_CHANGES_STRUCT_PASSING_CHANGED = "结构传递"

;;无法应用更改警告消息
CANNOT_APPLY_ADAPTER_CHANGE_TITLE = "无法对步骤应用某些更改"
CANNOT_APPLY_ADAPTER_CHANGE_MESSAGE Line0001 = "当您禁用指定适配器设置时，您不能将更改应用于加载的步骤。您必须 "
CANNOT_APPLY_ADAPTER_CHANGE_MESSAGE Line0002 = "指定适配器或不将更改应用到所有加载的步骤。"

[STEP_TYPE_PROP_DLG Property Display Names]
TS.CanSpecifyModule = "指定模块"
TS.CanEditCode = "编辑代码"
TS.CanEditModulePrototype = "编辑模块原型"
TS.CanEditParameterAdditionalResults = "参数附加结果"
TS.SData = "模块"
Flags = "高级按钮\\编辑标志"
Comment = "描述"
TS.LoadOpt = "加载选项"
TS.UnloadOpt = "卸载选项"
TS.Mode = "运行模式"
TS.PrecondIntExe = "交互模式下的前提条件评估"
TS.WindowActivation = "TestStand 窗口激活"
TS.HasModule = "有模块"
TS.IgnoreRTE = "忽略运行时错误"
TS.StepFCSeqF = "步骤失败导致序列失败"
TS.ResultOption = "结果记录"
TS.UseMutex = "使用锁"
TS.MutexNameOrRef = "锁定名称或引用表达式"
TS.BatchSyncOpt = "批量同步"
TS.SwitchEnabled = "开关启用"
TS.VirtualDeviceName = "虚拟设备名称"
TS.SwitchOperation = "开关操作"
TS.RouteGroupConnect = "要连接的路线"
TS.RouteGroupDisconnect = "要断开的路由"
TS.MulticonnectMode = "多连接模式"
TS.OperationOrder = "操作指令"
TS.ConnectionLifetime = "连接/断开连接生命周期"
TS.WaitForDebounce = "等待去抖动"
TS.PassAct = "通过操作"
TS.FailAct = "失败操作"
TS.CustTrueAct = "自定义条件为真时的操作"
TS.CustFalseAct = "自定义条件为假时的操作"
TS.PassActTarget = "通过操作的目标"
TS.FailActTarget = "失败操作的目标"
TS.CustTrueActTarget = "自定义条件为真时的目标"
TS.CustFalseActTarget = "自定义条件为假时的目标"
TS.CustExpr = "自定义后操作条件"
TS.PreCond = "先决条件"
TS.Icon = "图标"
TS.StatusExpr = "状态表达式"
TS.PreExpr = "预表达"
TS.PostExpr = "表达式后"
TS.LoopType = "循环类型"
TS.LoopIncrement = "循环增量表达式"
TS.LoopInitialize = "循环初始化表达式"
TS.LoopWhile = "循环表达式"
TS.LoopStatus = "循环状态表达式"
TS.LoopOpt = "循环选项（记录每次迭代的结果）"
TS.CustomResults = "自定义附加结果"
DescriptionFormat = "步骤描述表达式"
DefaultNameFormat = "默认步骤名称表达式"
Substeps = "子步骤"
CodeTemplates = "代码模板"
Version = "版本"
AutoConvertVersions = "自动转换类型版本"
Menu.Adapter = "指定适配器名称"
Menu.CanBeSubstepType = "可以是子步骤"
Menu.CanOnlyBeSubstepType = "只能是子步骤"
Menu.Category = "类别"
Menu.ItemName = "菜单项名称表达式"
Menu.SingularItemName = "单数菜单项名称"
Menu.EditItemName = "编辑菜单项名称"
Menu.SeparatorBeforeCategory = "分类前的分隔符"
Menu.SeparatorBeforeItemName = "项目名称前的分隔符"
Menu.Group = "菜单组"

BlockStartTypes = "块启动步骤类型"
BlockEndTypes = "块结束步骤类型"
AppliesToBlockStructure = "步骤影响序列块结构"
CanEncapsulate = "可以围绕一系列步骤"

[SYNTAX_ERROR_DLG]
CAPTION = "警告："
GOTO_BTN = "&转到错误"
IGNORE_BTN = "&忽略错误"
IGNORE_ALL_BTN = "忽略所有错误(&A)"
IGNORE_THIS_BTN = "&忽略这个错误"

[TESTOBJECT_PROP_SHEET]
TITLE = "%1 属性"
OK_BTN_LABEL = "&OK"
HELP_BTN_LABEL = "&帮助"
CANCEL_BTN_LABEL = "CANCEL"
VIEW_CONTENTS_BTN_LABEL = "&查看内容"
VIEW_CONTENTS_MODIFIED_OBJECT_TITLE = "属性对象已修改"
VIEW_CONTENTS_MODIFIED_OBJECT_MESSAGE = "您已修改此属性对象的属性。\n您要应用更改吗？"

[TIME_OUT_DLG]
TITLE = "超过时间限制"
EXECUTING_TIME_OUT_MSG = "以下执行时间已过：\n\n%1"
TERMINATING_TIME_OUT_MSG Line0001 = "终止以下执行的时间已过：\n\n%1\n\n"
TERMINATING_TIME_OUT_MSG Line0002 = "当 TestStand 执行正在等待一个"
TERMINATING_TIME_OUT_MSG Line0003 = "代码模块完成执行。在这些情况下，使用终止监视器"
TERMINATING_TIME_OUT_MSG Line0004 = "在代码模块中检查 TestStand 执行的状态。参考 "
TERMINATING_TIME_OUT_MSG Line0005 = "\"检查代码模块中暂停或停止的执行\" topic "
TERMINATING_TIME_OUT_MSG Line0006 = "在 TestStand 帮助中获取有关此问题的更多信息。"
ABORTING_TIME_OUT_MSG Line0001 = "中止以下执行的时间已过：\n\n%1\n\n"
ABORTING_TIME_OUT_MSG Line0002 = "当 TestStand 执行正在等待一个"
ABORTING_TIME_OUT_MSG Line0003 = "代码模块完成执行。在这些情况下，使用终止监视器"
ABORTING_TIME_OUT_MSG Line0004 = "在代码模块中检查TestStand 执行的状态。参考 "
ABORTING_TIME_OUT_MSG Line0005 = "\"检查代码模块中暂停或停止的执行\" topic "
ABORTING_TIME_OUT_MSG Line0006 = "在 TestStand 帮助中获取有关此问题的更多信息。"
ACTION_DO_NOTHING = "&什么都不做。让执行正常结束。"
ACTION_WAIT = "&等待"
ACTION_WAIT_SECONDS_LABEL = "秒，然后再次提示。"
ACTION_TERMINATE = "&终止执行。"
ACTION_ABORT = "&中止执行。"
ACTION_KILL_THREADS = "&Kill 执行中的所有线程。"
KILL_THREADS_WARNING = "警告：终止线程可能导致 TestStand 变得不稳定。"
SUSPENDED_TITLE = "暂停执行"
SUSPENDED_TIME_OUT_MSG = "以下执行已暂停：\n\n%1"
SUSPENDED_ACTION_DO_NOTHING = "恢复执行并让它正常结束。"
SUSPENDED_ACTION_WAIT = "恢复执行并等待"
SUSPENDED_ACTION_WAIT_SECONDS_LABEL = "秒，然后再次提示。"

[WAIT_FOR_EXECUTIONS_TO_FINISH_DLG]
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_TITLE = "继续等待运行的执行？"
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_MESSAGE Line0001 = "至少有一个执行仍在运行。\n\n"
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_MESSAGE Line0002 = "在执行过程中无法更改引擎环境。"
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_MESSAGE Line0003 = "此对话框通常表示最近关闭的序列文件（可能是进程模型）的卸载回调仍在运行。\n\n"
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_MESSAGE Line0004 = "您可以继续等待执行完成。或者，您可以CANCEL此引擎重启操作。\n\n"
WAIT_FOR_EXECUTIONS_TO_FINISH_DLG_MESSAGE Line0005 = "再等 10 秒好吗？\n"

[TOOL_MENU_ITEM]
COMMAND_TYPE_DISPLAY_STRING = "命令"
SEQUENCE_TYPE_DISPLAY_STRING = "序列"
SUBMENU_TYPE_DISPLAY_STRING = "子菜单"
SEQFILE_TYPE_DISPLAY_STRING = "序列文件"

[TOOL_MENU_DLG]
DLG_TITLE = "自定义工具菜单"
ADD_ITEM_DLG_TITLE = "添加工具菜单项"
ITEM_LIST_LABEL = "&工具"
ITEM_LIST_MENU_SEPARATOR = "->"
ITEM_LIST_LABEL_END = "菜单："
ITEM_TEXT_LABEL = "&物品文本表达："
SEPARATOR_BEFORE_LABEL = "在项目前插入分隔符(&S)"
EDITS_SELECTED_FILE_LABEL = "编辑选定文件(&D)"
ENABLE_EXPR_LABEL = "&启用表达式："
HIDDEN_EXPR_LABEL = "&隐藏表达式："
COMMAND_LABEL = "&命令："
ARGUMENTS_LABEL = "参数&参数："
INIT_DIR_LABEL = "初始目录(&N):"
SEQUENCE_FILE_LABEL = "序列&文件："
SEQUENCE_LABEL = "&序列："
ADD_BUTTON_LABEL = "&添加..."
REMOVE_BUTTON_LABEL = "&删除"
MOVE_UP_BUTTON_LABEL = "向上移动(&U)"
MOVE_DOWN_BUTTON_LABEL = "向下移动(&D)"
EXPAND_BUTTON_LABEL = "展开&xpand"
COLLAPSE_BUTTON_LABEL = "&Collapse"
RESTORE_DEFAULT_BUTTON_LABEL = "恢复默认&ts"
EXPORT_BUTTON_LABEL = "导出项目到文件(&B)..."
BROWSE_COMMAND_DLG_TITLE = "选择命令"
BROWSE_SEQ_FILE_DLG_TITLE = "选择序列文件"
BROWSE_INIT_DIR_DLG_TITLE = "选择初始目录"
ITEM_TEXT_COLUMN_LABEL = "物品文本"
ITEM_TYPE_COLUMN_LABEL = "类型"
REMOVE_SUBMENU_WARNING_TEXT = "删除此项会删除整个子菜单。"
REMOVE_SUBMENU_WARNING_TITLE = "警告"
DEFAULT_SUBMENU_NAME = "子菜单"
ITEM_TYPE_LABEL = "物品类型："
SYNTAX_ERROR_TITLE = "工具菜单"
SYNTAX_ERROR_ITEM_TEXT_MESSAGE = "菜单项文本表达式"
SYNTAX_ERROR_ENABLE_MESSAGE = "菜单项启用表达式"
SYNTAX_ERROR_HIDDEN_MESSAGE = "菜单项隐藏表达式"
INVALID_INIT_DIR_MESSAGE = "无效目录：%1\n目录必须是绝对路径并使用盘符。"
INVALID_INIT_DIR_TITLE = "工具菜单"
ARGUMENT_IS_EXPRESSION = "使用参数表达式"

[TOOL_MENU_ENTRIES]
ENGINE_INSTALLATION_WIZARD = "引擎安装向导..."
LAUNCH_MAX = "测量和自动化资源管理器..."
LAUNCH_MAX_FAILED_CAPTION = "未找到 NI 测量和自动化资源管理器"
LAUNCH_MAX_FAILED_MESSAGE = "无法启动 NI Measurement and Automation Explorer (MAX) 应用程序。请确认 MAX 已安装。您可以从 TestStand 附带的 NI 设备驱动程序 CD 安装 MAX。"
XMLPACK = "为分发打包 XML/HTML 文件..."

[TYPE_PROP_PAGE]
TYPE_PROP_PAGE_TITLE = "版本"
VERSION = "&版本"
VERSION_WARNING Line0001 = "警告：更改类型的版本时要小心。除非启用'始终提示'选项，"
VERSION_WARNING Line0002 = "当TestStand遇到同名类型时，自动替换"
VERSION_WARNING Line0003 = "旧版本类型与新版本类型。"
CONFLICT_ACTION = "当 TestStand 加载一个文件，该文件包含与内存中已有定义不同的此类型的定义："
PROMPT_ON_CONFLICT = "总是提示用户解决冲突(&A)。"
AUTO_RESOLVE_CONFLICT Line0001 = "&使用版本号最高的定义。如果版本号相同"
AUTO_RESOLVE_CONFLICT Line0002 = "或者如果其中一种类型启用了'修改'复选框，提示用户解决冲突。"
TYPE_MODIFIED Line0001 = "&Modified。启用此选项表示自上次设置版本号以来您已经修改了类型。"
" TYPE_MODIFIED Line0002 = " TestStand 在修改类型时自动启用此选项，在更改版本号时禁用此选项。
TYPE_MODIFIED Line0003 = "禁用删除'修改'标记的选项。"
TYPE_LAST_MODIFIED = "上次修改此类型的 TestStand 版本："
TYPE_LAST_MODIFIED_PRE_TS3_VAL = "早于 3.0"
CHECK_TYPE_LAST_MODIFIED = "&设置可以使用此类型的最早 TestStand 版本："
NO_TEXT = ""
INVALID_VERSION_TITLE = "无效值"
INVALID_VERSION_MSG = "%1 不是有效的类型版本。\n使用格式 \"#.#.#.#\"。\n\n你想修复版本吗？\n（选择 \"No\" 恢复以前的价值。）"
INVALID_MINIMUM_PRODUCT_VERSION_TITLE = "无效值"
INVALID_MINIMUM_PRODUCT_VERSION_MSG = "'%1' 不是设置可以使用此类型的最早 TestStand 版本的有效条目。\n请使用格式 \"#.#.#.#\"。\n\n是否要修复版本？ \n（选择"否"恢复以前的值。）"
HIGH_MINIMUM_PRODUCT_VERSION_TITLE = "版本高于当前 TestStand 版本"
HIGH_MINIMUM_PRODUCT_VERSION_MSG = "您为设置可以使用此类型的最早 TestStand 版本输入的版本 (%1) 高于当前 TestStand 版本 (%2)。\n\n您要修复版本吗？"
LOW_MINIMUM_PRODUCT_VERSION_TITLE = "版本低于当前 TestStand 版本"
LOW_MINIMUM_PRODUCT_VERSION_MSG = "这种类型的最低 TestStand 版本是 %1；它应该是 %2。你想修复它吗？"
OLDER_VERSION_TITLE = "版本较旧"
OLDER_VERSION_MSG Line0001 = "您输入的版本 (%1) 比当前版本 (%2) 旧。\n\n"
OLDER_VERSION_MSG Line0002 = "你想更改类型以使用旧版本号吗？"
SAME_VERSION_TITLE = "版本相同"
SAME_VERSION_MSG Line0001 = "您输入的版本 (%1) 等同于当前版本 (%2)。\n\n"
SAME_VERSION_MSG Line0002 = "确认您输入了正确的版本。"
CONFIRM_VERSION_TITLE = "确认新版本"
CONFIRM_VERSION_MSG = "TestStand 会将此类型的版本从 '%1' 更新为 '%2'。这是否正确？"

[USER_PROP_SHEET]
USER_PROP_SHEET_TITLE = "属性"
LOGIN_NAME_LABEL = "用户名："
GROUP_NAME_LABEL = "群组名称："
FULL_NAME_LABEL = "全名："
COMMENT_LABEL = "评论："
&ADVANCED = "高级"
PASSWORD_LABEL = "密码："
CONFIRM_PASSWORD_LABEL = "确认密码："
USER_TEMPLATE_LABEL = "用户群组(&R)："
MEMBERS_LABEL = "组成员："
PRIVILEGES_LABEL = "组权限："
PASSWORD_NOT_CONFIRMED_MESSAGE = "密码未正确确认。请重新输入密码。"

[VARIABLE_BROWSER_DLG]
TITLE = "在序列上下文中浏览变量和属性"
VARIABLE_LABEL = "变量"
COPY_VAR_NAME_BTN_LABEL = "复制属性路径(&P)"
GO_TO_BTN_LABEL = "转到变量"
ADD_WATCH_BTN_LABEL = "添加手表(&W)"
FILE_LABEL = "文件："
SEQUENCE_LABEL = "序列："
STEP_GROUP_LABEL = "步骤组："
STEP_LABEL = "步骤："

[VARIABLE/OPERATOR_BROWSER]
SHEET_TITLE = "表达式浏览器"
EXPR_LABEL = "表达式&xpression:"
VARIABLE_PAGE_TITLE = "变量/属性"
OPERATOR_PAGE_TITLE = "运算符/函数"
SYMBOL_COLUMN_HEADER = "交易品种"
OPERATOR_COLUMN_HEADER = "操作"
VARIABLE_LABEL = "&变量:"
DESCRIPTION_LABEL = "&描述："
INSERT_EXPR_BTN_LABEL = "&插入"
REPLACE_EXPR_BTN_LABEL = "&替换"
CHANGE_PROPERTIES_OF_X = "更改 %1 的属性"
UNDO_DESCRIPTION = "表达式浏览器对话框更改"

;;默认名称必须是有效的属性名称
TESTSTAND_GLOBAL_DEFAULT_NAME = "全局"
SEQFILE_VARIABLE_DEFAULT_NAME = "变量"
SEQ_PARAMETER_DEFAULT_NAME = "参数"
SEQ_LOCAL_DEFAULT_NAME = "本地"

[TSAPI_BROWSER]
TESTSTAND_API = "测试平台 API"
&SHOW_OBJECTS_WITH_INTERFACE: = "&Show Objects with Interface:"
ANY_INTERFACE = "任何接口"
SHOW_&MEMBERS_OF_INTERFACE: = "显示接口成员(&M):"
&REPLACE = "替换"
&INSERT = "插入"
TESTSTAND_API_&HELP = "TestStand API 及帮助"
？ ="？"

[WATCHEXPRESSION_SETTING_DLG]
EXPRESSION_LABEL = "&表达式:"
EXPRESSION_DESCRIPTION = "手表表达式"
BREAKTYPE_GROUP_LABEL = "断点类型"
BREAKTYPE_NONE_BTN_LABEL = "&无"
BREAKTYPE_VALUE_BTN_LABEL = "关于价值&改变"
BREAKTYPE_CONDITION_BTN_LABEL = "表达式为真"
SCOPE_BTN_LABEL = "仅在指定范围内存在(&X)"
LOCALTOEXECUTION_BTN_LABEL = "仅存在于当前执行中(&U)"
SEQUENCEFILE_LABEL = "序列&文件："
SEQUENCE_LABEL = "&序列："
DLG_TITLE = "观看表达式设置"
CLIENTFILE_LABEL = "&客户端序列文件："
DEPTH_BTN_LABEL = "&Attach to Sequence Context from Specified Scope"
INVALID_CONTEXT Line0001 = "监视表达式需要一个有效的上下文才能附加。"
INVALID_CONTEXT Line0002 = "要确定有效上下文，您必须指定序列文件。"

[WORKSPACE_BROWSER_DLG]
DLG_TITLE = "工作区浏览器"
CREATE_WORKSPACE_DLG_TITLE = "新工作区文件"
OPEN_WORKSPACE_DLG_TITLE = "打开工作区"
WORKSPACE_FILEPATH_LABEL = "工作区路径名："
WORKSPACE_SCC_MESSAGE_LABEL = "源代码控制消息："
PROVIDER_OPTIONS_BUTTON = "提供商&选项..."
RUN_PROVIDER_BUTTON = "&Run Provider..."
DONE_BUTTON = "完成(&N)"
HELP_BUTTON = "&帮助"
WORKSPACE_FILTER_NAME = "工作区文件 (*.tsw)"

INSERT_FOLDER_DLG_TITLE = "插入文件夹"
INSERT_FILES_DLG_TITLE = "添加文件"
SCC_MESSAGES_DLG_TITLE = "源代码控制消息"
MESSAGES_DLG_HEADER_LABEL = "消息："
MESSAGES_DLG_CLEAR_MESSAGES = "清除消息(&M)"
CREATE_PROJECT_DLG_TITLE = "创建项目"
OPEN_PROJECT_DLG_TITLE = "打开项目"
PROJECT_FILTER_NAME = "项目"
INITIAL_FOLDER_NAME = "新文件夹"
FAILED_TO_INSERT_TITLE = "警告"
FAILED_TO_INSERT_DUPLICATE = "以下文件未添加，因为它们已存在于工作区中：\n\n"

;;提示
GENERIC_PROMPT_TITLE = "工作区浏览器"
PROMPT_TO_SAVE_TITLE = "警告"
PROMPT_TO_SAVE = "对工作区/项目文件有一个或多个未保存的更改。\n你想保存更改吗？"
PROMPT_TO_CHECKOUT = "文件已签入源代码控制。\n文件签入时无法完成操作。\n\n是否要签出文件？"
PROMPT_FILE_NOT_CHECKED_OUT = "文件未签出。无法继续操作。"
PROMPT_FILE_RELOADED_OPERATION_CANNOT_CONTINUE = "文件已重新加载。无法继续操作。\n重复操作。"

PROMPT_CHECK_OUT_OVERWRITE_TITLE = "警告"
PROMPT_CHECK_OUT_OVERWRITE = "以下文件已被修改，尚未保存到磁盘。\n执行源代码控制操作将覆盖磁盘上的文件。\n你想继续吗？\n\n"
FAILED_TO_SAVE_TITLE = "警告"
PROMPT_TO_RELOAD_WORKSPACE_TITLE = "警告"
PROMPT_TO_RELOAD_WORKSPACE = "工作区/项目文件已被外部修改。\n你想重新加载文件并丢失对工作区/项目文件所做的任何更改吗？"

;;上下文菜单
WORKSPACE_NEW_WORKSPACE = "&新工作区文件...\tCtrl+N"
WORKSPACE_LOAD_WORKSPACE = "&打开工作区文件...\tCtrl+O"
WORKSPACE_UNLOAD_WORKSPACE = "&关闭工作区文件\tCtrl+W"
WORKSPACE_SAVE = "&保存工作区文件\tCtrl+S"
WORKSPACE_NEW = "新建文件夹(&E)"
WORKSPACE_INSERT_NEW_PROJECT = "插入新项目(&E)..."
WORKSPACE_ADD_PROJECT = "从磁盘添加项目..."
WORKSPACE_INSERT_FOLDER_FROM_DISK = "从磁盘插入文件夹(&F)..."
WORKSPACE_INSERT_FILES_FROM_DISK = "从磁盘添加文件..."
WORKSPACE_OPEN = "打开&笔"
WORKSPACE_INSERT_CODEMODULES = "插入代码和模块"
SCC_ADD = "&Add to Source Code Control..."
SCC_REMOVE = "从源代码控制中删除&ve..."
SCC_GET_LATEST = "&获取最新版本..."
SCC_CHECK_OUT = "签出&k..."
SCC_CHECK_IN = "签入&In..."
SCC_UNDO_CHECK_OUT = "撤消检出..."
SCC_SHOW_HISTORY = "显示历史(&H)..."
SCC_SHOW_DIFFERENCES = "显示差异&w..."
SCC_REFRESH_ALL = "&刷新所有 SCC 状态"
EDIT_CUT = "剪切\tCtrl+X"
EDIT_COPY = "复制\tCtrl+C"
EDIT_PASTE = "粘贴\tCtrl+V"
EDIT_DELETE = "删除\tDel"
EDIT_RENAME = "重命名\tF2"
SCC_CLEAR_MESSAGES = "清除&清除 SCC 消息"
SCC_PROVIDER_OPTIONS = "SCC 提供商选项(&T)..."
PROPERTIES = "属性...\tAlt+Enter"

[WORKSPACE_PROP_DLG]
DLG_TITLE = "%1 属性"
GENERAL_PAGE_TITLE = "一般"
SCC_PAGE_TITLE = "源代码控制"
SELECT_PROJECT_FILE_DLG_TITLE = "选择项目文件"
SELECT_GENERAL_WORKSPACE_FILE_DLG_TITLE = "选择文件"
DIFFERENT_LOCATION_TITLE = "不同的名称/位置"
FILE_NOT_FOUND_TITLE = "找不到文件"
PROJECT_NAME_EMPTY_TITLE = "空项目名称"

PATH_NAME_LABEL = "路径名称："
LAST_MODIFIED_LABEL = "上次修改："
PROJECT_NAME_LABEl = "项目："
SCC_STATUS_LABEL = "状态："
SEQUENCE_FILE_LABEL = "序列文件："
SOURCE_CONTROL_PROPERTIES = "源代码控制属性..."
DIFFERENT_FULL_PATH_ERROR Line0001 = "不允许更改文件 '%1' 的名称或位置。\n您可以更改路径是否为 "
DIFFERENT_FULL_PATH_ERROR Line0002 = "文件是相对路径或\n绝对路径，但路径必须指向同一个文件。\n\n原始：%2\n新：%3"
FILE_NOT_FOUND_ERROR = "文件 '%1' 不在任何搜索目录中。\n请输入一个不同的名称。"

PROVIDER_NAME_LABEL = "供应商名称："
SCC_PROJECT_LABEL = "源代码控制&项目："
USER_NAME_LABEL = "源代码控制&用户名："
CONNECT_TO_PROVIDER_BUTTON = "&连接"
CHANGE_SCC_PROJECT_BUTTON = "更改项目(&H)..."
ADVANCED_BUTTON = "高级..."
RUN_SCC_PROVIDER_BUTTON = "&运行 %1..."
CHANGE_PROVIDER_WARNING_TITLE = "更改提供商警告"
CHANGE_PROVIDER_WARNING = "提供商名称已更改。\n\n更改为不同的提供商可能会导致意外行为。\n是否继续？"
DISCONNECT_FROM_PROVIDER_WARNING = "您已选择不使用任何 SCC 供应商。\n\nTestStand 将断开与当前供应商的连接。\n继续吗？"
DISCONNECT_FROM_PROVIDER_WARNING_TITLE = "正在断开当前供应商警告"
CONNECTING_TO_DEFAULT_PROVIDER_WARNING = "您已选择连接到默认提供程序。\n\n更改为不同的提供程序可能会导致意外行为。\n是否继续？"
CONNECTING_TO_DEFAULT_PROVIDER_WARNING_TITLE = "连接到默认提供商警告"
USER_NAME_INFO = "（更改在\n 重新打开工作区\n 或更改提供商后生效。）"
PROJECT_NAME_EMPTY_ERROR = "源代码控制项目必须有一个值。\n请输入项目名称以继续。"
NO_PROVIDER = "<无>"
DEFAULT_PROVIDER = "<默认>"

FOLDER_NAME_LABEL = "文件夹名称："



;;序列编辑器对话框

[ALL_TYPES_DLG]
DLG_TITLE = "查找类型"
TYPE_CATEGORY_HEADER = "类别"
STEP_TYPE = "步骤类型"
CUSTOM_TYPE = "自定义数据类型"
STD_TYPE = "标准数据类型"
TYPE_NAME_HEADER = "名称"
TYPE_USAGES_HEADER = "用法"
GOTO_BTN_LABEL = "&转到8888"

CANT_GOTO_STEPTYPE_IN_GLOBALS_MSG = "无法转到站点全局类型视图中的步骤类型 '%1'。"
CANT_GOTO_STEPTYPE_IN_USER_MSG = "无法转到用户管理器类型视图中的步骤类型 '%1'。"
CANT_GOTO_GLOBALS_WHILE_RUNNING_MSG = "运行时无法在 Station Globals 类型视图中输入 '%1'。"

[LV_CLOSE_EXE_OPTION_DLG]
DLG_TITLE = "关闭执行窗口"
TERMINATE_RADIO_LABEL = "终止执行"
ABORT_RADIO_LABEL = "中止执行（不清理）"
CLOSE_WINDOW_LABEL = "关闭窗口（继续执行）"
EXECUTION_CURRENTLY_RUNNING_MSG Line0001= "该执行当前正在运行。"
EXECUTION_CURRENTLY_RUNNING_MSG Line0002= "你想做什么？"
OK="确定"
CANCEL="取消"

[CLOSE_EXE_OPTION_DLG]
DLG_TITLE = "关闭 %1"
TERMINATE_RADIO_LABEL = "&终止执行"
ABORT_RADIO_LABEL = "&中止执行（不清理）"
CLOSE_WINDOW_LABEL = "&Close Window (leave execution running)"

[CONFIGURE_TYPE_PALETTES_DLG]
CONFIGURE_TYPE_PALETTES_DLG_TITLE = "配置类型面板"
CREATE_FILE_DLG_TITLE = "创建类型面板"
CREATE_FILE_DLG_OK_BUTTON = "创建"
ADD_FILE_DLG_TITLE = "添加类型选项板"
ADD_FILE_DLG_OK_BUTTON = "添加文件"
CREATE = "创建..."
ADD = "添加..."
REMOVE = "移除"
MOVE_UP = "上移"
MOVE_DOWN = "下移"
TYPE_PALETTES_FILTER_DESC = "配置文件"
ALL_FILES_FILTER_DESC = "所有文件"
CANT_REMOVE_LAST_PALETTE = "你必须至少加载一种类型的调色板。"
CANT_ADD_INSTALL_PALETTE Line0001 = "您不能添加您选择的类型调色板，因为它是已安装的"
CANT_ADD_INSTALL_PALETTE Line0002 = "类型调色板的版本。要加载此文件，请将其复制到 "
CANT_ADD_INSTALL_PALETTE Line0003 = "<TestStand Public>\\Components\\TypePalettes 目录并重新启动序列编辑器。"
OK = "确定"
CANCEL = "取消"
HELP = "帮助"
PROMPT_TO_SAVE_BEFORE_REMOVE = "类型调色板 '%1' 已修改。你想在从列表中删除之前保存类型调色板吗？（选择否放弃更改。）"

[COPY_PASTE_WARNING_DLG]
CAPTION = "粘贴类型"
LBL_TEXT Line0001 = "此文件之前没有引用您添加的一种或多种类型，因此 TestStand 将这些类型附加到文件中。\n\n"
LBL_TEXT Line0002 = "如果您想基于现有类型创建新类型，请将类型复制并粘贴到已引用该类型的文件中，以便 TestStand 粘贴该类型的唯一命名副本。"
CHK_SHOW_NEXT_TIME = "&下次显示这条消息"
BTN_OK = "确定"
BTN_HELP = "&帮助"

[DEFAULT_ADAPTER_CONFIG_DLG]
DLG_TITLE = "选择适配器"

[DIFFERENCE_DESCRIPTION_DLG]
DIALOG_TITLE = "差异描述"
TYPE_OF_DIFFERENCE_LABEL = "差异类型："
DESCRIPTION_LABEL = "详细说明："
CLOSE = "关闭"

[FIND_DIALOG]
ROOT_OBJECT_LOCATION_DISPLAY_STRING = "<搜索的根对象>"
WAITING_FOR_EXECUTION_FOR_REPLACE_CAPTION = "等待执行或回调完成"
WAITING_FOR_EXECUTION_FOR_REPLACE_TEXT = "文件 '{0}' 正在被执行或回调使用，例如 SequenceFileLoad 或 SequenceFileUnload 回调。执行完成后替换操作继续。"
TYPE_NAMES_LABEL = "&类型名称"
EDIT_SEL_ITEMS_LBL = "编辑所选物品"
INVALID_MATCH_SELECTED_TEXT = "<由于'替换值'操作，所选项目不再有效。>"
NO_MATCHES_SELECTED_TEXT = "<未选择项目。>"
MULTIPLE_MATCHES_SELECTED_TEXT = "<选择了多项。仅选择一项以查看字符串中的位置。>"
ADD_FILES_DLG_TITLE = "添加文件"
SPECIFIC_FILES_ON_DISK_LABEL = "特定序列文件："
ADD_FILES_BTN_LBL = "&添加文件..."
REMOVE_FILES_BTN_LBL = "&删除"
REMOVE_ALL_FILES_BTN_LBL = "全部删除&移动"
FIND_IN_SPECIFIC_VIEW_ONLY = "&限制搜索范围："
USE_RESULT_PANE_2 = "在查找结果 2 中显示"
TYPES_LBL = "类型"
FIND_TITLE = "在以下位置查找/替换："
FIND_IN_FILES_TITLE = "在文件中查找/替换"
SEARCH_FOR_TAB = "搜索"
FIND_LABEL = "&查找:"
MATCH_CASE_LABEL = "&匹配大小写"
REGEXPR_LABEL = "正则表达式&xpression"
WHOLE_WORD_LABEL = "只匹配整个单词(&M)"
FILES_GROUP_LABEL = "搜索范围"
SELECTED_FILE_LABEL = "打开的文件："
FILES_UNDER_DIRECTORY_LABEL = "目录下的所有序列文件："
BROWSE_BTN_LABEL = "&浏览..."
ALL_OPEN_FILES_LABEL = "所有打开的序列文件"
ALL_FILES_IN_WORKSPACE_LABEL = "当前工作区中的所有序列文件"
INC_SUBSEQS_LABEL = "递归地搜索序列文件称为子序列"
USERS_LABEL = "<用户>"
STATION_GLOBALS_LABEL = "<站点全局>"
TYPE_PALETTES_LABEL = "<文字调色板>"
FILTER_TAB = "过滤器"
ELEM_TO_SEARCH_LABEL = "要搜索的元素"
VALUES_LABEL = "值&ues"
STRING_LABEL = "&字符串"
NUMBER_LABEL = "数字&mber"
BOOLEAN_LABEL = "&布尔值"
NAMES_LABEL = "&名字"
COMMENTS_LABEL = "&评论"
ATTRIBUTES_LABEL = "&属性"
OBJS_TO_SEARCH_LABEL = "要搜索的对象"
VARIABLES_LABEL = "&变量"
LOCALS_LABEL = "&Locals"
PARAMS_LABEL = "序列参数"
SFGLOBALS_LABEL = "文件和全局变量"
STEPS_AND_STEP_PROPS_LABEL = "步骤&步骤"
CUSTOM_PROPS_LABEL = "自定义属性"
BUILTIN_PROPS_LABEL = "其他内置属性"
MODULE_PROPS_LABEL = "模块属性"
ADAPTER_LABEL = "&适配器"
BUILTIN_SEQ_SEQFILE_PROPS_LBL = "内置序列和序列文件&属性"
TYPE_DEFS_LABEL = "类型定义"
STEP_TYPES_LABEL = "步骤类型"
CUSTOM_DATA_TYPES_LABEL = "自定义数据类型"
STD_DATA_TYPES_LABEL = "标准数据类型"
LIMIT_SEARCH_TO_VARS_CHECKBOX_LABEL = "仅在具有以下名称的对象中搜索"
LIMIT_SEARCH_TO_TYPES_CHECKBOX_LABEL = "仅在属于以下类型的实例的对象中搜索"
LIMIT_SEARCH_TO_TYPES_SELECT_BTN = "选择..."
RESULTS_DLG_CAPTION = "搜索结果"
FOUND_ITEMS_LBL = "找到的物品："
SELECT_ALL_BTN = "全选"
GOTO_SELECTED_ITEM_BTN = "转到所选项目"
CANCEL_SEARCH_BTN = "停止"
SEARCH_AGAIN_BTN = "新搜索..."
SEARCH_COMPLETE_LBL = "搜索完成"
SEARCH_CANCELLED_LBL = "搜索停止"
REPLACE_WITH_LBL = "替换为："
REPLACE_SELECTED_ITEMS_BTN = "替换找到的文本"
SKIP_TO_NEXT_BTN = "跳到下一个"
REPLACE_VALUES_BTN = "替换值"
APPLY_REPLACE_IN_TYPE_TO_INSTANCES_LBL = "将类型替换应用于类型实例"
FILE_HDR = "文件"
OBJECT_HDR = "位置"
ELEMENT_HDR = "发现于"
ELEMENT_NAME = "名称"
ELEMENT_TYPE_NAME = "类型名称"
ELEMENT_VALUE = "值"
ELEMENT_COMMENT = "评论"
ELEMENT_ENUMERATORS = "枚举器"
VALUE_HDR = "值"
NUM_MATCHES_PANE_TEXT = "匹配数：%1"
REPLACE_FAILED_WARN = "将对象 %2 的 %1 中的匹配文本替换为 \"%3\" 失败。\n\n%4"
REPLACE_FAILED_WARN_WITH_SUPPRESS = "将对象 %2 的 %1 中的匹配文本替换为 \"%3\" 失败。\n\n%4\n\n不显示额外的警告吗？"
REPLACE_VALUE_FAILED_WARN = "用 \"%3\" 替换对象 %2 的值失败。\n\n%4"
REPLACE_VALUE_FAILED_WARN_WITH_SUPPRESS = "用 \"%3\" 替换对象 %2 的值失败。\n\n%4\n\n不显示额外的警告吗？"
FIND_BTN = "查找/替换"
CANNOT_FIND = "找不到 '%1'。"
WRAPPED_STATUS_MSG = "搜索已结束"
HELP_BTN = "帮助"
FIND_IN_VIEW_LBL = "在以下位置找到'%1'："
FIND_IN_FILES_LBL = "在文件中查找'%1'："
FIND_LBL = "查找："
LOCATION_LBL = "位置："
INDICES_OF_SELECTED_MATCHES_PANE_TEXT = "已选择 %1 个匹配项 [%2]"
INDEX_OF_SELECTED_MATCH_PANE_TEXT = "1 个匹配选择 [%1]"
NO_SELECTED_MATCHES_PANE_TEXT = "没有选择匹配项"
LOC_DOES_NOT_EXIST = "指定的位置不再存在。"
BROWSE_DIRECTORY_TITLE = "选择要搜索的目录"
WARNING_LBL = "警告："
ALL_ADAPTERS_LBL = "<所有适配器>"
ERR_VIEW_NOLONGER_EXISTS = "无法在视图中再次搜索。视图不再存在。"
RESET_TO_DEFAULTS = "重置为默认值"
GOTO_LOCATION_FAILED = "无法前往位置。\n\n%1"
UNSAVED_FILE_NOLONGER_EXISTS = "未保存的文件 '%1' 不再存在。"
NO_SORTING_WHILE_RUNNING_MSG = "搜索仍在进行时不允许排序。等待搜索完成或单击停止按钮中止搜索。"
SORT_TAKING_TOO_LONG_MSG = "对大量项目进行排序会花费大量时间。\n\n你想继续吗？\n\n（你将有机会在 %1 秒后再次CANCEL。）"
UNDO_REPLACE_TEXT = "用 '%1' 替换匹配的文本"
UNDO_REPLACE_VALUE = "用 '%1' 替换值"

[INSTALL_NEW_TYPE_PALETTE_DLG]
DLG_TITLE = "安装了新类型调色板"
DLG_MESSAGE Line0001 = "TestStand 检测到此计算机上安装了一个新的类型调色板。"
DLG_MESSAGE Line0002 = "因为这台计算机上已经存在一个类型调色板，你必须选择以下选项之一。\n"
DLG_MESSAGE Line0003 = "\n"
DLG_MESSAGE Line0004 = "注意：如果将新类型调色板与现有类型调色板组合，TestStand "
DLG_MESSAGE Line0005 = "提示您解决发生的任何类型冲突。"
OPTIONS_STATIC = "选项："
COMBINE_TYPE_PALETTES_LABEL = "组合类型调色板"
REPLACE_OLD_TYPE_PALETTE_LABEL = "用新安装的类型替换现有的类型调色板(&R) "
DISCARD_NEW_TYPE_PALETTE_LABEL = "不要安装新类型调色板"

[MORE_WINDOWS_DLG]
DLG_TITLE = "选择窗口"
ACTIVATE_BTN_LABEL = "激活"

[REGISTER_USER_DLG]
REGISTER_USER_TITLE = "TestStand注册"
REGISTER_USER_MSG Line0001 = "此 TestStand 副本当前未注册。请填写所需的注册信息。"
REGISTER_USER_MSG Line0002 = "此对话框将在 TestStand 启动时继续启动，直到您注册此副本。"
USER_NAME_LABEL = "用户名："
COMPANY_NAME_LABEL = "公司名称："
SERIAL_NUMBER_LABEL = "序列号："
INVALID_SERIAL_NUMBER_MSG Line0001 = "未输入 TestStand 序列号或无效。\n\n产品注册对话框将继续 "
INVALID_SERIAL_NUMBER_MSG Line0002 = "在 TestStand 启动时启动，直到您正确注册此副本。"
OK_BTN = "确定"
CANCEL_BTN = "取消"
HELP_BTN = "帮助"

[LOCKUNLOCK_DLG]
锁定 = "锁定"
解锁 = "解锁"
文件 = "文件"
TYPE_DEFS = "类型定义"
ON_TYPE_DEFS = "类型定义。"
ON_SPECIFIC_TYPE_DEF = "类型定义：\n%1。"
TYPE_DEFS_UNLOCK_FAILED_TITLE = "解锁失败"
TYPE_DEFS_SOME_UNLOCK_FAILED_TITLE = "某些类型定义的解锁失败"
TYPE_DEFS_UNLOCK_MSG = "你想尝试不同的密码吗？"
TYPE_DEFS_UNLOCK_SUCCESS = "以下类型定义已成功解锁：\n%1。"
TYPE_DEFS_UNLOCK_ERROR = "由于错误 \"%2\"，无法解锁以下类型定义：\n%1。"
LOCK_MSG = "输入新密码进行锁定"
UNLOCK_MSG = "输入解锁密码"
ON_FILE = "以下文件："
PASSWORD_LABEL = "密码："
NEW_PASSWORD_LABEL = "新密码："
REENTER_PASSWORD_LABEL = "重新输入密码："
INCORRECT_PASSWORD = "密码不正确"
PASSWORD_CANNOT_UNLOCK = "解锁操作失败，因为密码不正确。"
PASSWORD_MISMATCH = "重新输入的密码与新密码不匹配。"
MAX_UNLOCK_ATTEMPTS = "您已达到解锁此文件所允许的最大失败次数。"
REMEMBER_PASSWORD_LABEL = "记住密码："
REMEMBER_PASSWORD_OPTION_NONE = "否"
REMEMBER_PASSWORD_OPTION_CURRENT = "对于当前会话"
REMEMBER_PASSWORD_OPTION_CURRENT_AND_FUTURE = "对于当前和未来的会话"

[RUNMODE_NOTSAVED_DLG]
DLG_TITLE = "警告"
RUNMODE_NOTSAVED_WARNING = "在执行显示中所做的运行模式更改不会保存。\n使用序列文件窗口进行永久运行模式更改。"
STOP_DISPLAY_WARNING = "下次不要显示此警告信息"

[SAVE_SEQFILE_DLG]
SAVE_SEQFILE_DLG_TITLE = "保存序列文件"
SAVE_BTN_LABEL = "保存"
DONT_SAVE_BTN_LABEL = "不保存"
SELECT_SEQFILE_TO_SAVE = "选择要保存的序列和文件："

[SAVE_OVER_OLDFORMAT_FILE_DLG]
DLG_TITLE = "备份提示"
PROMPT_LABEL = "你正在用旧文件格式或更新文件格式的现有文件保存序列文件。你想创建现有文件的备份副本吗？"
PROMPT_LABEL_SAVE_AS = "您正在将序列文件保存为旧文件格式，并且您正在替换现有文件。当您以旧格式保存文件时，您可能会失去一些功能。是否要创建现有文件的备份副本文件？"
YES_LABEL = "是"
NO_LABEL = "否"
CANCEL_LABEL = "取消"
OPTIONS_BACKUP_LABEL = "以旧格式或新格式重新保存时备份序列文件："
OPTIONS_BACKUP_YES = "是"
OPTIONS_BACKUP_NO = "否"
OPTIONS_BACKUP_PROMPT = "提示"
FILENAME_TITLE = "文件名："
HELP_LABEL = "帮助"

[SELECT_TYPES_DLG]
TITLE = "选择类型："
TYPE_NAMES_HDR = "名称"
TYPE_CATEGORY_HDR = "类别"
STEP_TYPE = "步骤类型"
CUST_TYPE = "自定义数据类型"
STANDARD_TYPE = "标准数据类型"

[SHUTDOWN_EXECUTIONS_DLG]
DIALOG_TITLE = "未完成的执行"
TERMINATE_ALL_BUTTON_TEXT = "终止所有"
ABORT_ALL_BUTTON_TEXT = "中止所有"
EXPLAIN_TEXT = "以下执行未完成。您可以全部终止、中止或CANCEL关机。"

[SHUTDOWN_MODIFIED_FILES_DLG]
DIALOG_TITLE = "修改文件"
SAVE_ALL_BUTTON_TEXT = "保存选中的文件"
SHUTDOWN_DISCARD_ALL_BUTTON_TEXT = "退出不保存"
LOGOUT_DISCARD_ALL_BUTTON_TEXT = "注销不保存"
CLOSE_ALL_WINDOWS_DISCARD_ALL_BUTTON_TEXT = "关闭而不保存"
EXPLAIN_LOGOUT_TEXT = "以下文件已修改。在注销前选择您要保存的文件。TestStand 不会保存对您未选择的文件的任何修改。"
EXPLAIN_SHUTDOWN_TEXT = "以下文件被修改。退出前选择您要保存的文件。TestStand 不会保存对您未选择的文件的任何修改。"
EXPLAIN_CLOSE_ALL_WINDOWS_TEXT = "以下文件已修改。在关闭所有窗口之前选择您要保存的文件。TestStand 不会保存对您未选择的文件的任何修改。"
EXPLAIN_SAVE_ALL_WINDOW_TEXT = "以下文件已修改。TestStand 仅保存您选择的文件。"
EXPLAIN_TEXT_DIMMED_ITEMS = "您没有必要的权限来保存变暗的文件。"
DIALOG_TITLE_SAVE_ALL = "全部保存"

[SEQUENCE_EDITOR_OPTIONS_DIALOG]
DIALOG_TITLE = "序列编辑器选项"

MAKE_UNIQUE_STEP_NAMES_LABEL = "插入步骤时使步骤名称唯一"
CLOSE_COMPLETED_EXECUTION_DISPLAYS_ON_EXECUTION_START_LABEL = "执行开始时关闭已完成&执行显示"
DISPLAY_RUNMODE_NOTSAVED_WARNING_LABEL = "在执行窗口中显示关于运行模式更改的警告"

HIDE_USER_MANAGER_WND_LABEL = "&Disable 'View User Manager' 命令"
SAVE_BEFORE_RUNNING_LABEL = "运行前保存："
ALWAYS_OPTION_LABEL = "总是"
ASK_OPTION_LABEL = "提示"
NEVER_OPTION_LABEL = "从不"

BACKUP_WHEN_RESAVING_IN_NEWER_VORMAT_LABEL = "以旧格式或新格式重新保存时备份序列文件"
BACKUP_YES = "总是"
BACKUP_PROMPT = "提示"
BACKUP_NO = "从不"

ALLOW_EDITING_READ_ONLY_FILES_LABEL = "允许编辑只读文件"
SHOW_LISTVIEWS_TOOLTIPS = "显示列表&视图工具提示"
OK_BTN = "确定"
CANCEL_BTN = "取消"
HELP_BTN = "帮助"

[SELECT_SEQFILE_DLG]
SELECT_SEQFILE_DLG_TITLE = "选择序列文件"
SELECT_SEQFILE_TO_DIFF = "选择打开的序列文件进行比较："

[TOOLBARS_DLG]
DLG_TITLE = "工具栏"
CLOSE_BTN_LABEL = "关闭"

TOOLBAR_STANDARD = "标准"
TOOLBAR_DEBUG = "调试"
TOOLBAR_ENVIRONMENT = "环境"
TOOLBAR_FIND = "查找"

[TYPE_USAGE_SELECTION_DLG]
DLG_TITLE = "选择类型用法"
GOTO_BTN_LABEL = "转到"

[EDIT_ENUMERATORS_DLG]
EDIT_ENUMERATORS_DLG_TITLE = "编辑枚举器"
EDIT_ENUMERATORS_DLG_DESCRIPTION = "使用此对话框添加、修改或删除枚举器。"
FLAGS_CHECK_BOX_LABEL = "标志枚举"
STRICT_CHECK_BOX_LABEL = "严格枚举"
ENUMERATOR_COLUMN_HEADER = "枚举器"
VALUE_COLUMN_HEADER = "值"
TOOL_TIP_TEXT_FOR_DELETE_COLUMN = "删除枚举器"
DUPLICATE_ENUMERATOR_NAMES_NOT_ALLOWED = "不允许重复的枚举器名称。"
INVALID_NAME = "请输入有效的枚举器名称。"
ERROR_CAPTION = "错误"
INVALID_FLOAT_64 = "请输入有效的 64 位浮点数。"
INVALID_FLOAT_64_FOR_FLAGS_ENUM = "将具有 64 位浮点表示的枚举设置为标志将可接受值的范围限制为 32 位整数。请输入有效的 32 位整数或更改表示。"
INVALID_INT_64 = "请输入一个有效的 64 位整数。"
INVALID_UINT_64 = "请输入一个有效的无符号 64 位整数。"

[EDIT_ENUM_VALUE_DLG]
EDIT_ENUM_VALUE_DLG_TITLE = "编辑枚举值"
ENUMERATOR_COLUMN_HEADER = "枚举器"
VALUE_COLUMN_HEADER = "价值"
ENUM_STRING_LABEL = "输入值字符串:"
VALUE_STRING_LABEL = "输入值数值:"
ERROR_CAPTION = "错误"
INVALID_STRING_VALUE = "请输入有效的枚举器名称。"
INVALID_NUMBER_VALUE = "%1 不是枚举 %2 的有效数值。"

;;适配器对话框
;; C/CVI 适配器共享字符串

[CVI_COMMON_DLG]
OK_BTN_LABEL = "__确定"
CANCEL_BTN_LABEL = "取消"
YES_BTN_LABEL = "__是"
NO_BTN_LABEL = "__否"

[CREATE_CODE_PROTOTYPE_PROMPT_DLGS]
PARSE_ERROR_DLG_TITLE = "代码模板解析错误"
PROTOTYPES_CONFLICT_DLG_TITLE = "原型冲突"
VALUES_CONFLICT_DLG_TITLE = "价值观冲突"
SOURCE_PROTOTYPE_CONFLICT_MESSAGE = "从源文件解析的原型与模块选项卡上的原型不同。选择要用于创建代码的原型："
TEMPLATE_PROTOTYPE_CONFLICT_MESSAGE = "从代码模板解析的原型与模块选项卡上的原型不同。选择用于创建代码的原型："
VALUES_CONFLICT_MESSAGE = "模块选项卡上的参数值与代码模板中指定的不同。选择要使用的值："
USE_MODULE_TAB_PROTOTYPE_RADIO_LABEL = "使用 &Module 选项卡中的原型"
USE_CODE_TEMPATE_PROTOTYPE_RADIO_LABEL = "使用来自&代码模板的原型"
USE_CODE_TEMPATE_PROTOTYPE_UPDATE_RADIO_LABEL = "使用代码模板中的原型并更新模块选项卡上的原型"
USE_SOURCE_PROTOTYPE_UPDATE_RADIO_LABEL = "使用源文件中的原型并更新模块选项卡上的原型"
USE_MODULE_TAB_VALUES_RADIO_LABEL = "&Keep the Values that are currently on the Module Tab"
USE_CODE_TEMPLATE_VALUES_RADIO_LABEL = "使用 &Code 模板中的值"
KEEP_MODULE_VALUES_CHECK_LABEL = "&Keep the Current Parameter Values"

[STEP_CODE_REPLACE_DLG]
STEP_CODE_REPLACE_DLG_TITLE = "替换步骤代码"
REPLACE_BTN_LABEL = "替换"
INSERT_BTN_LABEL = "插入"
RESTORE_BTN_LABEL = "重置"
SOURCE_CODE_LABEL = "源代码 (%1):"
INSERT_CODE_LABEL = "插入代码："


;; CVI适配器

[STANDARD_CVI_ADAPTER]
STEP_DESC_ALWAYS_RUN_IN_PROC = "始终在进程中运行"
;;指定模块对话框
EDIT_RUN_INPROCESS_LABEL = "始终在进程中运行"

CANT_CONNECT_TO_TSAUTOMGR Line0001 = "无法连接到 TSAutoMgr.exe 服务器。DCOM 权限可能不正确，因为 "
CANT_CONNECT_TO_TSAUTOMGR Line0002 = "远程执行的配置更改。要解决此问题，请确保当前用户具有默认的 DCOM 访问权限或 "
CANT_CONNECT_TO_TSAUTOMGR Line0003 = "dcomcnfg.exe 对话框的访问权限部分没有用户。您可以使用位于 Windows 系统目录中的 dcomcnfg.exe 程序，"
CANT_CONNECT_TO_TSAUTOMGR Line0004 = "更改 DCOM 访问权限。\n"
CANT_CONNECT_TO_TSAUTOMGR Line0005 = "细节：%1"

TSCVIRUN_AT_A_BRKPT Line0001 = "TestStand 用于运行 LabWindows/CVI 步骤的 LabWindows/CVI 实例当前在断点处暂停。这可能会阻止 "
TSCVIRUN_AT_A_BRKPT Line0002 = "执行终止或中止。通过在 LabWindows/CVI 中继续或终止执行来避免此问题。"
TSCVIRUN_AT_A_BRKPT_IGNORE_BTN = "忽略"
TSCVIRUN_AT_A_BRKPT_CONT_BTN = "&Continue execution in LabWindows/CVI"
TSCVIRUN_AT_A_BRKPT_TERM_BTN = "在 LabWindows/CVI 中终止执行(&T)"
PRELOAD_TIMEOUT_EXTERNAL_CVI = "LabWindows/CVI 正忙于执行另一个步骤。无法预加载 '%1'。"
CALL = "调用 %1 (%2)"
CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'"
CODE_TMPL_INVALID_PROTOTYPE = "代码模板文件中的原型不是标准的 LabWindows/CVI 测试执行原型。\n使用前必须将正确的原型放入代码模板中。"
CHANGING_STEP_PROTOTYPE_WARNING Line0001 = "此设置提供与 LabWindows/CVI 测试执行程序版本 2.0 或更早版本的向后兼容性。文本执行程序使用 "
CHANGING_STEP_PROTOTYPE_WARNING Line0002 = "扩展原型，包括一个额外的字符串参数，用于预测试和后测试。"
CHANGING_STEP_PROTOTYPE_WARNING Line0003 = "使用标准原型，除非你有正当理由不这样做。"
CVI_LOST_CONNECT = "与 LabWindows/CVI 的 ActiveX 连接丢失。LabWindows/CVI 适配器将尝试在下一次执行时重新连接。"
QUERY_TO_TERM_CVI_PRJ = "要继续，您必须终止在 LabWindows/CVI 中运行的程序。如果测试正在 LabWindows/CVI 中执行，此操作可能会导致 TestStand 卸载测试。"
CFG_CHANGE_WILL_UNLOAD_MODULES_WARNING = "更改测试执行位置会导致 TestStand 卸载所有模块。"
CFG_CHANGE_AUTOLOAD_WILL_UNLOAD_MODULES_WARNING = "配置支持库的自动加载会导致 TestStand 卸载所有模块。"
EXT_PROTO_FUNC_ABORT = "LabWindows/CVI 扩展原型测试返回失败。"
ALL_FILES_MSG = "所有文件"
PRJ_FILES_MSG = "LabWindows/CVI 项目文件"
OBJ_FILES_MSG = "目标文件"
SRC_FILES_MSG = "源文件"
DLL_FILES_MSG = "动态链接库"
LIB_FILES_MSG = "静态链接库"
LIB_OR_OBJ_FILES_MSG = "库或目标文件"
MISSING_STD_FILES = "以下文件不存在，无法添加到 LabWindows/CVI 项目：%1"
PRJ_PATH_EMPTY = "需要项目路径"
PRJ_PATH_INVALID = "项目路径无效。\n"
SRC_PATH_INVALID = "源文件路径无效。\n"
SRC_PATH_EXTENSION_INVALID = "LabWindows/CVI 开发环境仅支持 C 源文件。在尝试创建代码之前更改源文件的名称以使用 C 源文件扩展名 (.c)。\n"
PRJ_PATH_NOT_ABSOLUTE = "项目路径不是有效的绝对路径。"
MODULE_BROWSE_TITLE = "为步骤选择代码模块"
INVALID_CFG_MSG = "无效配置"
PRJ_BROWSE_TITLE = "选择 LabWindows/CVI 项目文件"
AUTOLOAD_LIBS_SUBDIR = "自动加载库"
OUTBUFFER_ANSI_CONV_ERR = "无法将 testData.outBuffer 转换为 ANSI 字符串。"
ERRORMSG_ANSI_CONV_ERR = "无法将 testError.errorMessage 转换为 ANSI 字符串。"
EXTMOD_LOAD_FAILURE = "无法加载标准 LabWindows/CVI 步骤外部模块。"
SRCMOD_LOAD_NOT_SUPPORTED Line0001 = "无法加载标准 LabWindows/CVI 步骤外部模块。\n"
SRCMOD_LOAD_NOT_SUPPORTED Line0002 = "注意：某些版本的 LabWindows/CVI 不支持运行源文件。请查阅 LabWindows/CVI 文档以获取更多详细信息。"
SRCMOD_LOAD_FAILURE Line0001 = "无法加载标准 LabWindows/CVI 步骤外部模块。\n"
SRCMOD_LOAD_FAILURE Line0002 = "当前 LabWindows/CVI 适配器配置为使用‘%1’项目在 LabWindows/CVI 的外部副本中运行测试。源文件‘%2’"
SRCMOD_LOAD_FAILURE Line0003 = "必须包含在这个项目中，TestStand 才能加载它。你想现在把文件添加到项目中吗？\n\n"
SRCMOD_LOAD_FAILURE Line0004 = "警告：TestStand 在添加源之前卸载所有 LabWindows/CVI 步骤模块"
SRCMOD_LOAD_FAILURE Line0005 = "文件到项目。"
EXTMOD_GETADDR_FAILURE = "无法获得 '%1' 的标准 LabWindows/CVI 步骤模块地址。"
EXTMOD_GETADDR_FAILURE_OBJ Line0001 = "无法获得‘%1’的标准 LabWindows/CVI 步骤模块地址。您可能有一个过时的 .obj 文件。"
EXTMOD_GETADDR_FAILURE_OBJ Line0002 = "根据模块的加载/卸载设置，您可能需要卸载所有模块或"
EXTMOD_GETADDR_FAILURE_OBJ Line0003 = "一旦你得到一个更新的 .obj 就关闭并重新打开序列文件，因为旧文件可能"
EXTMOD_GETADDR_FAILURE_OBJ Line0004 = "仍在记忆中。"
UNRESOLVED_REFS_LIST Line0001 = "代码模块引用了以下函数或变量，但 TestStand 找不到它们。"
UNRESOLVED_REFS_LIST Line0002 = "您可能需要在 tscvirun 项目中包含额外的库或仪器驱动程序文件，或者"
UNRESOLVED_REFS_LIST Line0003 = "自动加载 Libs 目录以确保 TestStand 可以加载模块："
MKDIR_OKCANCEL_QUESTION = "目录 '%1' 不存在。\n你想创建它吗？"
UNABLE_TO_CREATE_SRC_EXTENDED_PROTOTYPE = "TestStand 无法为扩展原型步骤创建代码。您必须手动为这种类型的步骤创建代码。"
CVI_ADAPTER_MSG_TITLE = "LabWindows/CVI 适配器消息"
ADD_CVI_LIBS_VER_STRING = "LabWindows/CVI 版本 %1 安装于：%2"
AUTOLOADLIBS_DATE_MISMATCH_WARNING_NEWER Line0001= "AutoLoadLibs 警告：\n\n文件 '%1' 的版本在其原始文件中找到了更新的文件日期 "
AUTOLOADLIBS_DATE_MISMATCH_WARNING_NEWER Line0002 = "目录：\n\n'%2'\n\n你想用这个版本替换 TestStand AutoLoadLibs 目录中的文件副本吗？"
AUTOLOADLIBS_DATE_MISMATCH_WARNING_OLDER Line0001 = "AutoLoadLibs 警告：\n\n在其原始文件中发现文件 '%1' 的版本具有较早的文件日期 "
AUTOLOADLIBS_DATE_MISMATCH_WARNING_OLDER Line0002 = "目录：\n\n'%2'\n\n你想用这个版本替换 TestStand AutoLoadLibs 目录中的文件副本吗？"
LIB_OR_OBJ_BROWSE_ADD_TITLE = "选择你想要添加的目标文件或库"
CONFIRM_DELETION_MSG = "你想删除选定的文件吗？"
CONFIRM_OBJ_FILE_CREATION = "\n源模块的相应目标文件：\n\n'%1'\n\n不存在。您希望 LabWindows/CVI 为您创建它吗？"
CONFIRM_OBJ_FILE_CREATION_OUTOFDATE = "\n源模块的相应目标文件：\n\n'%1'\n\n已过期。您希望 LabWindows/CVI 为您创建它吗？"
ERRORMSG_NON_DLL_MODULE_NOT_SUPPORTED = "CVI 适配器不再支持以 .dll 以外的格式调用模块。如果可能，从现有的源 (.c)、对象 (.obj) 或库 (.lib) 文件创建一个 .dll。"
PICK_DLL_FROM_PRJ_MSG = "所选项目包含多个目标文件。如果您想将模块 DLL 更新到这些路径之一，请选择所需路径，然后选择更新模块按钮。"
UPDATE_MODULE_BTN = "更新模块"
SKIP_BTN = "跳过"
;; ---------------------------------------------- --
;; TestData 和 TestError 用法
TESTDATA_COUNT_ERROR = "不允许超过一个 TestData 结构。\n\n此设置会导致运行时错误。"
TESTERROR_COUNT_ERROR = "不允许超过一个 TestError 结构。\n\n此设置会导致运行时错误。"
TESTERROR_USAGE_ERROR Line0001 = "你需要一个 TestData 结构来使用 TestError。"
TESTERROR_USAGE_ERROR Line0002 = "TestData 具有 TestError errorMessage 字段的分配器和释放函数。\n\n此设置会导致运行时错误。"
;; ---------------------------------------------- --
;;共享 Dlg 字符串
DLG_DONE_BTN = "完成"
;; ---------------------------------------------- --
;;适配器配置对话框字符串
ADP_CFG_DLG_CAPTION = "LabWindows/CVI 适配器配置"
ADP_CFG_DLG_GRP_BOX_TEXT = "步骤执行"
ADP_CFG_DLG_EXE_LOC1 = "在 LabWindows/CVI 的外部实例中执行步骤(&E)"
ADP_CFG_DLG_EXE_LOC2 = "执行步骤&In-Process（此模式不需要 LabWindows/CVI）"
ADP_CFG_DLG_CVI_PRJ_CAPT = "包含执行服务器的 LabWindows/CVI 项目的路径名："
ADP_CFG_DLG_CREATE_BTN = "创建"
ADP_CFG_DLG_AUTOLOAD_BTN = "配置自动加载链接 .objs 和 .libs 所需的支持库..."
ADP_CFG_TEMPLATE_CREATION_HDR = "代码模板策略"
ADP_CFG_ALLOW_NEW_TEMPLATES_ONLY = "只允许新模板"
ADP_CFG_ALLOW_OLD_TEMPLATES_ONLY = "仅允许旧版模板"
ADP_CFG_ALLOW_OLD_NEW_TEMPLATES = "允许新模板和旧模板"

;; ---------------------------------------------- --
;;自动加载库配置对话框
CFG_LIBS_DLG_CAPTION = "自动加载库配置"
CFG_LIBS_DLG_MSG1 = "TestStand 加载库和对象模块在"
CFG_LIBS_DLG_MSG2 = "加载任何其他模块之前的目录，以便 LabWindows/CVI 步骤中的模块链接回它们。"
CFG_LIBS_LIST_LABEL = "&library 中的文件："
CFG_LIBS_DLG_ADD_CVI_LIBS_BTN = "添加默认 LabWindows/CVI 库(&F)"
CFG_LIBS_DLG_ADD_OTHER_LIBS_BTN = "添加&其他库..."
CFG_LIBS_DLG_DELETE_BTN = "删除所选文件(&S)"
;; ---------------------------------------------- --
;; CVI 添加库对话框
CVI_LIBS_DLG_MSG = "您在此计算机上安装了多个版本的 LabWindows/CVI。为您要添加的库选择版本。"
CVI_LIBS_DLG_NO_CVI_INSTALLED = "在此计算机上找不到 LabWindows/CVI 安装。"
;; ---------------------------------------------- --
;;步骤配置对话框
STEP_CFG_DLG_CAPTION = "编辑 LabWindows/CVI 模块调用"
STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
STEP_CFG_DLG_EDIT_CODE_TAB_CAPTION = "源代码"
STEP_CFG_DLG_MOD_TYPE_TXT = "模块类型："

STEP_CFG_DLG_FUNC_NAME_TXT = "函数名称："
STEP_CFG_DLG_PASS_SEQ_CONTEXT = "传递序列和上下文"
STEP_CFG_DLG_STD_PROTO_TXT = "标准原型"
STEP_CFG_DLG_EXT_PROTO_TXT = "扩展原型(&X)"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0001 = "TestStand 需要以下信息供您编辑源代码"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0002 = "对于来自序列编辑器的这一步。如果你不想编辑"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0003 = "来自序列编辑器的源代码，您可以将这些条目留空。"
STEP_CFG_DLG_SRC_PATH_TXT = "包含函数的源文件及文件："
STEP_CFG_DLG_PRJ_PATH_TXT = "要打开的 LabWindows/CVI 和项目文件："
STEP_CFG_DLG_PRJ_PATH_OPT_TXT = "（可选）"
STEP_CFG_DLG_SRC_MODULE_BROWSE_DLG_FILTER = "源文件 (*.c)|*.c|所有文件 (*.*)|*.*||"

;; ---------------------------------------------- --
;;是，对所有人都是，中止对话，CCVIAtBrkptDlg，
;;对于 Yes_YesToAll_No_NoToAll 对话框，No，No to all
MISC_DLG_CAPTION = "LabWindows/CVI 适配器消息"
MISC_DLG_ABORT = "中止执行(&X)"

OBJECT_MODULE_TYPE = "目标文件 (*.obj)"
SOURCE_MODULE_TYPE = "源文件 (*.c)"
DLL_MODULE_TYPE = "动态链接库 (*.dll)"
LIBRARY_MODULE_TYPE = "静态链接库 (*.lib)"

EXTERNAL_PROCESS = "外部进程"

;; Dll C/C++ 适配器

[DLL_ADAPTER]
ADP_CFG_CAPTION = "C/C++ DLL 适配器配置"
ONE_DIM_STRING_ARRAY = "一维字符串数组"
ONE_DIM_BOOLEAN_ARRAY = "一维布尔数组"

BOOLEAN = "布尔值"
BOOLEAN_ARRAY = "布尔数组"

;;不确定是否应翻译以下内容。这些出现在
;;供用户选择的对话框。
CNIVECTOR_PARAM = "CNiVector"
CNIMATRIX_PARAM = "CNiMatrix"
CNICOMPLEX_PARAM = "CNiComplex"
CNICOMPLEXVECTOR_PARAM = "CNiComplexVector"
CNISTRING_PARAM = "CNiString"
CSTRING_PARAM = "CString"
CSTRINGARRAY_PARAM = "CStringArray"
CNIBOOLVECTOR_PARAM = "CNiBoolVector"
BSTR_T_PARAM = "_bstr_t"
CNISTRINGVECTOR_PARAM = "CNiStringVector"
TSOBJECT_PARAM = "TS 对象"

UNSPECIFIED_ENUM = "未指定的枚举类型"
PASS_BY_VALUE = "按值"
PASS_BY_POINTER = "通过指针 (*)"
PASS_BY_REFERENCE = "通过引用 (&)"
CLASS_PASS_BY_VALUE_PTR = "通过常量指针 (const *)"
CLASS_PASS_BY_VALUE_REF = "通过常量引用 (const &)"
CLASS_PASS_BY_REFERENCE_PTR = "通过指针 (*)"
CLASS_PASS_BY_REFERENCE_REF = "通过引用 (&)"
ARRAY_REAL_IMA_NOT_SAME_SIZE = "CNiComplexVector 参数的实部和虚部数组参数大小不同。实部数组大小：%1。虚部数组大小：%2"
UNKNOWN_INTERFACE_NAME = "<未知接口>"
INCOMPATIBLE_INTERFACE_PARAM = "参数表达式 '%1' 的对象接口与参数不兼容。需要 %2，找到 %3"
NOT_MSTUDIO_DLL_WARNING_MESSAGE Line0001 = "一个或多个指定参数使用 Measurement Studio、MFC 或 _bstr_t 类型，但 DLL '%1' 不提供对 Measurement Studio 类型的 TestStand 支持。这些设置会导致运行时错误。"
NOT_MSTUDIO_DLL_WARNING_MESSAGE Line0002 = "\n\n要将 TestStand 支持添加到 DLL，请使用添加/删除类库向导"
NOT_MSTUDIO_DLL_WARNING_MESSAGE Line0003 = "在 Measurement Studio 中将 TestStand Support 类库添加到项目中。"
NOT_MSTUDIO_DLL_WARNING_MESSAGE Line0004 = "此功能需要 Measurement Studio 企业版 7.0 或更高版本。"
NOT_MSTUDIO_DLL_WARNING_MESSAGE Line0005 = "有关 Measurement Studio 的更多信息，请参阅 http://www.ni.com/mstudio。"


STEP_CFG_DLG_EDIT_CODE_TAB_CAPTION = "源代码"
STEP_CFG_DLG_TARGET_TYPE_TEXT_FILE = "在文本文件中创建代码（仅限函数）"
STEP_CFG_DLG_TARGET_TYPE_VS_DOT_NET = "在 Microsoft Visual Studio 中创建代码"
STEP_CFG_DLG_PRJ_PATH_TXT = "Visual Studio 和项目文件："
STEP_CFG_DLG_SRC_PATH_TXT = "包含函数的源文件及文件："
STEP_CFG_DLG_SLN_PATH_TXT = "Microsoft Visual Studio 解决方案文件（可选）："
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0001 = "TestStand 需要以下信息供您编辑源代码"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0002 = "对于来自序列编辑器的这一步。如果你不想编辑"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0003 = "来自序列编辑器的源代码，您可以将此条目留空。"


STEP_CFG_DLG_CAPTION = "编辑 C/C++ DLL 调用"
;;尽管有 GetOpenFileName() 的 Microsoft 文档，*.c、*.cpp 的顺序很重要。
;;将 *.cpp 放在 *.c 之前以使用".cpp"作为默认扩展名。
STEP_CFG_DLG_SRC_MODULE_BROWSE_DLG_FILTER = "源文件 (*.cpp;*.c)|*.cpp;*.c|所有文件 (*.*)|*.*||"

CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'"

[C_ADAPTER_SHARED]
STEP_CFG_DLG_CREATE_CODE_BTN = "创建代码..."
STEP_CFG_DLG_EDIT_CODE_BTN = "编辑代码..."
STEP_CFG_DLG_VERIFY_PROTO_BTN = " 验证原型..."
USE_PROTO_FROM_MODULE_TAB_CHECK = "&Use Prototype from Module Tab"

UNABLE_TO_VERIFY_PROTO_SRC_DNE_PROMPT = "源文件不存在。\n你想为这一步创建源文件吗？"
UNABLE_TO_VERIFY_PROTO_FUNCTION_DNE_PROMPT = "在源文件中找不到函数定义。\n你想为这个步骤创建源吗？"
PROTOYPE_VERIFY_UPDATE_INVALID_SRC_PROTO_PROMPT = "源文件中的原型无效。\n你想用模块选项卡上的原型替换它吗？"
PROTOTYPE_VERIFY_SUCCESS_TITLE = "原型验证"
PROTOTYPE_VERIFY_SUCCESS_MSG = "源文件中的原型等同于模块选项卡上的原型。"

EXT_PROTO_DLG_PARAMS_STR_TXT = "&Params 字符串："
INVALID_CFG_MSG = "无效配置"
INVALID_STRING_VALUE = "<无效>"

PARSE_ERROR_MSG_TITLE = "源代码解析错误"
C_CODE_PARSE_ERROR_FMT_MSG = "解析文件时发生错误：\n'%1'\n%2\n"
C_CODE_UNMATCHED_BRACKET_PROMPT Line0001 = "找到了一个没有匹配的右括号字符 '}' 的左括号字符 '{'。\n"
C_CODE_UNMATCHED_BRACKET_PROMPT Line0002 = "无法解析不匹配括号后的代码。\n"
C_CODE_UNMATCHED_BRACKET_PROMPT Line0003 = "你想继续并忽略不匹配括号后的所有代码吗？"
CODE_TEMPLATE_PARSE_ERROR_FMT_MSG = "解析代码模板时出错：\n'%2'\n\n%1"
REQUIRED_CODE_TEMPLATE_STRING_MISSING = "所需的标记字符串 '%1' 未找到或以 C 标识符字符为前缀。"
CODE_TEMPLATE_FUNCTION_DEFN_MISSING = "找不到函数定义。检查函数参数列表和函数体括号。"
CODE_TEMPLATE_MULT_FUNCTION_DEFNS_FOUND = "在模板文件中找到了多个函数定义。TestStand 使用第一个定义并忽略其余的。"
RETURN_TYPE_PARSE_ERROR_MSG = "无法解析返回类型。"
PARAMETER_LIST_PARSE_ERROR_MSG = "无法解析参数列表。"
RELOAD_STEPCODE_ERROR = "重新加载源文件时发生错误。无法解析生成的代码。"

MISSING_FUNC_NAME = "您必须在执行此操作之前指定一个函数名称。您现在要指定一个吗？"
INVALID_FUNC_NAME Line0001 = "名称 '%1' 不是有效的函数名。函数名必须以字母开头，并且只能包含字母、数字和下划线。"
INVALID_FUNC_NAME Line0002 = "在执行此操作之前，您必须指定一个有效的函数名称。您现在要指定一个吗？"
INVALID_SRC_PATH = "要让 TestStand 执行此操作，源文件路径名必须有效。您现在要浏览文件吗？"
INVALID_MODULE_NAME Line0001 = "在执行此操作之前，您必须指定一个符合操作系统指南的有效模块名称。"
INVALID_MODULE_NAME Line0002 = "你现在想指定一个吗？"

C_ADAPT_ENUM_COMP_WRONG_REPRESENTATION_NO_TYPE_LIB = "所选枚举类型 '%1' 的数字表示与所选数据类型 %2 不兼容。"
C_ADAPT_ENUM_COMP_WRONG_REPRESENTATION = "枚举类型参数的数字表示 '%1' 与函数原型参数定义的数字数据类型 '%2' 不兼容。"
C_ADAPT_ENUM_COMP_MISMATCH_ENUMERATOR_COUNT = "参数的枚举类型 '%1' 与函数原型参数定义 '%2' 不匹配，因为它指定了不同数量的枚举数。"
C_ADAPT_ENUM_COMP_MISMATCH_ENUMERATOR_NAME = "参数的枚举类型 '%1' 与函数原型参数定义 '%2' 不匹配，因为它没有枚举数 '%3' 的定义。"
C_ADAPT_ENUM_COMP_MISMATCH_ENUMERATOR_VALUE = "参数的枚举类型 '%1' 与函数原型参数定义 '%2' 不匹配，因为枚举器的数值 '%3' 不匹配。"

DATA_TYPE_MISMATCH = "参数的数据类型 %1 与函数原型参数定义 %2 不匹配。"

MISSING_FUNC_NAME_NO_SPECIFY = "在执行此操作之前，您必须指定函数名称。"
INVALID_FUNC_NAME_NO_SPECIFY Line0001 = "名称 '%1' 不是有效的函数名。函数名必须以字母开头，并且只能包含字母、数字和下划线。"
INVALID_FUNC_NAME_NO_SPECIFY Line0002 = "在执行此操作之前，您必须指定一个有效的函数名称。"

SRC_BROWSE_TITLE = "选择源文件"

UNABLE_TO_EDIT_SRC_PRJ_NOT_FOUND = "无法找到此步骤的项目文件。确保模块项目文件存在于磁盘上。"
UNABLE_TO_EDIT_SRC_SRC_NOT_FOUND = "无法找到此步骤的源文件。确保模块源文件存在于磁盘上。"

;;;;
;;适配器配置对话框
SHOW_PARAMS_LABEL = "&Show Function Arguments in Step Description"
ADAPTER_PACKING_LABEL = "默认结构和包装："

;;消息
MISSING_FIRST_ARRAY_DIM_SIZE_MSG Line0001= "此函数的参数信息缺少一个或多个参数的第一个数组维度大小。\n"
MISSING_FIRST_ARRAY_DIM_SIZE_MSG Line0002= "您必须在指定模块对话框中为这些参数输入正确的大小。"
UNEXPECTED_ARRAY_DIM = "需要 %1 个维度，但参数有 %2 个维度。"
UNEXPECTED_ARRAY_DIM_SIZE = "预期维度大小为 %1，但参数的维度大小为 %2。"
UNEXPECTED_EMPTY_ARRAY = "不允许传递一个空的多维数组，发现 %1"


;;描述
MODULE = "[模块: %1] "
CALL = "%1 (%2)"

TWO_DIM_NUMERIC_ARRAY = "二维数字数组"

;;类型
TYPE_OBJECT = "对象"
TYPE_VOID = "无效"
TYPE_PTR = "指针/句柄"
TYPE_NUMERIC = "数字"
TYPE_ENUMERATION = "枚举"
TYPE_STRING = "字符串"
TYPE_STRUCT = "C 结构"
TYPE_NUMERIC_ARRAY = "数字数组"
TYPE_NUMERIC_ARRAY_FLOAT64_OR_BOOL = "数字数组{双精度，64位浮点数}或布尔数组"
TYPE_NUMERIC_ARRAY_I64_OR_BOOL = "数字数组{有符号 64 位整数} 或布尔数组"
TYPE_NUMERIC_ARRAY_UINT64_OR_BOOL = "数字数组 {无符号 64 位整数} 或布尔数组"
TYPE_STRING_ARRAY = "字符串数组"
TYPE_OBJECT_ARRAY = "对象数组"
TYPE_STRUCT_ARRAY = "C 结构数组"
TYPE_ENUM_ARRAY = "枚举数组"
;;数字类型
INT8 = "带符号的 8 位整数"
UINT8 = "无符号 8 位整数"
INT16 = "带符号的 16 位整数"
UINT16 = "无符号 16 位整数"
INT32 = "带符号的 32 位整数"
UINT32 = "无符号 32 位整数"
REAL32 = "32 位实数（浮点数）"
REAL64 = "64 位实数（双精度）"
INT64 = "带符号的 64 位整数"
UINT64 = "无符号 64 位整数"
;;对象类型
DISPATCH_PTR = "ActiveX 自动化 IDispatch 指针"
UNKNOWN_PTR = "ActiveX 自动化 IUnknown 指针"
CVI_AUTOMATION_HANDLE = "LabWindows/CVI ActiveX 自动化句柄"
;;通过
PASS_VALUE = "按值"
PASS_POINTER = "通过引用（通过指针）"
;;字符串类型
CSTRING = "C 字符串（常量）"
UNICODESTRING = "Unicode 字符串（常量）"
CSTRINGBUF = "C 字符串缓冲区"
UNICODESTRINGBUF = "Unicode 字符串缓冲区"
;;数组传递
ARRAY_ELEMPASS_EMBEDDED = "嵌入元素"
ARRAY_ELEMPASS_POINTER = "指向元素的指针"
;;通话约定
CDECL = "C (cdecl)"
STDCALL = "标准调用 (stdcall)"

DEFAULT_ARG_NAME = "arg"
DEFAULT_FUNC_NAME = "UnspecifiedFunction"
LIB_SELECT_DLG_TITLE = "选择 DLL"
DLL_FILES = "DLL 文件"
UNSPECIFIED_STRUCT = "未指定的结构类型"
INVALID_STRUCT = "无效的结构类型"
UNSPECIFIED_ENUMERATION = "未指定枚举类型"

;;指定模块参数/详细信息表。
COLUMN_VALUE_EXP_LABEL = "值表达式"
COLUMN_DESCRIPTION_LABEL ="说明"
COLUMN_NAME_LABEL = "名称"
COLUMN_LOG_LABEL = "日志"
COLUMN_PROPERTY_LABEL = "财产"
COLUMN_VALUE_LABEL = "价值"
COLUMN_CATEGORY_LABEL = "类别"
COLUMN_DATA_TYPE_LABEL = "类型"
COLUMN_ENUM_TYPE_LABEL = "枚举类型"
COLUMN_PASS_LABEL = "通过"
COLUMN_ARRAY_DIMENSIONS_LABEL = "维度"
COLUMN_ARRAY_DIMENSION_SIZE_LABEL = "Dim %1 大小"
COLUMN_ARRAY_SIZE_LABEL = "数组大小"
COLUMN_ARRAY_ELEM_PASS_LABEL = "元素通道"
COLUMN_BUFFER_SIZE_LABEL = "缓冲区大小"
COLUMN_RESULT_ACTION_LABEL = "结果操作"

;;SpecifyModule 控件
STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
FUNCTION_LABEL = "&函数名称："
RELOAD_PROTOTYPE_BTN_LABEL = "重新载入原型&&"
PARM_LABEL = "参数："
PARM_DETAIL_LABEL = "参数详情："
NEW_BTN_LABEL = "新建"
DELETE_BTN_LABEL = "删除"
MOVE_UP_BTN_LABEL = "上移"
MOVE_DOWN_BTN_LABEL = "下移"
EDIT_PROTOTYPE_LABEL = "编辑原型"
CREATE_PROTOTYPE_LABEL = "创建2.0原型"
MODULE_PATH_LABEL = "模块路径名："
ACCEPT_EDITS = "接受"
REVERT_EDITS = "恢复"
GOTO_ERROR = "转到错误"
CALL_LABEL = "函数调用："
PROTO_LABEL = "原型："

NO_ACTION = "无动作"
RTE_IF_LZ = "如果 Value < 0 将 Error.Occurred 设置为 True"
RTE_IF_GZ = "如果 Value > 0 设置 Error.Occurred 为 True"
RTE_IF_EZ = "if Value == 0 Set Error.Occurred to True"
RTE_IF_NEZ = "if Value != 0 Set Error.Occurred to True"
UNSPECIFIED_PARAM_VALUE = "?"
KEEP_PARAM_VALS = "你想保留当前参数值吗？"
KEEP_PARAM_VALS_TITLE = "保留参数值？"
USE_PARAM_INFO = "这个函数有参数信息。你想使用它吗？"
NO_PARAM_INFO = "此函数在 DLL 中没有参数信息或使用了 TestStand 无法识别的类型。"
BAD_PARAM_INFO = "TestStand 无法读取该函数的参数信息。该函数可能包含不受支持的参数类型。"
BAD_PARAM_INFO_XTRA = "TestStand 无法读取此函数的参数信息。参数名称 '%1' 是不受支持的类型。"
BAD_PARAM_INFO_RETURN_VALUE = "TestStand 无法读取此函数的参数信息。返回值是不受支持的类型。"
UNSUPPORTED_PARAM_WARN = "参数 '%1' 是不受支持的类型。该类型将默认为整数。"
CLEAR_PARAM_INFO = "你想放弃当前参数吗？"
USE_CODE_TEMPLATE_INFO = "此函数在 DLL 中没有参数信息或使用了 TestStand 无法识别的类型。\n您要使用代码模板来指定函数原型吗？"
USE_CODE_TEMPLATE_TITLE = "使用代码模板？"
CREATE_PROTOTYPE_WARNING = "创建2.0原型会丢弃当前参数和值。"
USE_PARAM_INFO_TITLE = "使用参数信息？"
CLEAR_PARAM_INFO_TITLE = "丢弃参数信息？"
NO_PARAMETER_INFO_TITLE = "没有可用的参数信息："
SYNTAX_ERR_RET_VAL = "返回值中存在语法错误：\n\n%1\n\n该值导致运行时错误。"
SYNTAX_ERR_PARAM = "参数 %1，'%2' 的值存在语法错误：\n\n%3\n\n该值导致运行时错误。"
SYNTAX_ERR_NUM_ELEMENTS = "参数 %1，'%2' 的元素数量表达式中存在语法错误：\n\n%3\n\n该值导致运行时错误。"
STRUCT_TYPE_NOT_FOUND = "未找到参数 %1 的结构类型，'%2'"
NEED_TO_SELECT_STRUCT_TYPE = "<选择结构类型>"
INVALID_STRUCT_TYPE = "<无效的结构类型>"
NEED_TO_SELECT_ENUM_TYPE = "<选择枚举类型>"
INVALID_ENUMERATION_TYPE = "<无效枚举类型>"
UNKNOWN_TEXT = "<未知>"

USE_PARAM_VALUE_INFO = "函数调用中的参数值与原型不匹配。是否要使用函数调用中参数值指定的数据类型？"
USE_PARAM_VALUE_TITLE = "使用参数值？"

SPECIFY_MODULE_INVALID_SRC_PATH = "无效的源文件路径。"

MODIFY_PROTOTYPE_TITLE = "解决函数调用和原型之间的差异"
ADD_RETVAL_PROMPT = "你指定了一个返回值，但函数原型表明该函数没有返回值。你想："
ADD_RETVAL_OPTION1 = "给函数原型添加一个返回值"
ADD_RETVAL_OPTION2 = "删除你输入的返回值"

DELETE_RETVAL_PROMPT = "你没有指定返回值，但函数原型表明函数有返回值。你想："
DELETE_RETVAL_OPTION1 = "删除函数原型的返回值"
DELETE_RETVAL_OPTION2 = "保留空返回值"

ADD_EXTRA_PARAMETERS_PROMPT = "你指定了 %1 个参数，但只有 %2 个参数。你想："
ADD_EXTRA_PARAMETERS_OPTION1 = "向函数原型添加 %1 个附加参数"
ADD_EXTRA_PARAMETERS_OPTION2 = "放弃函数的最后 %1 个参数"

DELETE_EXTRA_PARAMETERS_PROMPT = "你指定了 %1 个参数，但是有 %2 个参数。你想："
DELETE_EXTRA_PARAMETERS_OPTION1 = "从函数原型中删除最后的 %1 个参数"
DELETE_EXTRA_PARAMETERS_OPTION2 = "保留现有的 %1 个额外参数"


PARMFIX_MSG = "此 DLL 的类型信息未包含足够的信息来确定此函数参数是指向单个项目还是项目数组的指针。"
PARMFIX_TITLE = "读取函数参数列表时出现问题"
PARMFIX_GROUP_LABEL = "指定参数类型："
PARMFIX_DLL_FILE_LABEL = "DLL 文件："
PARMFIX_PARM_NUM_LABEL = "参数编号："
PARMFIX_FUNC_NAME_LABEL = "功能名称："
PARMFIX_SINGLE_ITEM_RADIO_LABEL = "Pointer to Single Item"
PARMFIX_ARRAY_RADIO_LABEL = "阵列"
PARMFIX_NUM_ELEM_LABEL = "元素数量："
PARMFIX_PARAM_NAME_LABEL = "参数名称："
ARRAYFIX_TITLE = "读取函数参数列表时出现问题"
ARRAYFIX_MSG = "这个 DLL 的类型信息没有包含足够的信息来确定这个数组参数的元素数量。"
ARRAYFIX_TYPE_LABEL = "数组元素类型："
ARRAYFIX_GROUP_LABEL = "指定数组元素数"

STRUCT_PROP_PAGE_TITLE = "C 结构传递"
ALLOW_STRUCT_PASSING_LABEL = "允许这种类型的对象作为结构传递"
SUBPROP_ALLOW_STRUCT_PASSING_LABEL = "要启用此选项卡上的控件，请右键单击包含此属性的类型，从上下文菜单中选择属性以启动类型属性对话框，然后启用允许此类型的对象作为结构传递选项C 结构传递选项卡。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL2 = "你不能在结构中包含这个属性，因为它是一个不允许结构传递的类型的实例。要启用它，右击包含这个属性的类型定义，从上下文菜单中选择属性来启动类型属性对话框，并在 C 结构传递选项卡上启用允许此类型的对象作为结构传递选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL3 = "此属性是一个类型的实例。要修改其属性，请右键单击类型定义并从上下文菜单中选择属性以启动类型属性对话框。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL4 = "这个属性是一个类型的实例。要修改它的值，右击包含这个属性的类型定义，然后从上下文菜单中选择属性来启动类型属性对话框。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL5 = "此容器属性已从结构中排除。要包含它，请右键单击包含此属性的类型，从上下文菜单中选择属性以启动类型属性对话框，并禁用传递结构时排除选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL6 = "此属性的父项之一已从结构中排除。要启用此选项卡上的控件，请右键单击包含此属性的类型，从上下文菜单中选择属性以启动类型属性对话框，然后禁用传递结构选项时排除。"
STRUCT_PACKING_LABEL = "包装："
STRUCT_PROP_LABEL = "属性："
STRUCT_PROP_GROUPBOX = "属性的内存布局"
STRUCT_PROP_TYPE_LABEL = "类型："
STRUCT_PROP_EXCLUDE_LABEL = "传递结构时排除"
STRUCT_ARRAY_STORAGE_LABEL = "存储数组："
STRUCT_OBJECT_TYPE_LABEL = "对象类型："
STRUCT_STRING_TYPE_LABEL = "字符串类型："
STRUCT_NUMERIC_TYPE_LABEL = "数字类型："
STRUCT_BOOLEAN_TYPE_LABEL = "布尔类型："
STRUCT_STRING_BUFFER_SIZE_LABEL = "字符串缓冲区大小："
STRUCT_MEMBER_STRUCT_STORAGE_LABEL = "存储结构："
STRUCT_STRING_STORAGE_LABEL = "存储字符串："
HIDDEN_STRUCT_MEMBER_SUFFIX = "（隐藏）"
STRUCT_MEMBER_NOT_ALLOWED_TITLE = "不能包含结构成员"
STRUCT_MEMBER_NOT_ALLOWED_MESSAGE = "指定的成员不能包含在结构中。"
STRUCT_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0001 = "指定的成员不能包含在结构中，因为你不能传递该类型的对象作为"
STRUCT_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0002 = "结构。您必须打开对象类型的属性表并启用允许此类型的对象作为结构传递选项。"
STRUCT_MEMBER_EMPTY_ARRAY_NOT_ALLOWED_MESSAGE Line0001 = "嵌入在结构中的数组不能为空。您必须打开数组的属性表并禁用边界页面上的空选项。\n\n"
STRUCT_MEMBER_EMPTY_ARRAY_NOT_ALLOWED_MESSAGE Line0002 = "LabVIEW 数组和使用指针传递的数组可以为空，因为类型定义不决定数组的大小。"

ADAPTER_PACKING_NOTE Line0001 = "你用来创建 DLL 的开发环境决定了选项 "
ADAPTER_PACKING_NOTE Line0002 = "用于结构封装值。\n\n"
ADAPTER_PACKING_NOTE Line0003 = "Visual C++ 和 Symantec C++ 使用默认的 8 字节打包。LabVIEW，Borland C++，"
ADAPTER_PACKING_NOTE Line0004 = "Watcom C++ 使用默认的 1 字节打包。对于 LabWindows/CVI，默认打包可以"
ADAPTER_PACKING_NOTE Line0005 = "8字节或1字节，具体取决于兼容模式。例如，在 Visual C++ 中"
ADAPTER_PACKING_NOTE Line0006 = "兼容模式，LabWindows/CVI 使用默认的 8 字节打包。"

PARSE_FUNCTION_CALL_ERROR = "函数调用表达式没有使用正确的函数调用语法。"

CREATE_TYPE_FROM_CLUSTER_DLG_CAPTION = "从结构创建/更新自定义数据类型"
PURPOSE_LABEL = "使用此对话框根据您选择的 C 结构创建或更新 TestStand 自定义数据类型。"
LABVIEW_LABEL_COLUMN = "C 名称"
LABVIEW_TYPE_COLUMN = "C 类型"
UPDATE_ACTION_COLUMN = "结构映射操作"
EXCLUDE_PROPERTY_WHEN_PASSING_CLUSTER = "传递结构时排除属性"
CHANGE_PROPERTY_TYPE = "更改类型或结构传递"
CHANGE_CLUSTER_ELEMENT_LABEL = "更改结构成员名称（原为'%1'）"
CHANGE_TESTSTAND_CLUSTER_LABEL = "更改 TestStand 结构标签"
ERROR_CREATING_ENUM_TYPE_IN_STRUCT = "从枚举参数元素 '%1' 创建/更新 TestStand 类型时发生以下错误：\n"

;; DotNet 适配器

[DOTNET_ADAPTER]
WARNING_NOT_ALL_TYPES_AVAILABLE = "由于以下错误，此程序集中的某些类可能不可用。要强制刷新此程序集的信息，请选择文件>>卸载所有模块。"
REQUIRES_TYPE_FROM_UNLOADABLE_ASSEMBLY = "程序集 '%3' 中类 '%2' 中的成员 '%1' 需要来自程序集 '%4' 的类型，但 TestStand 无法加载该程序集。要强制刷新此程序集的信息，选择文件>>卸载所有模块。"
STRUCT_FIELD_REQUIRES_TYPE_FROM_UNLOADABLE_ASSEMBLY = "调用成员 '%2' 时的参数 '%1' 需要来自程序集 '%3' 的类型，但 TestStand 无法加载该程序集。要强制刷新该程序集的信息，请选择文件 > >卸载所有模块。"
UNSUPPORTED_TYPE_ERROR_POINTER = "调用成员 '%2' 时的参数 '%1' 是指针类型。.NET 适配器不支持指针类型。"
OBJ_REF_DISPLAY_STRING = ".NET 类型：%1"
OBJ_REF_DISPLAY_STRING_WITH_TOSTRING = ".NET 类型：%1，ToString()：%2"
OBJ_REF_DISPLAY_STRING_EXCEPTION_OCCURRED = "<调用 ToString() 时发生异常：%1>"
STEP_DESC_ASSEMBLY_LABEL = "程序集："
ADP_CFG_DLG_CAPTION = ".NET 适配器配置"
ADP_CFG_SHOW_PARAMETERS_CHECK_LABEL = "在步骤描述中显示参数"
MODULE_BROWSE_TITLE = "为步骤选择代码模块"
SPEC_MOD_DLG_CAPTION = "编辑 .NET 调用"
STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
STEP_CFG_DLG_EDIT_CODE_TAB_CAPTION = "源代码"
CONFIG_CONSTRUCTOR_DLG_CAPTION = "配置类构造器"
MODULE_BROWSER_TITLE = "为步骤选择代码模块"
DLL_AND_EXE_FILES_MSG = "DLL 和 EXE 文件"
DLL_FILES_MSG = "DLL 文件"
EXE_FILES_MSG = "EXE 文件"
SELECT_AN_ASSEMBLY = "<选择一个程序集>"
SELECT_A_METHOD = "<选择方法>"
SELECT_A_PROPERTY = "<选择属性>"
SELECT_A_CLASS = "<选择类别>"
SELECT_AN_ACTION = "<选择一个动作>"
ASSEMBLY_NOT_FOUND_GAC = "（在 GAC 中找不到程序集）"
ASSEMBLY_NOT_SPECIFIED_GAC = "（未指定程序集）"
INTERFACE_REMOTE_ONLY = "已选择接口。必须使用远程功能。"
NAME = "名称"
TYPE = "类型"
OPTIONAL_PARAM = "可选"
DIRECTION = "方向"
DISPOSE = "处置"
LOG = "日志"
VALUE="值"
ASSEMBLY_FILE = "装配文件"
ASSEMBLY_GAC = "全球大会"
DO_NOT_CALL = "不要打电话"
CALL_METHOD = "调用方法"
GET_PROPERTY = "获取财产"
SET_PROPERTY = "设置属性"
CALL_CONSTRUCTOR = "调用构造函数"
CREATE_REMOTE = "创建远程对象"
USE_EXISTING = "使用现有对象"
KEEP_PARAM_VALS = "你想保留当前参数值吗？"
KEEP_PARAM_VALS_TITLE = "保留参数值？"
PARAMETER_DIFFER = "参数列表与之前指定的有所不同。\n"
ASSEMBLY_PATH_NOT_FOUND = "TestStand 找不到\n程序集 %1。"
ASSEMBLY_PATH_NOT_FOUND_TITLE = "找不到程序集"
MEMBER_NOT_FOUND = "TestStand 无法在类中找到成员 %1\n（具有正确的参数列表）。"
MEMBER_NOT_FOUND_TITLE = "未找到成员"
CLASS_NOT_FOUND = "TestStand 无法在程序集中找到类 %1。"
CLASS_NOT_FOUND_TITLE = "类未找到"
CONSTRUCTOR_NOT_FOUND = "TestStand 无法在类中找到构造函数。\n选择配置以指定构造函数。"
CONSTRUCTOR_NOT_FOUND_TITLE = "未找到构造函数"
DOTNET_ASSEMBLY_MISSING = "TestStand 无法加载 .NET 支持 DLL，因为无法解析程序集路径。"
DOTNET_ASSEMBLE_MISSING_TITLE = "找不到 .NET 程序集"
STEP_CFG_DLG_CREATE_CODE_BTN = "创建代码..."
STEP_CFG_DLG_EDIT_CODE_BTN = "编辑代码..."
DOTNET_ERROR = "访问 .NET 程序集时出错。\n"
DOTNET_ERROR_TITLE = ".NET 错误"
CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'"
CLASS_NOT_FOUND_TAG = "（未在程序集中找到）"
DOTNET_GAC_ASSEMBLY_MISSING = "在 GAC 中找不到强名称 %1。"
DOTNET_USE_THIS_ASSEMBLY = "\nGAC 已经包含一个同名的程序集。你想使用 %1 吗？"

STEP_DESC_REMOTE = "远程对象 %1"
STEP_DESC_OPTIONAL_ARG = "<使用默认值>"
STEP_DESC_UNSPECIFIED_ARG = "<未指定>"

ASSEMBLY_REFERENCE = "装配参考："
ASSEMBLY = "组装："
BROWSE = "浏览"
RELOAD = "重新加载"
CLASS_REFERENCE = "对象参考："
CLASS = "&Class:"
CREATE_OBJECT = "创建对象"
REMOTE_CALL = "远程呼叫"
SPECIFY_EXPRESSION = "为 URI 指定表达式"
USE_LOADSPEC = "使用分步加载/卸载选项指定对象创建时间和生命周期"
REMOTE_URI = "远程URI:"
CONSTRUCTOR = "构造函数："
CONFIGURE = "配置"
DISPOSE_ON_RELEASE = "释放对象时调用&Dispose"
CALL_METHOD_OR_ACCESS_MEMBER = "调用方法或访问属性(&A)"
METHOD_AND_PROPERTY_OPTIONS = "方法和属性选项："
STATIC = "静态"
STATIC_OPTIONS = "显示静态"
STATIC_MEMBER_TAG = "（静态）"
STRUCT_CLASS_TAG = "（结构）"
INTERFACE_CLASS_TAG = "（接口）"
NOT_CREATABLE_CLASS_TAG = "（不可创建）"
AMBIGUOUS_MEMBER_TAG = "（不明确）"
TOP_LEVEL_OPTIONS = "显示基类成员"
ACTIONLBL = "成员类型:"
MEMBER = "成员:"
PARAMETERS = "参数："
EDIT = "编辑"
CANT_GET_DEFAULT_VALUE = "\"默认值不可用\""
DN_PROGRESS_BAR_METHOD_MESSAGE = "检索方法信息"
DN_PROGRESS_BAR_PROPERTY_MESSAGE = "检索属性信息"
DN_PROGRESS_BAR_CLASS_MESSAGE = "正在检索职业信息"
DN_PROGRESS_BAR_CONSTRUCTOR_MESSAGE = "检索构造器信息"

RETURN_VALUE_PARAM_NAME = "返回值"
VALUE_PARAM_NAME = "值"
REMOTE_URI_PARAM_NAME = "远程 URI"
EXISTING_OBJECT_PARAM_NAME = "现有对象"
DISPLAY_NAME_FOR_CREATE_REMOTE_CALL = "<创建远程对象>"
DISPLAY_NAME_FOR_USE_EXISTING_CALL = "<使用现有对象>"
UNSPECIFIED_ENUM = "未指定的枚举类型"
ENUM			= "枚举"
ENUMS 			= "枚举数组"
ANYTHING_TYPE 	= "任何"
ANYTHING_TYPES 	= "任意数组"
POINTER_TYPE 	= "指针（不支持）"
ERROR_JAGGED_METHOD 	= "此方法的参数或返回值是锯齿状数组，TestStand 不支持。"
ERROR_JAGGED_CONSTRUCTOR = "这个构造函数有一个参差不齐的数组，TestStand 不支持。"
ERROR_JAGGED_PROPERTY = "此属性或字段是锯齿状数组，TestStand 不支持。"

DN_ERROR = ".NET 代码中发生错误。"
DN_GET_INSTANCE = "无法检索 .NET %1 的实例。"
DN_RELEASE_INSTANCE = "释放 .NET 对象引用时发生错误。"
DN_SET_INSTANCE = "无法存储 .NET %1 的实例。"
DN_LOAD_ASSEMBLY = "无法加载 .NET 程序集 %1。"
DN_CLASS_TYPE = "在程序集中找不到类 %1 的 .NET 类型。"
DN_CREATE_INSTANCE = "无法创建 .NET %1 %2。"
DN_CALL_MEMBER = "无法访问 .NET %1 '%2'。"
DN_CALL_MEMBER_TARGET = ".NET %1 '%2' 引发异常。"
DN_REFERENCE_ALREADY_EXISTS = ".NET 不允许引用两个具有相同名称的不同程序集。\n\n无法添加对"%1"的引用。对组件"%2"的引用已存在于项目中。"
DN_CALL_TARGET = ".NET %1 '%2' 在调用时抛出异常。"
DN_RETURN_PARAMETERS_NAME = "无法返回 .NET %1 '%2' 的值。"
DN_RETURN_PARAMETERS = "无法返回 .NET %1。"
DN_TYPE_MISMATCH = "类型不匹配 - 无法创建 .NET 参数数组。"
DN_STRUCT_VALUES = "类型不匹配 - TestStand 类型和 .NET 结构元素不匹配。"
DN_CLASS_LIST = "来自程序集 %1 的 .NET 类列表。"
DN_LIST_FROM_CLASS = "无法检索类 '%2' 中的 .NET %1 列表。"
DN_ACCESS_INFO = "无法访问 .NET %1 信息对象。"
DN_PARAM_LIST = "无法检索来自 %1 '%2' 的 .NET 参数列表。"
DN_PARAM_INFO = "无法访问 .NET 参数信息。"
DN_FREEING_LIST = "释放 %1 列表时发生错误。"
DN_IDENTIFY_TYPE = "识别参数类型时发生错误。"
DN_TYPE_INDEX = "类型索引的值为 %1，这是一个无效值。"
DN_PARAM_EVAL_ERROR = "评估参数 '%1' 的表达式时发生错误：\n"
DN_PARAM_EVAL_ERROR_FOR_CONSTRUCTOR = "计算对象 '%2' 的构造函数的 %3 '%1' 的表达式时发生错误。\n\n"
DN_PARAM_ARRAY_DIMENSIONS_ERROR = "数组参数的维度与参数所需的维度不匹配。"
DN_PARAM_JAGGED_ARRAY_ERROR = "你只能通过使用对象引用变量来存储和传递交错数组。"
DN_PARAM_NULL_PASSED_FOR_VALUE_TYPE_ERROR = "你不能为值类型参数传递 NULL 或 Nothing。"
DN_PARAM_ARRAY_ELEMENT_NULL_PASSED_FOR_VALUE_TYPE_ERROR = "为元素 '%1' 传递了 NULL 或无。您不能为值类型参数传递 NULL 或无。"
DN_PARAM_ARRAY_INPUT_ARRAY_EMPTY_ERROR = "参数 '%1' 的数组是一个输入参数并且为空。\n\n"
DN_PARAM_ARRAY_ARRAY_STRUCTS_EMPTY_ERROR = "数组 '%1' 作为结构数组传递并且是空的。\n\n"
DN_PARAM_ARRAY_INPUT_ARRAY_EMPTY_ERROR_FOR_CONSTRUCTOR = "对象 '%2' 的构造函数的参数 '%1' 的数组是一个输入参数并且为空。\n\n"
DN_PARAM_INVAL_EMPTY = "调用成员 '%2' 时的输入参数 '%1' 未指定。您必须为所有输入参数指定一个表达式。"
DN_PARAM_INVAL_EMPTY_STRUCT_ARRAY = "作为结构数组的所有参数必须至少包含一个元素。"
DN_PARAM_INCOMPATIBLE_WITH_SYSTEM_OBJECT_PARAMETER = "参数表达式 '%1' 的类型与调用成员 '%3' 时为参数 '%2' 返回的对象不兼容。您不能将 .NET 类型 '%4' 存储在类型 %5 的 TestStand 变量中"
DN_INVOKE_TARGET_ERROR = "调用 .NET 成员 '%1' 时发生异常：\n%2"
DN_INVOKE_ERROR = "调用 .NET 成员 '%1' 时发生错误："
STRUCT_ARG_ALL_OR_NOTHING = "您必须为结构 '%1' 指定所有元素，或者一个都不指定。\n\n未指定元素 '%2'。"
STRUCT_ARG_MAPPING_INCOMPLETE = "您必须指定所有元素结构 '%1' 或一个都不指定。\n当您使用参数映射时必须映射所有元素。\n\n元素 '%2'未映射。"
DN_NO_CONSTRUCTOR_CONFIGURED = "类或结构 '%1' 没有公共构造函数。\n选择另一个类或禁用创建实例选项。"
DN_CONSTRUCTOR_PARAMS_NOT_CONFIGURED = "您选择的类不包含参数为零的构造函数。\n您需要配置构造函数的参数。"
DN_CONSTR_PARAMS_NOT_CONFIG_TITLE = "构造器参数"
SYNTAX_ERR_REMOTE_HOST_EXPR_VAR = "远程主机表达式："
SYNTAX_ERR_CLASS_REF_EXPR_VAR = "类引用表达式："
DN_NO_CLASS_OBJECT_ERROR Line0001= "您正试图访问未指定对象的成员。您必须在此步骤中创建一个新对象或指定一个对象引用变量。这些设置会导致 "
DN_NO_CLASS_OBJECT_ERROR Line0002= "运行包含此步骤的序列时出错。"
DN_NO_MEMBER_NAME_SPECIFIED = "您选择了'调用方法或访问属性：'但没有指定成员。"
DN_INTERFACE_WITHOUT_REMOTE = "您选择了接口 '%1' 但没有使用远程调用。"
DN_ELEMENT_NOT_MATCHING_STRUCT = "参数的类型与 .NET 结构 '%1' 不匹配，或者结构传递在类型定义中被禁用。"
DN_ERROR_ENUM_FIELD_WRONG_REPRESENTATION = "参数的数字表示与 .NET 枚举 '%1' 的定义不兼容。"
DN_ELEMENT_NOT_MATCHING_ENUM_ENUM_VALUE = "参数类型与 .NET 枚举 '%1' 不匹配。指定枚举器的数值不匹配。"
DN_NULLABLE_STRUCT_DOES_NOT_HAVE_EXPECT_FIELDS = "类型 '%1' 是可空类型，但没有 TestStand 期望可空类型具有的字段。可空类型的 .NET Framework 定义必须已更改。请联系 National Instruments 报告此问题。"
DN_METADATA_TOKEN = "无法检索元数据令牌。"
DN_NO_CLASS_SPECIFIED_TITLE = "类别未指定"
DN_NO_CLASS_SPECIFIED = "您必须指定一个类名才能执行该步骤。"
DN_NULL_CLASSREF = "您没有创建对象，\n您还没有将类引用设置为对象。"
DN_COM_CLASSREF = "类引用中指定的对象不是 .NET 对象。\n因为您不是在创建对象，所以必须使用 .NET 对象。"
DN_GENERICS = "您正在访问一个使用泛型的类。\n这个版本的 TestStand 不支持泛型。"
DN_FRAMEWORK_VERSION_MISMATCH = "该程序集是使用比加载版本更高版本的 .NET 框架构建的。\n此应用程序加载了 %1 的 .NET 框架。\n该程序集是使用 %2 的 .NET 框架构建的。"
DN_ERROR_NO_MATCHING_FIELD_IN_TYPEDEF = ".NET 结构‘%3’的字段‘%2’在类型‘%1’中没有相应的子属性"
DN_ERROR_ARRAY_OUTPUT_IS_NULL = "预期数组，但输出值为 NULL。您不能将 NULL 引用存储为 TestStand 数组。"
DN_ERROR_OUTPUT_TYPE_UNEXPECTED = "输出参数或返回值与预期类型不匹配。"
DN_ERROR_STRUCT_HAS_CHANGED = "结构 '%1' 的定义在程序集中与您指定模块时不同。您必须更新模块规范和数据 TestStand 通过。"
DN_ERROR_CREATE_CODE_LAST_CALL_DOES_NOT_RETURN_CLASS_OR_STRUCT = "无法创建代码，因为最后一次调用没有返回类或结构。TestStand 使用最后一次调用的返回值来指定要在其中创建代码的类。"
DN_ERROR_STRUCT_FIELD_WRONG_TYPE = "属性 '%1' 的类型与 .NET 结构 '%3' 的字段 '%2' 的结构定义不兼容。"
DN_ERROR_ENUM_FIELD_WRONG_REPRESENTATION_WITH_ARG = "类型 '%1' 的数字表示与 .NET 枚举 '%2' 的定义不兼容。"
DN_ERROR_NO_MATCHING_FIELD_IN_TYPEDEF_WITH_ARG = ".NET 结构 '%4' 的字段 '%3' 的类型 '%2' 的参数 '%1' 中没有相应的子属性。"
DN_ELEMENT_NOT_MATCHING_STRUCT_WITH_ARG = "参数 '%1' 的类型与 .NET 结构 '%2' 不匹配，或者结构传递在类型定义中被禁用。"
DN_ELEMENT_NOT_MATCHING_OF_NOT_PASSING_ENUM_WITH_ARG = "参数 '%1' 的类型与 .NET 枚举 '%2' 不匹配，或者结构传递在类型定义中被禁用。"
DN_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_COUNT = "参数 '%1' 的类型与 .NET 枚举 '%2' 不匹配，因为它指定了不同数量的枚举器。"
DN_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_NAME = "参数 '%1' 的类型与 .NET 枚举 '%2' 不匹配，因为它没有 '%3' 的定义。"
DN_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_VALUE = "参数 '%1' 的类型与 .NET 枚举 '%2' 不匹配，因为枚举器 '%3' 的数值不匹配。"
DN_ERROR_TYPE_NOT_VALID_FOR_ARRAY_OF_STRUCTS = "参数 '%1' 的类型对结构数组无效。使用对象引用数组或自定义数据类型的数组，该数组对应于 .NET 结构并配置为支持 .NET结构传递。"

DN_MEMBER_ASSEMBLY = "组件"
DN_MEMBER_CLASS = "类"
DN_MEMBER_STRUCT = "结构"
DN_MEMBER_PARAMETER = "参数"
DN_MEMBER_METHOD = "方法"
DN_MEMBER_CONSTRUCTOR = "构造函数"
DN_MEMBER_PROPERTY = "属性"
DN_MEMBER_ELEMENT = "元素"
DN_MEMBER_FIELD = "字段"
STRUCT = "结构"
STRUCTS = "结构数组"


CREATE_TYPE_FROM_STRUCT_DLG_CAPTION = "从结构创建自定义数据类型"
PURPOSE_LABEL = "使用此对话框根据您选择的 .NET 结构创建 TestStand 自定义数据类型。"
CREATE_TYPE_IN_FILE = "创建自定义数据类型&In 文件："
SELECTED_SEQ_FILE = " -- <选定的序列文件>"
TYPE_NAME_LABEL = "类型&名称："
STRUCT_CREATE_BTN_LABEL = "创建&创建"

PROMPT_FOR_CALL_CAPTION = "选择呼叫"
CHOOSE_CALL_LABEL = "选择要执行您指定操作的呼叫："

SAVE_FILE_TO_STEP_CAPTION = "存储文件到步骤？"
SAVE_FILE_TO_STEP_TEXT = "将此文件存储为此步骤的 %1？TestStand 将此文件用于此步骤的所有调用。使用 .NET 源代码文件对话框更改此文件。"
DONT_ASK_AGAIN_TEXT = "不要在这一步再次询问 %1s。"
SOURCE_FILE = "源文件"
PROJECT_FILE = "项目文件"
SOLUTION_FILE = "解决方案文件"

DN_STRUCT_PROP_PAGE_TITLE = ".NET 结构传递"
ALLOW_STRUCT_PASSING_LABEL = "允许此类型的对象作为 .NET 结构传递(&Y)"
DN_STRUCT_PROP_LABEL = "属性："
DN_STRUCT_PROP_GROUPBOX_LABEL = "属性的内存布局"
DN_STRUCT_PROP_TYPE_LABEL = "类型："
DN_STRUCT_MEMBER_LABEL = "结构元素名称："
DN_STRUCT_PROP_EXCLUDE_LABEL = "传递结构时排除"
DN_STRUCT_MEMBER_NOT_ALLOWED_MESSAGE = "你不能在结构中包含指定的成员。"
DN_STRUCT_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0001 = "您不能在集群中包含指定的成员，因为该类型的对象不允许作为"
DN_STRUCT_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0002 = "结构。打开对象类型的属性表并启用允许此类型的对象作为 .NET 结构传递选项。"
DN_STRUCT_MEMBER_TYPE_NOT_ALLOWED_TITLE = "不能包含结构成员"
DN_STRUCT_LABEL_COLUMN = ".NET 元素标签"
DN_STRUCT_TYPE_COLUMN = "类型"
DN_STRUCT_NAME_COLUMN = "属性名称"
DN_STRUCT_CREATE_BTN_LABEL = "创建"
SUBPROP_ALLOW_STRUCT_PASSING_LABEL = "要启用此属性页中的控件，打开包含此属性的类型的属性表并启用允许此类型的对象作为 .NET 结构传递选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL2 = "您不能在结构中包含此属性，因为它是不允许结构传递的类型的实例。打开类型定义的属性表并启用允许此类型的对象作为 .NET 结构传递选项"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL3 = "这个属性是一个类型的实例。要修改它的属性，打开类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL4 = "这个属性是一个类型的实例。要修改它的值，打开包含这个属性的类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL5 = "此容器属性已从结构中排除。要包含它，请打开其父项的属性表并禁用传递结构时排除选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL6 = "此属性的父项之一已从结构中排除。要启用此属性页上的控件，请打开该父项的属性表并禁用传递结构时排除选项。"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0001 = "TestStand 需要以下信息供您编辑源代码"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0002 = "对于来自序列编辑器的这一步。如果你不想"
STEP_CFG_DLG_EDIT_CODE_EXPLAIN_MSG Line0003 = "从序列编辑器编辑源代码，您可以将这些条目留空。"

PARAM_DISPLAY_VALUE_FOR_ARGUMENT = "<DotNetArgument 值>"

;; Python适配器
[PYTHON_ADAPTER]
SPEC_MOD_DLG_CAPTION = "编辑 Python 调用"

STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
STEP_CFG_DLG_ADVANCE_SETTINGS_TAB_CAPTION = "高级设置"

ADP_CFG_CAPTION = "Python 适配器配置"
ADP_CFG_INTERPRETER_OPTIONS = "Python 解释器选项"
PYTHON_INTERPRETER_TO_USE = "要使用的 Python 和解释器："
PYTHON_VERSION = "Python版本:"
UNSUPPORTED_PYTHON_VERSION = "TestStand 支持 python 2.7+ 和 3.6+。指定带有主要和次要版本号的版本，如'2.7'或'3.6'。确保 python 路径存在于 PATH 环境变量中。"
UNSUPPORTED_PYTHON_VIRTUAL_ENV_FOLDER = "无效的虚拟环境路径。TestStand 支持使用 'virtualenv' 工具创建的虚拟环境。确保可以使用 TestStand 搜索目录找到虚拟环境目录。"
VIRTUAL_ENV_PATH = "Python 虚拟环境和环境："
BROWSE_VIRTUAL_ENV_TOOLTIP = "浏览虚拟环境文件夹..."
DISPLAY_CONSOLES_FOR_INTERPRETER_SESSIONS = "解释器显示控制台"

ADP_CFG_PY_MODULE_VIEWER_SETTINGS = "Python 模块查看器"
MODULE_VIEWER_APP_PATH = "应用程序和路径："
MODULE_VIEWER_APP_ARGUMENTS = "参数："
BROWSE_FOR_MODULE_VIEWER_APP = "浏览Python 模块查看器应用程序..."
MODULE_VIEWER_APP_BROWSE_TITLE = "选择用于查看 Python 模块的应用程序"

MODULE_VIEWER_APP_CAPTION = "TestStand Python 模块查看器"
SPECIFY_MODULE_VIEWER_APP = "您需要指定一个外部应用程序来查看 Python 模块。"
MODULE_VIEWER_APP_CANNOT_BE_FOUND = "找不到 Python 适配器配置中指定的外部 Python 模块查看器应用程序。\n确保指定的应用程序存在。如果不使用绝对路径，请确保将搜索路径添加到 TestStand。"
MODULE_VIEWER_APP_ARGS_MUST_CONTAIN_MODULE_PATH = "Python 模块查看器应用程序的参数必须包含 '%1' 占位符。"
MODULE_VIEWER_APP_CONFIG_INFO = "\n\n在配置->适配器...->Python 中适当地配置 Python 模块查看器应用程序和应用程序参数。"

OK = "确定"
CANCEL = "取消"
HELP = "帮助"

MODULE_DESCRIPTION = "[模块: %1] "
CREATE_CLASS_DESCRIPTION = "新 %1(%2)"
CALL_FUNCTION_DESCRIPTION = "%1(%2)"
GET_ATTRIBUTE_DESCRIPTION = "%1getattr(%2)"
SET_ATTRIBUTE_DESCRIPTION = "%1setattr(%2, %3)"

PYTHON_HOLDER_OBJECT = "Python 对象"
PYTHON_INTERPRETER_SESSION_HOLDER_OBJECT = "Python 解释器会话"

CAPTION_TESTSTAND = "TestStand"
MODULE_COM_EXCEPTION = "无法加载模块 '%1'。遇到以下错误：\n\n"

CONSOLE_TITLE_PREFIX = "TestStand Python 解释器会话 - "

PY_PARAMETER_PROP_PAGE_TITLE = "Python 参数传递"
ALLOW_STRUCT_PASSING_LABEL = "允许此类型的对象作为 .NET 结构传递(&Y)"
PY_PARAMETER_PROP_LABEL = "属性："
PY_PARAMETER_PROP_GROUPBOX_LABEL = "属性的内存布局"
PY_PARAMETER_PROP_TYPE_LABEL = "类型："
PY_PARAMETER_PROP_EXCLUDE_LABEL = "传递元组时排除&x"
PY_TUPLE_INDEX_LABEL = "元组属性索引："
HIDDEN_STRUCT_MEMBER_SUFFIX = "（隐藏）"
PY_PROP_ENUM_INFO_GROUPBOX_LABEL = "枚举映射信息"
PY_PROP_ENUM_LABEL = "枚举："
PY_PROP_MODULE_PATH_RESOLUTION_HELP_LABEL = "如果指定的模块路径是相对路径，它将在运行时解析为绝对路径。它基于使用此类型的序列上下文。"
PY_PROP_INVALID_ENUM_NAME = "解析 python 模块时未找到指定的枚举。如果枚举在模块运行时存在，TestStand 枚举将作为此类枚举传递给 python 模块。"
PY_PASS_PROPERTY_AS_LABEL = "将属性传递:"
PY_PASS_PROPERTY_AS_USE_ADAPTER_SETTING = "使用适配器设置（%1）"
PY_PASS_PROPERTY_AS_LIST = "列表"
PY_PASS_PROPERTY_AS_NUMPY_ARRAY = "NumPy数组"

;;序列适配器
[SEQUENCING ADAPTER]
TYPE_CONFLICT_IN_MODEL_FILE = "新执行使用的模型文件包含与客户端序列文件或已加载到内存中的另一个文件冲突的类型。"
UNABLE_TO_OPEN_SEQUENCE_CALL_MODULE_FILE = "无法打开序列调用模块文件。"
USE_CURRENT_FILE_AND_REMOTE_MSG Line0001 = "为远程执行启用了使用当前文件选项。"
USE_CURRENT_FILE_AND_REMOTE_MSG Line0002 = "对于远程执行，您必须为序列文件指定路径或路径表达式。"

EVAL_REMOTE_HOST_ERROR_DESC = "评估远程主机表达式时出错。"
EVAL_MODULE_SEQFILE_ERROR_DESC = "评估模块序列文件路径表达式时出错。"
EVAL_MODULE_SEQUENCE_ERROR_DESC = "评估模块序列名称表达式时出错。"

CANT_EVAL_REMOTE_HOST_DESC = "TestStand 仅在运行时评估指定远程主机的表达式。"
CANT_EVAL_MODULE_SEQFILE_PATH_DESC = "TestStand 仅在运行时评估指定模块序列文件路径的表达式。"
CANT_EVAL_MODULE_SEQ_NAME_DESC = "TestStand 仅在运行时评估指定模块序列名称的表达式。"

EMPTY_HOST_MSG = "没有指定远程主机。"
EMPTY_HOST_MSG_TITLE = "序列调用"
TEST_OBJ_PARAMETER_OF_REMOTE_CALL_MSG Line0001 = "此序列调用的一个或多个参数是属性容器。"
TEST_OBJ_PARAMETER_OF_REMOTE_CALL_MSG Line0002 = "因为 TestStand 将属性容器参数转换为远程序列调用的对象引用，"
TEST_OBJ_PARAMETER_OF_REMOTE_CALL_MSG Line0003 = "你不能使用引用远程序列中参数子属性的表达式。"
TEST_OBJ_PARAMETER_OF_REMOTE_CALL_MSG Line0004 = "使用 TestStand ActiveX API 中的属性对象类访问远程序列中参数的子属性。"

TEST_OBJ_PARAMETER_OF_REMOTE_CALL_TITLE = "序列调用"

SEQ_PROTOTYPE_SELECTION_DLG_LABEL = "加载序列原型"
SEQ_MODULE_DLG_LABEL = "编辑序列调用"

PATHNAME_AND_SEQUENCE_GROUP_LABEL = "路径名和序列"
MULTITHREAD_GROUP_LABEL = "多线程和远程执行"
SPECIFY_BYEXPR_BTN_LABEL = "为路径名和序列指定表达式"
USE_CURRENT_FILE_BTN_LABEL = "使用当前文件"
NO_MODEL_SPECIFIED_TEXT = "<未指定>"

FILEPATH_EDITOR_LABEL = "文件路径名："
FILEPATH_EXPR_EDITOR_LABEL = "文件路径或参考："
FILEPATH_EXPR_EDITOR_LABEL_REMOTE_EXE = "&文件路径："
SEQUENCE_COMBOBOX_LABEL = "序列："
SEQUENCE_EXPR_EDITOR_LABEL = "序列："

CLIENTPATH_EDITOR_LABEL = "客户端路径名:"
CLIENTPATH_EXPR_EDITOR_LABEL = "客户端路径或引用:"
ENTRYPOINT_COMBOBOX_LABEL = "入口点："
ENTRYPOINT_EXPR_EDITOR_LABEL = "入口点："

ARGUMENTS_LISTCTRL_LABEL = "参数"
USE_SEQUENCE_PROTOTYPE_LABEL = "使用所选序列的原型"
SEQ_PROTOTYPE_SELECTION_BTN_LABEL = "加载原型..."
USE_DEFAULT_OPTION_LABEL = "使用默认值"
ENTER_EXPR_OPTION_LABEL = "输入表达式"

MULTITHREAD_SETTINGS_BUTTON_LABEL = "设置..."
MODEL_PATH_LABEL = "模型路径："
MODEL_PATH_EXPR_LABEL = "模型路径或引用："

CURRENT_FILE_TEXT = "<当前序列文件>"
USE_CLIENT_MODEL_TEXT = "<使用客户端文件模型>"
ARGUMENTS_LISTCTRL_COLUMNHEADINGS = "名称、类型、日志、默认值、值、传递方式"

SEQUENCE_NOT_FOUND_WARNING_MSG = "文件 '%2' 中不存在指定的序列 '%1'。"
SEQUENCE_NOT_FOUND_WARNING_TITLE = "找不到序列"

SELECT_FILE_DLG_TITLE = "选择序列文件"
SEQUENCE_FILES = "序列文件"
SEQUENCE_FILE_LOWER_CASE = "序列文件"
ALL_FILES = "所有文件"

SEQUENCE_EXPR_ERROR_TEXT = "序列表达式"
SEQFILE_EXPR_ERROR_TEXT = "序列文件表达式"
MODELFILE_EXPR_ERROR_TEXT = "模型文件表达式"
REMOTE_HOST_EXPR_ERROR_TEXT = "远程主机表达式"
TYPE_MASK_EXPR_ERROR_TEXT = "执行类型掩码表达式"
EXEC_REF_EXPR_ERROR_TEXT = "执行引用表达式"
THREAD_REF_EXPR_ERROR_TEXT = "线程引用表达式"
EXEC_BREAK_ON_ENTRY_EXPR_ERROR_TEXT = "输入表达式中断"
CUSTOM_CPU_AFFINITY_EXPR_ERROR_TEXT = "自定义 CPU 关联表达式"

SYNTAX_ERR_ARGUMENT = "参数 '%1' 的参数表达式中存在语法错误：\n\n%2\n\n该值导致运行时错误。"

PARAMETER_MISMATCH_WARNING_TITLE = "参数不匹配"

MORE_ARGUMENTS_THAN_PARAMETERS_MSG Line0001 = "此序列调用中的参数数量 (%1) 超过了序列的参数数量 (%2)。\n"
MORE_ARGUMENTS_THAN_PARAMETERS_MSG Line0002 = "当您单击确定关闭指定模块对话框时，TestStand 会删除额外的参数。"

FEWER_ARGUMENTS_THAN_PARAMETERS_MSG Line0001 = "此序列调用中的参数数量 (%1) 少于序列的参数数量 (%2)。\n"
FEWER_ARGUMENTS_THAN_PARAMETERS_MSG Line0002 = "TestStand 显示附加参数并在您单击确定退出指定模块对话框时保存它们。"

NO_PARAMETERS_MSG Line0001 = "此序列调用有 %1 个参数，但不存在有效原型。\n"
NO_PARAMETERS_MSG Line0002 = "当您单击确定退出指定模块对话框时，TestStand 将删除参数。"

PARAMETERS_CHANGED_MSG Line0001 = "这个序列调用的参数已经更新以匹配序列的参数。\n"
PARAMETERS_CHANGED_MSG Line0002 = "当您单击确定退出指定模块对话框时，TestStand 应用这些更改。"

PASS_UNKNOWN = "未知通过"
PARAM_NAME_UNKNOWN = "<未使用>"
PARAM_TYPE_UNKNOWN = "<参数类型未知>"

USE_DEFAULT = "<使用默认值>"
PASS_BYVALUE = "按值"
PASS_BYREFERENCE = "通过引用"

STEP_DESC_REMOTE_HOST = "在服务器上：%1"
STEP_DESC_CURRENT_FILE = "<当前文件>"
STEP_DESC_DEFAULT_ARG = " 步骤下降默认"
STEP_DESC_UNSPECIFIED_ARG = "?"
STEP_DESC_UNSPECIFIED_REMOTE_HOST = "?"
ADAPTER_SPECIFIC_STEP_DESCRIPTION = "在 %2 中调用 %1"
ADAPTER_SPECIFIC_STEP_DESCRIPTION_FOR_REMOTE = "在 %2 %4 中调用 %1"
ADAPTER_SPECIFIC_STEP_DESCRIPTION_WITH_PARAMS = "在 %2 中调用 %1(%3)"
ADAPTER_SPECIFIC_STEP_DESCRIPTION_FOR_REMOTE_WITH_PARAMS = "在 %2%4 中调用 %1(%3)"

MULTITHREAD_NONE = "无"
MULTITHREAD_NEW_THREAD = "在新线程中运行序列"
MULTITHREAD_NEW_LOCAL_EXECUTION = "在新执行中运行序列"
MULTITHREAD_NEW_REMOTE_EXECUTION = "在远程计算机上运行序列"

THREAD_SETTINGS_DLG_TITLE = "话题设置"
THREAD_INITIALLY_SUSPENDED_LABEL = "最初暂停"
THREAD_WAIT_DESC = "如果您想从异步调用中获取结果、状态和错误信息，请禁用此选项并在您的序列中插入一个等待步骤。"
THREAD_USE_SINGLE_THREADED_APARTMENT_LABEL = "使用单线程单元(&U)"
THREAD_INITIALLY_SUSPENDED_DESC Line0001 = "要恢复线程，请在线程引用上调用 Thread.Resume 方法。"
THREAD_INITIALLY_SUSPENDED_DESC Line0002 = "您可以使用 ActiveX/COM 步骤从一个序列中调用 Thread.Resume。"
MULTITHREAD_AUTO_WAIT_LABEL = "自动等待线程在当前序列结束时完成"
MULTITHREAD_STORE_THREAD_REF_EXPR_LABEL = "将对新线程的对象引用存储在（可选）中："

LOCAL_EXECUTION_SETTINGS_DLG_TITLE = "执行设置"
EXEC_INIT_SUSPENDED_LABEL = "最初暂停"
EXEC_HIDDEN_LABEL = "最初隐藏并禁用跟踪"
EXEC_RESTARTABLE_LABEL = "重启工作台"
EXEC_CLOSE_WHEN_DONE_LABEL = "完成后关闭窗口"
EXEC_USE_SINGLE_THREADED_APARTMENT_LABEL = "使用单线程单元"
EXEC_TYPE_MASK_LABEL = "&附加执行类型掩码设置（可选）："
EXEC_STORE_EXPR_LABEL = "在（可选）中存储对新执行的对象引用:"
EXEC_BREAK_ON_ENTRY_LABEL = "进入"

EXEC_PROCESS_MODEL_OPTION_LABEL = "进程模型选项："
EXEC_MODEL_OPTION_NONE = "不使用进程模型"
EXEC_MODEL_OPTION_DEFAULT = "使用指定客户端文件的进程模型"
EXEC_MODEL_OPTION_SPECIFIC = "使用特定的进程模型"

EXEC_WAIT_DESC = "如果您想从异步执行调用中获取结果、状态和错误信息，请选择不等待此选项并在序列中插入等待步骤。"
WAIT_OPTION_LABEL = "等待执行完成："
WAIT_OPTION_NONE = "不要等待"
WAIT_OPTION_BEFORE_NEXT_STEP = "在执行下一步之前"
WAIT_OPTION_END_OF_SEQUENCE = "在当前序列的末尾"

REMOTE_EXECUTION_SETTINGS_DLG_TITLE = "远程执行设置"
REMOTE_EXECUTION= "远程执行"
SPECIFY_BYEXPR_HOST_BTN_LABEL= "为主机指定表达式&x"
REMOTE_HOST= "远程主机:"
REMOTE_HOST_EXPR= "远程主机表达式："
REMOTE_HOST_NOTE= "对于远程序列调用，序列文件路径名是相对于远程主机的。要从 32 位 TestStand 远程调用 64 位 TestStand，反之亦然，请在远程主机名前加上 64\\\\ 或32\\\\"

ADP_CFG_DLG_CAPTION = "序列适配器配置"
ADP_CFG_SHOW_ACTIVEX_CONTROLS_CHECK_LABEL = "显示 Active&X 控件"
ADP_CFG_SHOW_PARAMETERS_CHECK_LABEL = "在步骤描述中显示参数"

CPU_AFFINITY_FOR_NEW_THREAD = "新线程的 CPU 亲和力："
CPU_AFFINITY_FOR_NEW_EXECUTION = "初始执行线程的 CPU 关联："
USE_STATION_OPTION = "为 CPU 关联使用站选项"
USE_CALLER_AFFINITY = "使用调用者的 CPU 亲和力"
USE_ALL_CPUS = "使用所有 CPU"
USE_CUSTOM = "使用自定义 CPU 亲和力"

REMOTE_ENVIRONMENT = "远程主机：%1"

;; FlexG 适配器

[FLEXG_ADAPTER]
G_ADP_MSG_TITLE = "LabVIEW 适配器消息"
FORCE_EXACT_MATCH_WILL_DELETE_VALUES="强制完全匹配将覆盖对话框中的当前值。您确定要继续吗？"
VI_FULLNAME = "VI 名称：%1"
BROWSE_INTO_LLB_WARNING = "警告：您必须启动 LabVIEW 才能浏览 *.llb 文件。"
BROWSE_INTO_LVLIBP_WARNING = "警告：您必须启动 LabVIEW 才能浏览 *.lvlibp 文件。"
CANNOT_BROWSE_INTO_LVLIBP_FILE = "TestStand 无法浏览到 LabVIEW 打包项目库文件。确保该文件是有效的 .lvlibp 文件。您必须使用 LabVIEW 2010 或更高版本才能浏览到 LabVIEW 打包项目库文件。"
CANNOT_CREATE_VI_IN_LVLIBP_FILE = "TestStand 无法创建 VI。LabVIEW 打包的项目库文件是只读的。TestStand 无法将 VI 添加到打包的项目库文件中。"
LV_SERVER_IS_NOT_EDITOR Line0001 = "LabVIEW 适配器当前配置为在执行测试的环境中运行测试\n"
LV_SERVER_IS_NOT_EDITOR Line0002 = "不支持编辑 VI 或 LabVIEW 项目。要编辑或创建 VI 或 LabVIEW 项目，\n"
LV_SERVER_IS_NOT_EDITOR Line0003 = "您必须在 LabVIEW 适配器配置对话框中选择不同的 LabVIEW ActiveX 服务器。"
RTE_FOR_LV_PROJECT_NOT_INSTALLED = "未安装支持 LabVIEW 项目 '%1' 的 LabVIEW 运行时引擎版本。"
LV_LOST_CONNECT = "失去与 LabVIEW 服务器的 ActiveX 连接。LabVIEW 适配器将尝试在下一次执行尝试时重新连接。"
LV_LOST_REMOTE_CONNECTION Line0001 = "无法执行远程 VI。\n\nVI 或其组件之一可能不在内存中。确认远程计算机包含所有必需的 VI。"
LV_LOST_REMOTE_CONNECTION Line0002 = "\n\n与远程主机 '%1' 的连接可能已经丢失。您必须在重新开始执行之前卸载所有模块。"
CFG_GSERVER_WILL_UNLOAD_MODULES_WARNING = "如果您更改要使用的 LabVIEW ActiveX 或运行时服务器，TestStand 必须卸载所有模块。"
LOAD_ERR_VI_WITH_NAME_ALREADY_LOADED Line0001 = "无法加载 VI '%1'。LabVIEW 已经加载了 VI '%2'，无法加载不同的"
" LOAD_ERR_VI_WITH_NAME_ALREADY_LOADED Line0002 = "具有相同名称的 VI。您可以通过重命名 VI 或将 VI 添加到 LabVIEW 项目库来解决此问题。
LOAD_ERR_LVCLASS_WITH_NAME_ALREADY_LOADED Line0001 = "无法加载 LabVIEW 类 '%1'。LabVIEW 已经加载了 LabVIEW 类 '%2'，无法加载不同的类"
LOAD_ERR_LVCLASS_WITH_NAME_ALREADY_LOADED Line0002 = "具有相同名称的类。"
VI_WITH_NAME_ALREADY_LOADED Line0001 = "无法创建 VI '%1'。LabVIEW 内存中已有同名的 VI。"
VI_WITH_NAME_ALREADY_LOADED Line0002 = "您必须先从 LabVIEW 卸载 VI，然后才能创建同名的新 VI。"
PRELOAD_TIMEOUT_EXTERNAL_LV = "LabVIEW 正在执行另一个步骤，无法预加载 '%1'。"
FAILED_TO_READ_VI_PROTOTYPE Line0001 = "LabVIEW 在尝试读取 VI'%1' 的原型时报告错误。\n当您将包含太多元素的簇连接到连线板时，可能会发生此错误。\n"
FAILED_TO_READ_VI_PROTOTYPE Line0002 = "减少集群元素的数量并重新加载原型。"
FAILED_TO_LOAD_LABVIEW_PACKED_PROJECT_LIBRARY = "LabVIEW 在尝试加载 LabVIEW 打包项目库时报告错误\n'%1'\n"
FAILED_TO_LOAD_LABVIEW_CLASS_LIBRARY = "LabVIEW 在尝试加载 LabVIEW 类库时报告错误\n'%1'\n"
FAILED_TO_SET_NUM_OF_THREADS_OR_THREAD_AFFINITY = "LabVIEW 运行时引擎在尝试设置执行 VI 的线程数或附加 LabVIEW 线程的 CPU 线程关联时报告错误。"
FAILED_TO_ACCESS_CLASS_MEMBER = "TestStand 无法访问 LabVIEW 类成员：\n'%1'\n确保它具有公共范围并且属于所选类。"
FAILED_TO_GET_MEMBERS_OF_LABVIEW_CLASS = "TestStand 无法获取 LabVIEW 类成员：\n'%1'"
INVALID_LABVIEW_CLASS_MEMBER_SCOPE = "TestStand 无法访问 LabVIEW 类成员：\n'%1'\nTestStand 只能访问公共 LabVIEW 类成员。"
FAILED_TO_ACCESS_LABVIEW_CLASS = "TestStand 无法访问 LabVIEW 类：\n'%1'。"
ERROR_EXPECTED_PATH_DATA_TYPE = "预期路径数组，找到容器数组。"
LV_HELP_WEB = "[<WEB_URL>]"

ERR_COMMUNICATING_WITH_LV Line0001 = "尝试访问 LabVIEW 开发系统时发生错误。在 LabVIEW 中验证以下 VI 服务器设置（工具->选项：VI 服务器：配置）：\n"
ERR_COMMUNICATING_WITH_LV Line0002 = "在协议部分，启用 ActiveX。\n在可访问服务器资源中，启用 VI 属性和方法以及应用程序方法和属性选项。\n"
ERR_COMMUNICATING_WITH_LV Line0003 = "确保 VI 服务器授予对导出 VI 列表中所有 VI 的访问权限。"
UNABLE_TO_LOAD_VI_IN_LVPACKED_LIBRARY = "无法加载 VI。如果 VI 在 LabVIEW 打包项目库中，则 LabVIEW 已经加载了打包项目库。\nLabVIEW 无法从不同目录加载具有相同名称的不同打包项目库。"
TYPE_MISMATCH = "发生类型不匹配错误。传递给 VI 的参数之一的数据类型与 LabVIEW 预期的数据类型不匹配。联系 National Instruments 以获得更多支持。"

MODULE_NOT_PART_OF_STEP = "无法加载原型，因为模块不是步骤的一部分。"

MINIMUM_SUPPORTED_32BIT_LVVERSION = "2017 SP1"
MINIMUM_SUPPORTED_64BIT_LVVERSION = "2017 SP1"
LVVERSION_YEAR_BASED_AND_NUMERIC = "%1 (%2)"
LVVERSION_BITNESS_32 = "32 位"
LVVERSION_BITNESS_64 = "64 位"
LVRT_DLL_VERSION_NOT_INSTALLED = "TestStand 找不到版本 '%1' 和位数 '%2' 的 LabVIEW 运行时引擎。"
LVRT_DLL_VERSION_NOT_INSTALLED_REQUIRED_FOR_LV_PACKED_PROJECT_LIBRARY = "LabVIEW 打包项目库 '%1' 需要 LabVIEW 运行时引擎 '%2'。TestStand 无法访问该版本。它可能未安装。"
LVRT_DLL_VERSION_NOT_INSTALLED_REQUIRED_FOR_ERROR_CODE = "\n\n错误解释可能不准确，因为 %2 LabVIEW 运行时 %1 未找到。"
LVRT_DLL_VERSION_IS_EMPTY = "LabVIEW 版本为空。"
LVRT_DLLS_NOT_FOUND = "TestStand 无法定位 LabVIEW 运行时引擎。确保计算机上至少安装了一个版本为 %1 或更高版本的 %2 LabVIEW 运行时引擎。"
LVRT_DLL_NOT_XX_OR_GREATER = "无法加载 LabVIEW 运行时引擎版本 '%1'。TestStand 仅支持 LabVIEW %2 或更高版本。"
LVRT_DLL_IS_REQUIRED = "远程调用需要 LabVIEW 运行时引擎。TestStand 无法在此计算机上找到或加载运行时引擎的兼容版本。"
LVRT_DLL_IS_REQUIRED_FOR_BCRTE = "LabVIEW 的版本独立运行时功能要求至少安装 17.0 (2017) 或更高版本的 LabVIEW 运行时引擎。TestStand 无法在此计算机上找到或加载运行时引擎的兼容版本。"
NEED_LV_VERSION_XX_OR_GREATER = "TestStand %3 需要 LabVIEW %2 或更高版本。\nLabVIEW %1 当前处于活动状态。\nTestStand 无法连接到 LabVIEW。"
NEED_PROJECT_AND_VI_VERSION_TO_BE_THE_SAME = "LabVIEW 项目（'%1'）和 VI（'%2'）的 LabVIEW 运行时引擎版本必须匹配，TestStand 才能执行 VI。"
NEED_LV_PROJECT_VERSION_90_OR_GREATER = "TestStand 要求 LabVIEW 项目使用 LabVIEW 2009 或更高版本。\nLabVIEW 项目的版本为 '%1'。"
REPAIR_LABVIEW_ADAPTER_SUPPORT_DIR = "TestStand 在 <TestStand Public>\\AdapterSupport\\LabVIEW 目录中的文件之一遇到问题。\n 重新安装或修复 TestStand。"
LABVIEW_ADAPTER_SUPPORT_DIR_ERROR = "加载 VI '%1' 失败，出现以下错误：\n"
LOAD_ERR_LABVIEW_PROJECT = "无法加载 LabVIEW 项目 '%1'。"
LOAD_ERR_LABVIEW_PROJECT_REMOTELY = "无法远程加载 LabVIEW 项目 '%1'。"
UNLOAD_ERR_LABVIEW_PROJECT = "无法卸载 LabVIEW 项目 '%1'。"
UNLOAD_ERR_LABVIEW_PROJECT_REMOTELY = "无法远程卸载 LabVIEW 项目 '%1'。"
NEED_LVRTE_VERSION_1200_OR_GREATER_FOR_LVCLASSES = "TestStand 需要 LabVIEW RTE 版本 12.0 (2012) 或更高版本来配置和执行 LabVIEW 类成员 VI。\nTestStand 正在尝试使用由当前选定的 LabVIEW RTE 定义的版本 '%1'。"
NEED_LV_VERSION_1200_OR_GREATER_FOR_LVCLASSES = "TestStand 需要 LabVIEW开发系统版本 12.0 (2012) 或更高版本来配置和执行 LabVIEW 类成员 VI。\nTestStand 正在尝试使用由当前选定的 LabVIEW 开发系统定义的版本 '%1'。"
PROPERTY_NODES_NOT_SUPPORTED_WITH_RTE = "TestStand 不支持使用 LabVIEW 运行时引擎配置属性节点调用。"
UNABLE_TO_EDIT_PROPERTY_NODE_CALL = "无法在 LabVIEW 中编辑配置为调用 LabVIEW 属性节点的步骤。使用指定模块对话框进行更改。"
NEED_LV_VERSION_1300_OR_GREATER_FOR_LVPROPERTYNODES = "TestStand 当前配置为使用 LabVIEW 开发系统版本 '%1'。\nTestStand 需要 LabVIEW 开发系统版本 13.0 (2013) 或更高版本来配置属性节点调用。"

CANNOT_BROWSE_INTO_LLB_FILE = "TestStand 无法找到浏览 .llb 文件所需的指定 LabVIEW 运行时引擎。\n安装指定的 LabVIEW 运行时引擎或编译文件\n<TestStand Public>\\AdapterSupport\\LabVIEW\\TestStandListDir .llb 为与计算机上安装的\nLabVIEW Run-Time Engine 版本之一相同的版本。"

REMOTE_EXE_NOT_SUPPORTED Line0001 = "当 TestStand 在 LabVIEW 开发系统中运行且 VI 版本与 LabVIEW 版本不匹配时，不支持将 VI 下载到远程主机。\n"
REMOTE_EXE_NOT_SUPPORTED Line0002 = "VI '%1' 的版本为 '%2'。\nLabVIEW 开发系统的版本为 '%3'。"

RTE_NOT_LOADED_ENGINE_SHUTTING_DOWN = "无法加载 LabVIEW 运行时引擎，因为 TestStand 引擎正在关闭。"

REMOTE_EXE_SUPPORT_NOT_INSTALLED = "未安装对远程执行 VI 的支持。"
REMOTE_EXE_UPDATE_SUPPORT_VIS = "远程调用中使用的支持 VI '%1' 不是最新版本。\n将 .llb 文件更新为最新的 LabVIEW 版本。\n\n"

UPDATE_ADAPTER_SUPPORT_VIS = "支持 VI '%1' 可能不是最新版本。\n将 .llb 文件更新为最新的 LabVIEW 版本。\n\n"
CREATE_NEW_SUPPORT_VIS = "支持 VI '%1' 不存在。要创建它，请将现有 '%2' 文件重命名为 '%3' 并使用 LabVIEW 版本 '%4' 进行批量编译。"

VI_VERSION_IS_NEWER = "TestStand 无法加载 VI。\nVI 的版本可能晚于 '%1'。"
CHECK_IF_70_OR_GREATER_INSTALLED Line0001 = "TestStand 无法加载 VI。\n\n出现此错误的原因可能是当前活动的 LabVIEW\n版本 '%1' 无法加载选定的 VI，\n该 VI 可能已保存在更高版本的 LabVIEW 中。"
CHECK_IF_70_OR_GREATER_INSTALLED Line0002 = "使用 LabVIEW 适配器配置对话框选择 LabVIEW 运行时引擎\n版本以用于加载 VI。"

COPY_TESTSTAND_LV_API_FAILED = "TestStand 无法将最新版本的 '%1' 安装到此计算机上已注册的 LabVIEW 安装中。"
CFG_GSERVER_SELECTED_NON_EDITOR_SERVER Line0001 = "您选择了 LabVIEW 运行时引擎服务器而不是 LabVIEW 开发系统服务器。"
CFG_GSERVER_SELECTED_NON_EDITOR_SERVER Line0002 = "您必须确保 LabVIEW 运行时引擎服务器可以加载 TestStand 加载的 LabVIEW 测试 VI 的整个层次结构。"
CFG_GSERVER_VERSION_MISMATCH_ACTIVE_VS_CONNECTED = "TestStand 无法连接到活动的 LabVIEW 版本 %1。请退出所有其他正在运行的 LabVIEW 版本以确保 TestStand 可以连接到活动的 LabVIEW 开发系统。"

VI_TYPE_NOT_SUPPORTED = "TestStand 不支持您选择的 VI 类型。\nTestStand 仅支持 Express、多态和标准 VI 类型。"

MUST_HAVE_VI_EXT = "模块路径中的文件名必须使用 .vi 扩展名，以便 TestStand 创建 VI。如果指定 .llb 文件，则必须在其后指定 VI 文件名。"
MUST_HAVE_LVPRJ_EXT = "项目路径中的文件名必须使用 .lvproj 扩展名，以便 TestStand 创建 LabVIEW 项目。"
CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'。"
UNABLE_TO_CREATE_VI_PATH_NOT_ABS = "无法创建 VI。\n您必须指定绝对路径才能创建 VI。"
ERR_EVALUATING_UUT_ITER_EXPR = "无法评估 LabVIEW 适配器 UUT 迭代表达式。"
ERR_EVALUATING_UUT_SERIAL_NUM_EXPR = "无法评估 LabVIEW 适配器 UUT 序列号字符串表达式。"
UNABLE_TO_EDIT_LV_PRJ_NOT_FOUND = "无法找到此步骤的 LabVIEW 项目文件。确保 LabVIEW 项目文件存在于磁盘上。"
UNABLE_TO_EDIT_LV_CLASS_NOT_FOUND = "无法找到此步骤的 LabVIEW 类文件。确保 LabVIEW 类文件存在于磁盘上。"
INVALID_PROJECT_PATH = "项目路径无效。"
INVALID_PATH = "VI 路径无效。"
UNABLE_TO_LOAD_LV_PRJ = "无法加载 LabVIEW 项目。LabVIEW 项目或其依赖项之一可能丢失。\n\n'%1'\n\n'%2'"
UNABLE_TO_EDIT_LV_PRJ = "TestStand 无法编辑以下 LabVIEW 项目：\n\n'%1'\n\n加载时。您必须卸载所有模块才能在 TestStand 中编辑 LabVIEW 项目。"
EXPRESS_VI_NOT_SUPPORTED_WITH_LVPRJS = "TestStand 不支持使用 LabVIEW 项目调用或配置 Express VI。"
REMOTE_CALLS_NOT_SUPPORTED_WITH_LVPRJS= "TestStand 不支持远程调用 LabVIEW 项目。"
UNABLE_TO_LOAD_LV_PRJ_WITH_CONFLICTS = "LabVIEW 项目有冲突：\n\n'%1'\n\n以下项目有您必须在 LabVIEW 中解决的冲突：\n\n%2"
UNABLE_TO_REFRESH_LV_PRJ = "当 TestStand 加载项目时，您不能更新 LabVIEW 项目。您必须卸载所有模块。"
" REMOTE_CALLS_NOT_SUPPORTED_WITH_LVPRJS_AND_CLASSES= "远程 LabVIEW 服务器可能不支持具有配置为使用 LabVIEW 项目的 LabVIEW 类数据类型参数的远程 VI 调用。
REMOTE_CALLS_WITH_CLASSES_NEED_TO_PRELOAD_MODULE_IN_RTE = "为使带有 LabVIEW 类数据类型参数的远程 VI 调用正常工作，您必须在与 VI 版本匹配的 LabVIEW 运行时引擎中的本地计算机上预加载 LabVIEW 类定义。"
LABVIEW_ABORTED_VI_IN_PACKED_PROJECT_LIBRARY = "VI 中止的一个原因可能是因为当 VI 调用配置为显示前面板的子 VI 时，LabVIEW 中止了来自没有调试符号的 LabVIEW 打包项目库的正在执行的 VI。"
UNABLE_TO_GET_PROJECT_FROM_PROJECT_CACHE = "无法从 LabVIEW 项目缓存中获取 LabVIEW 项目。"
DYNAMIC_DISPATCH_NOT_ALLOWED_IN_NORMAL_VI_CALLS = "不允许使用 VI 调用调用需要动态调度才能正常工作的 VI。更改步骤配置以改为使用类成员调用。\n\n"

HIDDEN_STRUCT_MEMBER_SUFFIX = "（隐藏）"
UNABLE_TO_EDIT_SRC_SRC_NOT_FOUND = "无法找到此步骤的源文件。确保模块源文件存在于磁盘上。"
MUST_HAVE_LVCLASS_EXT = "LabVIEW 类路径中的文件名必须使用 .lvclass 扩展名，以便 TestStand 编辑 LabVIEW 类。"

LABVIEW_DEV_SYSTEM = "LabVIEW 开发系统"
UNABLE_TO_LOAD_BROKEN_VI = "无法使用 LabVIEW 运行时引擎版本 %2 (%3) 加载 VI '%1'。\n子 VI 的版本可能与运行时引擎的版本不匹配，版本独立运行时功能是已禁用或可能缺少 VI 依赖项。\n要解决此问题，请批量编译代码模块 VI 或在当前计算机上尝试以下步骤：\n\n"
UNABLE_TO_LOAD_BROKEN_VI_DETAILED_ERROR = "无法使用 LabVIEW 运行时引擎版本 %2 (%3) 加载 VI '%1'。\n"
UNABLE_TO_LOAD_BROKEN_VI_PREAMBLE = "要解决此问题，请批量编译您的代码模块 VI 或在当前机器上尝试以下步骤：\n\n"
UNABLE_TO_LOAD_BROKEN_VI_DEFAULT_VI = " 1. 在 LabVIEW 开发系统中打开 '%1'。如果 VI 损坏，请修复 VI 中的任何错误。\n 2. 通过在按住 'Ctrl' 键的同时单击运行箭头来强制编译 VI。 \n 3. 在 LabVIEW 中，选择 File >> Save All 确保所有子 VI 都保存在同一个 LabVIEW 版本中。
UNABLE_TO_LOAD_BROKEN_VI_DEFAULT_VI_BCRTE = " 1. 在 LabVIEW 开发系统中打开 '%1'。如果 VI 损坏，修复 VI 中的任何错误。\n 2. 通过在按住 'Ctrl' 键的同时单击运行箭头强制编译 VI。 \n 在使用版本独立运行时功能时，请参阅此处的帮助以获取有关执行 VI 的更多信息。"
RUN_TIME_CANNOT_LOAD_VI_EXPRESS_OR_PROPNODE_INFO = "- 配置 LabVIEW 适配器以使用 LabVIEW 开发系统，然后从 TestStand 工具菜单运行'更新 VI 调用'。"
UNABLE_TO_LOAD_BROKEN_VI_EDIT_IN_LV = "\n\n您想在 LabVIEW 中编辑 VI 吗？"
UNABLE_TO_LOAD_BROKEN_VI_TITLE = "无法使用运行时引擎加载 VI"
UNABLE_TO_LOAD_VI_TITLE = "无法加载 VI"
UNABLE_TO_LOAD_VI_INTERNAL_ERROR = "尝试加载 VI 时发生内部错误。"
RUN_TIME_CANNOT_LOAD_VI = "无法使用 LabVIEW 运行时引擎版本 '%2' 加载 VI '%1'，因为 VI 版本为 '%3'。\n要加载 VI，运行时引擎的版本和版本VI 的必须匹配。\n"
AVOID_VI_VERSION_NOT_MATCHING_RTE = "为避免此错误，要么：\n1) 批量编译 VI\n2) 确保计算机上存在与 VI 版本匹配的 LabVIEW 运行时引擎版本。\n\n同时修改 LabVIEW 适配器以使用使用运行时引擎时设置"%1"，\n您可以修改 LabVIEW 步骤的高级设置"%2"。
UNABLE_TO_GET_DEFAULT_VALUE_FOR_VI = "无法使用 LabVIEW 运行时引擎版本 '%2' 获取 VI '%1' 的默认值。VI 版本为 '%3'。VI 版本必须与 LabVIEW 运行时引擎版本相匹配。 "
PPL_IS_STALE = "指定的打包项目库不包含对 VI 所做的更改。"
PPL_PROJECT_MATCHES_SOURCE_PROJECT = "在打包项目库中调用 VI 时使用的项目不能与构建库的项目相同。"
CLICK_TO_BUILD_PPL = "\n单击此处构建打包项目库。"
PPL_BUILD_FAILED = "无法构建打包的项目库。\n详细信息：\n %1"
PPL_BUILD_FAILED_TAG = "无法构建打包的项目库。\n详细信息：\n"

FAIL_TO_LOAD_VI_RTE = "无法在 LabVIEW 运行时引擎版本 '%2' 中加载 VI '%1'。"
VI_VERSION_DOES_NOT_MATCH_RTE = "LabVIEW 运行时引擎无法加载 VI，因为 VI 版本为 '%1'。"
FAIL_TO_LOAD_VI_IN_DEV = "无法在 '%2' 版本 '%3' 中加载 VI '%1'。"
VI_VERSION_GREATER_THAN_DEV = "'%1' 无法加载 VI，因为 VI 版本为 '%2'，高于 '%3'。"
VI_EMBEDDED_IN_STEP = "属性节点步骤"

VI_IS_BROKEN = "无法在 '%2' 中加载 VI '%1'，因为 VI 已损坏。\n\n可能缺少 VI 相关性。"
EDIT_IN_LV = "\n\n您想在 LabVIEW 中编辑 VI 吗？"
VI_IS_BROKEN_TITLE = "损坏的 VI"
VI_MISSING_DEPENDENCIES_TITLE = "\n\n缺少以下依赖项：\n\n"
VI_MISSING_DEPENDENCIES_COMPONENT = "缺少的子 VI 是 %1 %2 的一部分\n\n"
VI_MISSING_DEPENDENCIES_ADDITIONAL = "还有其他缺失的依赖项。在 LabVIEW 中打开 VI 以获得完整列表。\n"
VI_HAS_CHANGED Line0001 = "VI '%1' 已更改。\nVI 或子 VI 的版本可能已更改。\nNational Instruments "
VI_HAS_CHANGED Line0002 = "建议您在 LabVIEW 中打开并保存 VI。\n\n您想在 LabVIEW 中编辑 VI 吗？"
VI_HAS_CHANGED_TITLE = "VI 已更改"
FAILED_TO_EDIT_VI = "LabVIEW 无法打开 VI 进行编辑。"
FAILED_TO_LOAD_REMOTE_VI Line0001 = "无法在远程主机 '%1' 上加载 VI。\n%2"
FAILED_TO_LOAD_REMOTE_VI Line0002 = "\n\n如果远程计算机正在运行 LabVIEW 实时模块，则本地 LabVIEW 运行时引擎版本必须与远程计算机上的 LabVIEW 实时模块版本相匹配。"
VI_RT_VERSION_MISMATCH = "版本不匹配：VI 版本 '%1'，LabVIEW 实时模块版本 '%2'。"

CANNOT_DOWNLOAD_VI Line0001= "\n无法将 VI 下载到远程系统，因为它未运行 LabVIEW Real-Time。\nLabVIEW 仅支持自动下载到运行 LabVIEW Real-Time 的系统。但是，\n您可以在运行之前手动下载 VI。 "
CANNOT_DOWNLOAD_VI Line0002= "或者，您可以在远程系统上运行第 3 方\nFTP 服务器，并使用 TestStand FTP 文件步骤类型在运行时下载您的\nVI。如果您正在调用 Express VI，您可以创建一个包装器通过在指定模块对话框中将 VI 类型从 Express VI 更改为 Standard VI 来下载\nVI。"

CANNOT_CREATE_GENERIC_TARGET = "\n无法创建通用目标。确保您安装了带有 LabVIEW 运行时引擎的\"NI TestStand 的远程执行支持\"。\n"
CANNOT_CONNECT_TO_REMOTE_SYSTEM Line0001 = "\n无法连接到远程计算机'%1'。\n连接可能由于以下原因之一而失败：\n1. 计算机不在网络中。\n"
CANNOT_CONNECT_TO_REMOTE_SYSTEM Line0002 = "2. LabVIEW 项目已连接。\n3. 远程计算机可能未运行 LabVIEW 实时模块。\n4. 远程 VI 版本与远程计算机上运行的 LabVIEW 版本不匹配。"
CANNOT_DOWNLOAD_TO_REMOTE_SYSTEM = "\n无法将 VI 下载到远程系统 '%1'。\nVI 可能损坏或被修改。"
ERR_DUPLICATE_VI = "另一个具有相同名称但不同路径的 VI 已经加载到远程系统中。要解决此问题，请重命名其中一个 VI。"
REMOTE_SYSTEM_CANNOT_RUN_VI = "远程系统未运行 LabVIEW Real-Time 或 LabVIEW 开发系统。"

VIS_ARE_READ_ONLY = "以下 VI 已修改且只读。下载前需要保存它们。"
NEED_TO_SPECIFY_FULLPATH = "在远程系统上调用 VI 时需要指定远程 VI 的完整路径。"

ARRAY_DIMENSIONS_ERROR = "数组参数 '%2' 需要 '%1' 维度，但收到 '%3' 维度。"
INVALID_DISPATCH_POINTER_ADDR = "表达式 '%1' 包含无效的 LabVIEW 引用。"
KEEP_PARAM_VALS = "你想保留当前参数值吗？"
KEEP_PARAM_VALS_TITLE = "保留参数值？"
NEED_TO_UPDATE_VI_PROTOTYPE = "VI 原型已更改。\n参数信息将更新以反映新原型。"
VI_PROTOTYPE_CHANGED = "VI '%1' 的原型已更改。\n您必须在执行 VI 之前更新原型。\n使用 TestStand 序列编辑器更新原型。"
UNABLE_TO_CREATE_XML_PARSER = "无法创建 XML 解析器。\n无法解析 VI 原型。"
CHECKSUM_DOES_NOT_MATCH = "名称为 '%1' 的 VI 已加载到主机 '%2' 中，并且与此步骤尝试加载的 VI 不同。"
UNEXPECTED_VI_NAMESPACE = "VI '%1' 的命名空间与您最初选择的 VI 的命名空间不同。\n预期的命名空间：'%2'。\n找到的命名空间：'%3'。\n单击错误提供程序或运行更新 VI 调用工具以重新加载 VI 原型。"
UNEXPECTED_VI_NAMESPACE_REGEX = "VI '.*' 的命名空间？与您最初选择的 VI 的命名空间不同"
NO_NAMESPACE_SPECIFIED = "<未指定命名空间>"

RTE_NOT_INSTALLED_FOR_PROJ_LIBRARY_DEPLOYMENT = "TestStand 未能在指定的项目库中部署共享变量。确保安装了 LabVIEW 运行时引擎版本 '%1'。"
RTE_NOT_INSTALLED_FOR_PROJ_LIBRARY_UNDEPLOYMENT = "TestStand 未能CANCEL部署指定项目库中的共享变量。确保已安装 LabVIEW 运行时引擎版本 '%1'。"
CANNOT_DEPLOY_PROJ_LIBRARY = "TestStand 未能在指定的项目库中部署共享变量。确保项目库仅定义共享变量，不包含任何 VI。另外，确保主机存在并且在网络中。"
CANNOT_UNDEPLOY_PROJ_LIBRARY = "TestStand 无法CANCEL部署指定项目库中的共享变量。确保项目库只定义共享变量，不包含任何 VI。另外，确保主机存在并且在网络中。"
CANNOT_DEPLOY_PROJ_LIBRARY_FROM_LVPROJECT = "TestStand 无法在指定的 LabVIEW 项目中自动部署项目库中的共享变量。确保项目库只定义共享变量，不包含任何 VI。另外，确保主机存在并且在网络中。"
CANNOT_UNDEPLOY_PROJ_LIBRARY_FROM_LVPROJECT = "TestStand 未能自动CANCEL部署指定 LabVIEW 项目中项目库中的共享变量。确保项目库仅定义共享变量，不包含任何 VI。另外，确保主机存在并在网络中。"
CANNOT_DEPLOY_PROJ_LIBRARY_INSIDE_LLB = "TestStand 无法从 LLB 内部的项目库中部署共享变量。保存所有包含 LLB 外部共享变量的库。"
DEPLOYMENT_OPERATION_TIMED_OUT = "TestStand 未能完成对指定项目库中共享变量的请求操作。操作超时。"
TIMESTAMP_FORMAT_INVALID = "指定的时间戳值没有预期的格式：mm/dd/yyyy hh:mm:ss.sss AM/PM"
RUNNING_VI_NOT_FOUND = "VI '%1' 当前未运行。"
NOT_A_PATH = "<不是路径>"
INVALID_FILE_TYPE_INPUT_TO_CACHE = "输入的文件类型无效。预期的文件类型扩展名是'%1'，但找到的输入路径是'%2'。"

PARAMETER = "参数 '%1':\n%2"
WRAPPER_VI_MOD="包装 VI 已修改。重新配置 VI 会覆盖更改。"
SPEC_MOD_DLG_CAPTION = "编辑 LabVIEW VI 调用"
SPEC_MOD_DLG_SHOW_FRONTPNL_TXT = "调用时显示 VI 前面板(&F)"
SPEC_MOD_DLG_ADVANCED_BTN = "高级..."
SPEC_MOD_DLG_EDIT_DECO_LABEL = "路径和执行"
SPEC_MOD_DLG_PARAM_CONPANE_LABEL = "描述和连线板"
SPEC_MOD_DLG_CREATE_BTN = "创建 VI..."
SPEC_MOD_DLG_EDIT_BTN = "编辑 VI..."
SPEC_MOD_DLG_CONFIGURE_BTN = "配置 VI..."
SPEC_MOD_DLG_REFRESH_VI_BTN = "&重新加载原型"
SPEC_MOD_DLG_RESET_PARAMS_BTN = "&重置参数"
SPEC_MOD_DLG_VI_HELP_BTN = "VI 帮助..."
SPEC_MOD_DLG_PARAM_MAPPING_BTN = "参数映射..."
SPEC_MOD_DLG_VI_DESCRIPTION_LABEL = "VI 描述："
SPEC_MOD_DLG_VI_PARAMETERS_LABEL = "VI 参数："
SPEC_MOD_DLG_NAME_COLUMN = "名称"
SPEC_MOD_DLG_TYPE_COLUMN = "类型"
SPEC_MOD_DLG_INOUT_COLUMN = "输入/输出"
SPEC_MOD_DLG_DEFAULT_COLUMN = "默认"
SPEC_MOD_DLG_LOG_COLUMN = "日志"
SPEC_MOD_DLG_VALUE_COLUMN = "值"
SPEC_MOD_DLG_OR = " or "
SPEC_MOD_DLG_AND = " and "

SPEC_MOD_DLG_NORMAL_VI = "标准 VI"

SPEC_MOD_DLG_NO_VI_DESCRIPTION = "<不存在 VI 描述>"
SPEC_MOD_DLG_VALUE = " [值：%1]"
SPEC_MOD_DLG_UNSPECIFIED_VALUE = "<未指定>"
SPEC_MOD_DLG_USING_CONFIG_VALUE = "<使用配置值>"
SPEC_MOD_DLG_NO_EXPRESS_VI_SEL = "<未选择 Express VI>"
EXPRESS_VI = "Express VI"

OPTIONAL_PARAMS_DLG_CAPTION = "可选参数"
SPEC_MOD_DLG_PARM_GRP_TXT = "可选参数"
SPEC_MOD_DLG_INBUF_TXT = "输入缓冲区"
SPEC_MOD_DLG_INVOC_TXT = "调用信息"
SPEC_MOD_DLG_DISP_TXT = "序列上下文 ActiveX 指针"
SEQ_CONTEXT_REQUIRED_CHECK_TXT = "序列上下文 ActiveX 指针\n（当前选择的代码模板需要。）"

MKDIR_OKCANCEL_QUESTION = "目录 '%1' 不存在。\n你想创建它吗？"

LV_ERR_REP_CALLSITE_TO_BE_READ_DEPENDENCY_MISSING = "CheckVIRefsForMissingDependencies"
LV_ERR_REP_CALLSITE_TO_BE_READ_MISMATCH = "VIToVIBaseLinkRef::CheckInstInstMismatch"
LV_ERR_REP_CALLSITE_READ_MISMATCH = "CheckInstInstMismatch"
LV_ERR_REP_CALLSITE_TO_BE_READ_COMPILE_ERROR = "LVEditor::SetVICompileNeeded"
LV_ERR_REP_CALLSITE_TO_BE_READ_VI_BAD = "VILinkObj::SetSelfErrorsCORE - VI 错误"
LV_ERR_REP_CALLSITE_TO_BE_READ_OUT_OF_SCOPE = "VILinkRefInfo::UpdateScopeInfoToVI"
LV_ERR_REP_CALLSITE_NOT_READ_LOADERROR = "loadError: { mgErr = 1124; loadCode = 1; };"
LV_ERR_REP_CALLSITE_TO_BE_READ_FUNCTION_MISMATCH = "DSToExtFuncLinkRef::PatchOffset（无 extFunc）"
LV_ERR_REP_CALLSITE_NOT_READ_PATCH = "InstInstPatch"
LV_ERR_REP_CALLSITE_NOT_READ_NOTIFY_LINK = "NotifyVIOfChangedLink"
LV_ERR_REP_CALLSITE_NOT_READ_VI_BAD = "设置VIBad"
LV_ERR_REP_CALLSITE_READ_FOR_COMPLIE_BAD = "VI CompiledBad"
LV_ERR_REP_CALLSITE_READ_FOR_MISSING_DEPENDENCY = "依赖缺失"
LV_ERR_REP_CALLSITE_FOR_UNKNOWN_CALLSITE = "未知调用点"
LV_ERR_REP_DATE_FORMAT = "%Y-%m-%dT%H:%M:%S"
LV_ERR_REP_OUTLOG_VI_ERROR = "标题：{ VI 路径：%1 }\n\n\nVI 错误：\n %2\n\n\n原始日志：\n %3\n\n\n"
LV_ERR_REP_OUTLOG_BROKEN_VI_LIST = "\n\n以下 VI 已损坏：\n"
LV_ERR_REP_OUTLOG_HEADER = "标题"
LV_ERR_REP_REPLACE_TAG_RCHAR = "\r"
LV_ERR_REP_REPLACE_TAG_SPACE = " "
LV_ERR_REP_REPLACE_TAG_TAB = "\t"
LV_ERR_REP_OUTLOG_CLOSING_TAG = " }"
LV_ERR_REP_OUTLOG_HEADER_CLOSING_TAG = " }\n\n\n"
LV_ERR_REP_OUTLOG_SPACING = "\n\n\n"
LV_ERR_REP_OUTLOG_SPACING_SINGLELINE = "\n"
LV_ERR_REP_CHAIN_TAB = " 	-"
LV_ERR_REP_OUTLOG_SPACING_DOUBLELINE = "\n\n"
LV_ERR_REP_OUTLOG_RAW_LOG = "原始日志："
LV_ERR_REP_OUTLOG_FILETYPE = ".txt"
LV_ERR_REP_OUTLOG_FILEEXTENSION = "_"
LV_ERR_REP_OUTLOG_END_OF_VI_PATH = "/\\"
LV_ERR_REP_OUTLOG_VI_EXTENSION = ".vi"
LV_ERR_REP_CTL_EXTENSION = ".ctl"
LV_ERR_REP_LOG_OF_LV = "_BrokenVILog_*"
LV_ERR_REP_DETAILED_ERROR_CALLSTACK_STR = "\n 调用堆栈：\n"
LV_ERR_REP_DETAILED_ERROR_CALLING_STR = "\n正在通话\n"
LV_ERR_REP_MISSIN_REFEE_REPLACE_START = "缺少资源：["
LV_ERR_REP_MISSIN_REFEE_REPLACE_END = "; }"
LV_ERR_REP_MISSIN_REFEE_REPLACE_NEXT_LINE = "]; "
LV_ERR_REP_INPUT_LOG_START_BRACES = "{"
LV_ERR_REP_INPUT_LOG_CLOSE_BRACES = "}"
LV_ERR_REP_INPUT_LOG_HEADER_START_BRACES = "标题：{"
LV_ERR_REP_INPUT_LOG_MODE = "模式："
LV_ERR_REP_INPUT_PATH_REGEX = ".*路径*。"
LV_ERR_REP_INPUT_LOG_MODE_REPLACE_STRING = "模式：\""
LV_ERR_REP_INPUT_LOG_ENDTAG_REPLACE_STRING = "\";"
LV_ERR_REP_OUTPUT_REFERRAL_PATH = "\n详细日志存储在\'%1\' "
LV_ERR_REP_OUTPUT_OUT_OF_SCOPE = "在库或类中更新下面提到的 VI 的范围。\n"
LV_ERR_REP_UI_OUT_MESSAGE = "\n加载 VI 时报告多个错误。"
LV_ERR_REP_INPUT_LOG_SECTION_END_COMMENT = "TOP_LEVEL_BROKEN_LOAD_FINISHED"
LV_ERR_REP_INPUT_LOG_COMPLIE_BAD = "compiledWhileBad: true"
LV_ERR_REP_UI_OUT_MESSAGE_COMPILE_BAD = "VI 在编译时损坏。"
LV_ERR_REP_INPUT_LOG_CALLERS = "来电者：[];"
LV_ERR_REP_VI_NAME_REGEX = "名称：\"(.*?)\";"
LV_ERR_REP_TS_VINAME_REGEX = "名称：\\\".*?\\\";"
LV_ERR_REP_OUTPUT_NAME_TRIM = "名称：\""
LV_ERR_REP_VI_LINE_REGEX = "vi: (.*?);\\}"
LV_ERR_REP_TS_VI_LINE_REGEX = "vi:.*?;\\}"
LV_ERR_REP_VI_LOADERROR_REGEX = "加载错误：(.*?);\\}"
LV_ERR_REP_TS_VI_LOADERROR_REGEX = "加载错误：.*?;\\}"
LV_ERR_REP_REPLACE_LOADERROR = "加载错误："
LV_ERR_REP_VI_PATH_REGEX = "路径：\"(.*?).vi\""
LV_ERR_REP_TS_VI_PATH_REGEX = "路径：\\\".*?.vi\\\""
LV_ERR_REP_REPLACE_PATH = "路径：\""
LV_ERR_REP_REPLACE_VIFORPATH_REGEX = ".vi\""
LV_ERR_REP_VI_PATH_END_REGEX = "路径：\"(.*?).vi"
LV_ERR_REP_TS_VI_PATH_END_REGEX = "路径：\\\".*?.vi\\\""
LV_ERR_REP_TS_CTL_PATH_END_REGEX = "路径：\\\".*?.ctl\\\""
LV_ERR_REP_TS_CTL_PATH_END_REGEX_PATTERN = "路径：\\\".*?.ctl"
LV_ERR_REP_CTL_PATH_REGEX = "路径：\"(.*?).ctl\""
LV_ERR_REP_TS_CTL_PATH_REGEX = "路径：\\\".*?.ctl"
LV_ERR_REP_PATH_REGEX = "路径：\"(.*?)\";"
LV_ERR_REP_VI_TIMESTAMP_REGEX = "时间戳：\"(.*?)\";"
LV_ERR_REP_RTE_START = "编辑器版本："
LV_ERR_REP_TS_VI_TIMESTAMP_REGEX = "时间戳：\\\".*?\\\";"
LV_ERR_REP_TS_VI_CALLSITE_REGEX = "callSite: \\\".*?\\\";"
LV_ERR_REP_REPLACE_END_TIMESTAMP = ";\""
LV_ERR_REP_REPLACE_END_CALLSITE = "\";"
LV_ERR_REP_VI_MISSINGREFEE_REGEX = "缺少资源：\\[(.*?)\\];"
LV_ERR_REP_TS_VI_MISSINGREFEE_REGEX = "缺少资源：\\[.*?\\];"
LV_ERR_REP_VI_CALLCHAIN_REGEX = "调用链：\\[(.*?)\\];"
LV_ERR_REP_VI_REFEE_REGEX = "裁判：(.*?);\\}"
LV_ERR_REP_TS_VI_REFEE_REGEX = "裁判：.*?;\\}"
LV_ERR_REP_REPLACE_REFEE = "裁判：{"
LV_ERR_REP_REPLACE_REFEE_END_TAG = "\";}"
LV_ERR_REP_VI_DEPEDENCYIDENT_REGEX = "dependencyIdent: (.*?)\";\\};"
LV_ERR_REP_TS_VI_DEPEDENCYIDENT_REGEX = "dependencyIdent: .*?;\\};\\}"
LV_ERR_REP_REPLACE_DEPEDENCYIDENT = "dependencyIdent: { "
LV_ERR_REP_REPLACE_DEPEDENCYIDENT_END_TAG = "\";};"
LV_ERR_REP_REPLACE_TS_DEPEDENCYIDENT_END_TAG = ";\\};\\}"
LV_ERR_REP_VI_REFEEVI_REGEX = "refeeVI: \\{(.*?);\\}"
LV_ERR_REP_TS_VI_REFEEVI_REGEX = "refeeVI: \\{.*?;\\}"
LV_ERR_REP_REPLACE_REFEEVI = "refeeVI: { "
LV_ERR_REP_CALLCHAIN_OUT_ERROR = "\nVI调用链：\n"
LV_ERR_REP_INPUT_LOG_CALLCHAIN = "调用链：[];"
LV_ERR_REP_INPUT_LOG_CALLCHAIN_EXISTS = "调用链："
LV_ERR_REP_INPUT_LOG_CALLCHAIN_EXISTS_OPEN = "["
LV_ERR_REP_INPUT_LOG_CALLCHAIN_EXISTS_END = "];"
LV_ERR_REP_INPUT_LOG_CALLSITE = "呼叫站点："
LV_ERR_REP_INPUT_LOG_SET_VI_BAD = "设置VIBad"
LV_ERR_REP_INPUT_LOG_VI_NAME = "vi:"
LV_ERR_REP_INPUT_LOG_VI_PATH = "路径"
LV_ERR_REP_INPUT_LOG_HEADER_TAG = "标题"
LV_ERR_REP_INPUT_LOG_VI_BROKEN = "VI_BROKEN"
LV_ERR_REP_INPUT_LOG_TIMESTAMP = "时间戳："
LV_ERR_REP_INPUT_LOG_COMPILED = "已编译"
LV_ERR_REP_INPUT_LOG_REFEEVI = "refeeVI: "
LV_ERR_REP_INPUT_LOG_REFEE = "裁判："
LV_ERR_REP_INPUT_LOG_MISSING_REFEE = "缺少资源："
LV_ERR_REP_INPUT_LOG_END_COLON = ";"
LV_ERR_REP_UI_OUT_VI = "VIVI"
LV_ERR_REP_UI_OUT_VI_MISSING = "相关文件 \'%1\' 丢失。"
LV_ERR_REP_UI_OUT_CTL = "VICC"
LV_ERR_REP_UI_OUT_CTL_MISSING = "相关文件 \'%1\' 丢失。"
LV_ERR_REP_UI_OUT_LIB = "VILB"
LV_ERR_REP_UI_OUT_LIB_MISSING = "相关文件 \'%1\' 丢失。"
LV_ERR_REP_UI_OUT_PPL = "VIAV"
LV_ERR_REP_UI_OUT_PPL_COLON = ":"
LV_ERR_REP_UI_OUT_PPL_MISSING = "相关文件 \'%1\' 丢失。"
LV_ERR_REP_REPLACE_LOAD_ERROR = "'%1' 的位数/版本不匹配"
LV_ERR_REP_REPLACE_MISSING_DEPENDENCY = "'%1' 丢失。"
LV_ERR_REP_OUTLOG_HEADER_IN_LOG_FILE = "标题：{ VI 路径："
LV_ERR_REP_INPUT_LOG_DEPENDENCY_IDENT = "dependencyIdent: "
LV_ERR_REP_INPUT_LOG_REGEX_DEPENDENCY = ".*dependencyIdent*。"
LV_ERR_REP_INPUT_LOG_REGEX_REFTYPE = ".*refType*。"
LV_ERR_REP_INPUT_LOG_REGEX_REFIDENT = ".refIdent。"
LV_ERR_REP_INPUT_LOG_REGEX_NAME = ".*名称*。"
LV_ERR_REP_INPUT_LOG_REGEX_PATH = ".路径。"
LV_ERR_REP_UI_OUT_SOURCE_ONLY = "\n\n 未找到此 VI 的编译代码。确保 VI 在与正在使用的运行时引擎匹配的 LabVIEW 版本中编译。\n"
LV_ERR_REP_UI_OUT_SOURCE_ONLY_VI = "\n 可能找到一个 sourceonly VI。请在当前 LV 版本中编译 VI 并重新加载 VI。"
LV_ERR_REP_UI_OUT_DEPENDENCY_MISSING = "从路径加载的依赖项 '%1'，'%2' 导致类型不匹配 "
LV_ERR_REP_REGEX_SEARCH_CALLSITE = "\\{(.*?)\\}"
LV_ERR_REP_REPLACE_END_TAG_COLON_STR = ";}"
LV_ERR_REP_CALLSITE_READ_SOURCEONLY = "SourceOnly"
LV_ERR_REP_CALLSITE_TO_BE_READ_LOAD_FAILURE="加载失败"
LV_ERR_REP_CALLSITE_TO_BE_READ_END_OF_SECTION = "EndOfSection"
LV_ERR_REP_REPLACE_ERROR1_FOR_SINGLE_ERROR = "\n\n错误 1\n"
LV_ERR_REP_FIND_CHAR_TIMESTAMP = "'.'"
LV_ERR_REP_REPLACE_TIMESTAMP_STR = "时间戳：\""
LV_ERR_REP_REPLACE_RTE_STR = "编辑器版本："
LV_ERR_REP_REPLACE_CALLSITE_STR = "callSite: \""
LV_ERR_REP_REPLACE_QUOTE_STR = "\""
LV_ERR_REP_REPLACE_QUOTE_CTL_END = ";}"
LV_ERR_REP_REPLACE_END_TAG_STR = ";};"
LV_ERR_REP_CTL_FOUND_END = ".ctl"
LV_ERR_REP_ERROR_COUNT_STR = "错误"
LV_ERR_REP_BITNESS_CODE = "{ mgErr=1124; loadCode=22; };"
LV_ERR_REP_VERSION_CODE = "{ mgErr=1126; loadCode=10; };"
LV_ERR_REP_LOADERROR_MISMATCH = "\nVI \'%1\' 的位数/版本与 LabVIEW 运行时引擎的位数/版本不匹配"
LV_ERR_REP_VI_BROKEN_ERROR = "\nLabVIEW 上次保存时 VI '%1' 已损坏"
LV_ERR_REP_VI_SOURCEONLY_ERROR = "\n文件 \'%1\' 是一个纯源组件，在编译对象缓存中找不到它的编译代码。"
LV_ERR_REP_VI_DEPEDENCYMISMATCH_ERROR = "\nVI \'%1\' 缺少依赖项或者在编译对象缓存中找不到它的编译代码。\n"
LV_ERR_REP_VI_DEPENDENCYPATH_ERROR = "由\'%1\'引起的错误"
LV_ERR_REP_VI_OUT_OF_SCOPE_ERROR = "\n由于库访问范围，VI \'%1\' 无法访问引用项。\nVI 调用链：\n"
LV_ERR_REP_UNKNOWN_CALLSITE_ERROR_MESSAGE = "\n在 LabVIEW 调试日志中发现未知错误类型。请参阅 TestStand 的日志文件以获取更多信息"
LV_ERR_REP_VI_BAD_ERROR_MESSAGE = "\nVI 已损坏。请参阅 TestStand 的日志文件以获取更多信息"


;;参数映射对话框
PARAM_MAPPING_DLG_CAPTION = "参数名/值映射"
PARAMETER_NAME_COLUMN_HEADER = "参数名称"
VALUE_COLUMN_HEADER = "值表达式"
ADD_MAPPING_BTN = "&添加"
DELETE_MAPPING_BTN = "&删除"
PARAMETER_NAME_EDIT_LABEL = "参数名称："
VALUE_EDIT_LABEL = "&值表达式："

PARAMETERS_ADDED_MSG = "添加了以下参数：\n"
PARAMETERS_DELETED_MSG = "以下参数已删除：\n"
PARAMETERS_VERIFY_ARG_VALUES = "验证新参数具有正确的参数值。"
CONFIGURING_DLG_MSG = "打开配置..."
PROGRESS_BAR_LABEL = "构建 Express VI 菜单"
PROGRESS_WINDOW_TITLE = "建筑菜单"
REFRESH_EXPRESS_VI_MENU = "刷新菜单"
SELECT_EXPRESS_VI_TITLE = "选择 Express VI"
FIND_CONFIG_VI_PROMPT = "找到名为 '%s' 的 VI"

CONFIG_ERROR_DLG_TITLE = "配置 VI 时出错"
CONFIG_INVALID_PROTOTYPE = "配置 VI '%1' 没有预期的原型。"

CANNOT_CALL_EXPRESS_BLOCK_DIRECTLY Line0001 = "VI '%1' 是一个 Express VI。\n\nLabVIEW 适配器无法使用当前设置配置 Express VI。\n"
CANNOT_CALL_EXPRESS_BLOCK_DIRECTLY Line0002 = "您必须配置适配器以使用 LabVIEW 开发系统作为 LabVIEW ActiveX 服务器。"

CANNOT_BROWSE_FOR_EXPRESS_VI Line0001 = "LabVIEW 适配器当前配置为在\n不支持编辑 VI 的环境中运行测试。"
CANNOT_BROWSE_FOR_EXPRESS_VI Line0002 = "要选择一个 Express VI，您必须在\n中选择一个不同的 LabVIEW ActiveX 服务器"
CANNOT_BROWSE_FOR_EXPRESS_VI Line0003 = "LabVIEW 适配器配置对话框。"

CANNOT_CALL_EXPRESS_VI_IN_SUBSTEP = "TestStand 不支持从子步骤调用 Express VI。"

PROMPT_TO_SAVE_WRAPPER_VI = "如果将 Express VI 调用更改为标准 VI 调用，则不能\n在不丢失现有 Express VI 配置信息的情况下将调用类型改回 Express VI。\n\n是否要将 Express VI 调用转换为一个标准的 VI 调用？"
PROMPT_TO_SAVE_WRAPPER_VI_TITLE = "将 Express VI 调用转换为标准 VI 调用"

PROMPT_TO_CLEAR_WRAPPER_VI = "你选择了一个标准 VI。\n你想替换现有的 Express VI 吗？"
PROMPT_TO_CLEAR_WRAPPER_VI_TITLE = "清除现有的 Express VI？"

STANDARD_TO_EXPRESS_VI_MSG = "您不能将标准 VI 更改为 Express VI。\n继续选择会清除所有参数信息。\n\n您要继续吗？"

EXPRESS_VI_HAS_CHANGED Line0001 = "Express VI '%1' 是用 LabVIEW 版本 '%2' 创建的。\n当前活动的 LabVIEW 版本是 '%3'。\n"
EXPRESS_VI_HAS_CHANGED Line0002 = "配置更改将 Express VI 更新为当前 LabVIEW 版本。\n\n您是否仍要从 TestStand 配置 VI？"
EXPRESS_VI_HAS_CHANGED_TITLE = "VI 已更改"

NOT_EXPRESS_VI_ERROR = "需要 Express VI。'%1' 不是 Express VI。"
EXPRESS_VI_NOT_SUPPORTED = "此版本的 TestStand 不支持 Express VI '%1'。"
EMPTY_EXPRESS_VI_PATH = "Express VI 路径不能为空。"

PROPERTY_LIBRARY_NAME_IS_EMPTY = "无法创建 LabVIEW 属性节点。属性节点类型 (NodeLibraryName) 不能为空。"
PROPERTY_CLASS_DATA_NAME_IS_EMPTY = "无法创建 LabVIEW 属性节点。属性节点类型 (NodeLibraryGenericTypeName) 不能为空。"
PROPERTY_CLASS_NAME_IS_EMPTY = "无法创建 LabVIEW 属性节点。属性节点类 (NodeClassDataName) 不能为空。"
PROPERTY_INPUT_ARRAYS_ARE_DIFFERENT = "无法创建 LabVIEW 属性节点。属性名称和方向数组的大小不同。"
PROPERTY_INPUT_ARRAYS_ARE_EMPTY = "无法创建 LabVIEW 属性节点。没有选择任何属性。"
PROPERTY_INPUT_ARRAYS_GREATER = "无法创建 LabVIEW 属性节点。属性的数量大于允许的最大大小。"
PROPERTY_UNABLE_TO_ACCESS_LABVIEW_CLASS = "TestStand 无法访问 LabVIEW 类 '%1'。"

EMBEDDED_EXPRESS_VI_MSG = "[序列中嵌入的 Express VI]"

EXPRESS_VI_SELECTED = "您选择的 VI 是一个 Express VI。\n您要从 TestStand 调用和配置 Express VI 吗？"
SELECT_EXPRESS_VI_WRAPPER_LOCATION = "选择 Express VI 包装器位置"
SELECT_PROPERTY_NODE_VI_WRAPPER_LOCATION = "选择属性节点 VI 包装位置"
SPEC_MOD_DLG_EXPLANATION_LABEL = "为 Express VI 包装器选择位置和 VI 名称。"

SELECT_WHICH_PARAMS_TO_PASS = "选择要传递给 VI 的可选参数。"

CODE_TMPLT_DLG_TITLE = "选择代码模板"
CODE_TMPLT_DLG_EXPLANATION Line0001 = "选择用于为该步骤生成代码的代码模板。对于遗留代码\n"
CODE_TMPLT_DLG_EXPLANATION Line0002 = "模板，选择你需要的可选参数。"
CODE_TMPLT_DESCRIPTION_COLUMN_HEAD = "描述"
CODE_TMPLT_NAME_COLUMN_HEAD = "名称"
SELECT_CODE_TMPLT_MSG = "选择代码模板。"
CODE_TMPLT_DLG_SHOW_LEGACY_TEMPLATE = "列表中的遗留模板&how"
CODE_TMPLT_DLG_PARM_GRP_TXT = "旧模板的可选参数"

NON_STANDARD_PROTOTYPE_TITLE = "非标准原型"
VI_DOES_NOT_HAVE_STD_PROTOTYPE = "你选择的 VI 没有 TestStand 期望的标准原型。\n选择你想传递给 VI 的可选参数。\n"
READ_VI_PROTOTYPE_INFO_TITLE = "需要启动 LabVIEW"
READ_VI_PROTOTYPE_INFO = "您必须启动 LabVIEW 才能读取 VI 原型。"

ADVANCED_SETTINGS_DLG_TITLE = "高级设置"
REMOTE_CALL_SETTINGS_LABEL = "在远程计算机上运行 VI"
SPECIFY_BYEXPR_HOST_BTN_LABEL= "为主机指定表达式"
REMOTE_HOST= "远程主机:"
BROWSE_FOR_COMPUTER = "浏览计算机..."
REMOTE_PROJECT_PATH_LABEL = "远程项目路径:"
REMOTE_VI_PATH_LABEL = "远程 VI 路径&路径："
PORT_NUMBER_LABEL = "端口号："
TIMEOUT_LABEL = "超时（毫秒）："
REMOTE_HOST_NOTE Line0001 = "对于远程调用，LabVIEW 必须在远程主机上运行。该主机必须能够访问 VI 的副本以读取 VI 原型。"
REMOTE_HOST_NOTE Line0002 = "或者，您可以创建一个与该主机上的远程 VI 具有相同连线板的 VI。"
MISSING_PORT_NUMBER_OR_TIMEOUT = "您必须指定端口号和超时值。"
AUTO_DETECT_LVRT_LABEL = "始终在 LabVIEW 运行时引擎中运行 VI"
AUTO_DETECT_LVRT_DESC = "启用此选项以确保 TestStand 始终在 LabVIEW 运行时引擎中运行此 VI，而不管 LabVIEW 适配器的服务器设置如何。TestStand 自动确定用于运行此 LabVIEW 运行时引擎的正确版本六。"
DONT_ABORT_VI_LABEL = "不允许 TestStand 中止 VI"

SELECT_VI_FROM_PROJECT_DLG_CAPTION = "从 LabVIEW 项目中选择 VI - '%1'"
SELECT_CLASS_FROM_PROJECT_DLG_CAPTION = "从 LabVIEW 项目中选择一个类 - '%1'"
SELECT_CLASS_MEMBER_FROM_PROJECT_DLG_CAPTION = "从 LabVIEW 项目中选择一个类成员 - '%1'"
SELECT_MEMBER_FROM_CLASS_DLG_CAPTION = "从 LabVIEW 类中选择一个类成员 - '%1'"
ADD_OR_REMOVE_ITEMS_FROM_PROJECT_DLG_CAPTION = "从 LabVIEW 项目中添加或删除项目 - '%1'"
PROJECT_SEARCH_LABEL = "搜索项目："
PROJECT_HELP_LABEL = "右击 LabVIEW 项目并选择合适的上下文菜单选项\n以在 LabVIEW 项目中创建、添加或删除 VI。"
PROJECT_VI_LOCATION_LABEL = "选定的 VI："
PROJECT_CLASS_LOCATION_LABEL = "所选职业："
PROJECT_MEMBER_LOCATION_LABEL = "选定成员："
LVPROJECT_NEW_VI = "新 VI..."
LVPROJECT_NEW_LIBRARY = "新图书馆..."
LVPROJECT_NEW_VIRTUAL_FOLDER = "新虚拟文件夹..."
LVPROJECT_ADD_VI = "添加 VI..."
LVPROJECT_ADD_LIBRARY = "添加库..."
LVPROJECT_EDIT_VI = "编辑 VI"
LVPROJECT_REMOVE_FROM_PROJECT = "从项目中移除"
LVPROJECT_EXPAND = "全部展开"
LVPROJECT_COLLAPSE = "全部折叠"
UNABLE_TO_FIND_PROJECT_ITEM = "TestStand 无法完成您请求的操作。\n\n一些 LabVIEW 项目项不再存在。无法找到项目 '%1'。\n\nLabVIEW 项目将刷新。"
UNABLE_TO_ADD_PROJECT_ITEM = "TestStand 无法添加该项目。\n\n该项目可能已经存在于 LabVIEW 项目中。\n\nLabVIEW 项目将刷新。"
UNABLE_TO_COMPLETE_OPERATION = "TestStand 无法完成您请求的操作。\n\n%1\n\nLabVIEW 项目将刷新。"
PROJECT_DELETE_ITEM = "TestStand 从 LabVIEW 项目中永久删除所选项目。"
DEFAULT_NEW_FOLDER_TEXT = "新文件夹"
LVPROJECT_VERSION_TOO_EARLY = "LabVIEW 无法将 LabVIEW 项目版本(%2) 转换为 LabVIEW 运行时引擎版本 (%1)。项目或其库之一是旧版本。"
LVPROJECT_VERSION_LATER = "LabVIEW 无法将 LabVIEW 项目版本 (%2) 转换为 LabVIEW 运行时引擎版本 (%1)。该项目或其库之一是更新版本。"
SELECT = "选择"
DONE ="完成"
UNABLE_TO_SET_BCRTE = "TestStand 无法在 LabVIEW 中设置版本独立运行时引擎选项。"
ERR_UNEXPECTED_ERROR_RELEASE_EC = "使用 LabVIEW 运行时发生意外错误。请联系 NI 寻求支持。"
ERR_UNEXPECTED_ERROR_RELEASE_AND_CLOSE_VI_FRONT_PANEL = "关闭 VI 前面板时出现意外错误。请联系 NI 寻求支持。"

SELECT_VI_FROM_POLY_VI_DLG_CAPTION = "从多态 VI 中选择 VI"
SELECT_VI_DESCRIPTION = "所选 VI 是多态 VI。TestStand 不能直接调用多态 VI。选择多态 VI 包含的 VI 之一。"
SELECT_VI_SELECT_VI_LABEL = "选择一个 VI："
SELECT_VI_MUST_SELECT_VI = "您必须从列表中选择一个 VI 才能关闭此对话框。"
EMPTY_POLYMORPHIC_VI = "所选 VI 是空的多态 VI，无法打开。\n请选择另一个 VI。"

POLY_VI_SELECTED = "所选 VI 是多态 VI。TestStand 无法直接调用多态 VI。\n重新加载原型以选择多态 VI 包含的 VI 之一。"

MODULE_BROWSE_TITLE = "为步骤选择代码模块"
VI_BROWSE_TITLE = "选择要添加的 LabVIEW VI"
VI_CREATE_TITLE = "选择要创建的 LabVIEW VI"
PROJECT_BROWSE_TITLE = "为步骤选择 LabVIEW 项目文件"
PROJECT_CREATE_TITLE = "选择要为步骤创建的 LabVIEW 项目文件"
PROJECT_FILES_MSG = "LabVIEW 项目文件"
CLASS_BROWSE_TITLE = "为步骤选择 LabVIEW 类文件"
CLASS_FILES_MSG = "LVCLASS 文件"
LVLIBP_FILES_MSG = "LVLIBP 文件"
VI_FILES_MSG = "VI 文件"
LLB_FILES_MSG = "LLB 文件"
VI_AND_LLB_FILES_MSG = "VI 和 LLB 文件"
VI_LLB_AND_LVLIBP_FILES_MSG = "VI、LLB 和 LVLIBP 文件"
CLASS_LLB_AND_LVLIBP_FILES_MSG = "LVCLASS、LLB 和 LVLIBP 文件"
LV_AUTO_NOTREG = "'%1' ActiveX 自动化服务器未在此计算机上注册。"
LV_LAUNCH_FAILED = "无法启动 '%1' ActiveX 自动化服务器。"
LV_LAUNCH_FAILED_ADDITIONAL_DESCRIPTION = "CoCreateInstance 返回 '%1':\n%2"
LV_NOT_INSTALLED = "TestStand 找不到安装在这台计算机上的 LabVIEW 开发系统。"
SOURCE_PROJECT_BROWSE_TITLE = "为步骤选择 LabVIEW 源项目文件"

CLUSTER_PROP_PAGE_TITLE = "集群通过"
ALLOW_CLUSTER_PASSING_LABEL = "允许这种类型的对象作为 LabVIEW 簇传递(&Y)"
CLUSTER_PROP_LABEL = "属性："
CLUSTER_PROP_GROUPBOX_LABEL = "属性的内存布局"
CLUSTER_PROP_TYPE_LABEL = "类型："
CLUSTER_PROP_BINARY_STRING_LABEL = "是二进制字符串"
CLUSTER_MEMBER_LABEL = "集群项目&标签："
CLUSTER_PROP_EXCLUDE_LABEL = "通过集群时排除&x"
CLUSTER_MEMBER_NOT_ALLOWED_MESSAGE = "你不能在集群中包含指定的成员。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0001 = "簇不能包含指定的成员，因为您不能在 LabVIEW 中将该类型的对象作为簇传递。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0002 = "您必须打开对象类型的属性表并启用\"允许此类型的对象作为 LabVIEW 簇传递\"选项。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_TITLE = "不能包括集群成员"
TESTSTAND_NAME_COLUMN = "测试站名称"
LABVIEW_LABEL_COLUMN = "LabVIEW 标签"
TESTSTAND_TYPE_COLUMN = "测试台类型"
LABVIEW_TYPE_COLUMN = "LabVIEW 类型"
UPDATE_ACTION_COLUMN = "集群映射操作"
CLUSTER_CREATE_BTN_LABEL = "创建&创建"
CLUSTER_UPDATE_BTN_LABEL = "升级&pdate"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL = "要启用此属性页上的控件，打开包含此属性的类型的属性表并启用"允许此类型的对象作为 LabVIEW 集群传递"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL2 = "这是一个类型的实例。类型定义阻止您将其作为簇传递。要更改设置，打开类型定义的属性表并启用\"允许此类型的对象作为簇传递LabVIEW 集群\"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL3 = "这是一个类型的实例。要修改它的属性，请打开类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL4 = "这个属性是一个类型的实例。要修改它的值，打开包含这个属性的类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL5 = "您不能将此容器属性作为集群传递。要更改设置，请打开容器属性父级的属性表并禁用"传递集群时排除"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL6 = "您不能将此属性的父项之一作为集群成员传递。要启用此属性页上的控件，请打开父项的属性表并禁用"传递集群时排除"选项。"

ADP_CFG_CAPTION = "LabVIEW 适配器配置"
ADP_CFG_SELECT_SERVER_HDR = "选择或键入要使用的 LabVIEW 服务器"
ADP_CFG_AUTODETECT_RTE = "使用 VI 版本自动检测"
ADP_CFG_HI_SPEED_RTS_RADIO = "LabVIEW &运行时引擎"
ADP_CFG_USE_LABVIEW_RADIO = "LabVIEW &开发系统"
ADP_CFG_USE_ACTIVE_VERSION = "使用活动的 LabVIEW 版本：%1 [默认]"
ADP_CFG_USE_ACTIVE_32BIT_VERSION = "使用活动的 32 位版本：%1"
ADP_CFG_USE_ACTIVE_64BIT_VERSION = "使用活动的 64 位版本：%1"
ADP_CFG_UNKNOWN_LV_VERSION = "未知或未安装"
ADP_CFG_NOT_ALLOWED_LV_VERSION = " - 不允许"
ADP_CFG_OTHER_SERVER_RADIO = "其他&其他可执行文件"
ADP_CFG_OPTIONS_HDR = "选项"
ADP_CFG_VI_RESERVE_POLICY_LBL = "为执行保留加载的 VIs"
ADP_CFG_UNLOAD_NEVER_OPT = "从不卸载 VIs"
ADP_CFG_ABORT_RUNNING_VIS = "允许 TestStand 中断运行中的 VIs"
ADP_CFG_TEMPLATE_CREATION_HDR = "代码模板策略"
ADP_CFG_ALLOW_NEW_TEMPLATES_ONLY = "只允许新模板&&"
ADP_CFG_ALLOW_OLD_TEMPLATES_ONLY = "仅允许旧版模板(&L)"
ADP_CFG_ALLOW_OLD_NEW_TEMPLATES = "允许新旧模板"
ADP_CFG_UUT_INFO_SRC_BUTTON = "旧版 VI 设置(&S)..."
ADP_CFG_UUT_INFO_SRC_CAPTION = "旧版 VI 设置"
ADP_CFG_UUT_INFO_GROUP_LABEL = "调用信息参数 UUT 信息源表达式"
ADP_CFG_UUT_NUM_LABEL = "UUT 迭代次数："
ADP_CFG_UUT_INFO_LABEL = "序列号字符串："
ADP_CFG_LVVERSION_32BIT = "（32 位）"
ADP_CFG_LVVERSION_64BIT = "（64 位）"

ADP_CFG_ITER_SYNTAX_ERR = "UUT 迭代表达式中存在语法错误。"
ADP_CFG_SERIAL_NUM_SYNTAX_ERR = "UUT 序列号表达式中存在语法错误。"

ADP_CFG_LVPROJECT_OPTIONS_HDR= "LabVIEW 项目设置"
ADP_CFG_AUTO_DEPLOY_SHARED_VARIABLES_LBL = "首次加载项目中任何 VI 时自动部署共享变量(&&)"
ADP_CFG_AUTO_UNDEPLOY_SHARED_VARIABLES_LBL = "在最后一次卸载项目中的所有 VI 时自动CANCEL部署共享变量"

ADP_CFG_RTE_VER_LABEL = "版本："
ADP_CFG_RTE_NUMBER_THREADS_LABEL = "线程数："
ADP_CFG_RTE_USE_MULTIPLE_THREADS_CHECKBOX = "使用多线程执行'与调用者相同'VI*"
ADP_CFG_RTE_THREADS_INHERIT_CPU_AFFINITY_CHECKBOX = "附加线程(&I)继承调用线程的 CPU 关联性"
ADP_CFG_NUM_RTE_THREADS_DEFAULT = "默认 (%1)"
ADP_CFG_INFO_TEXT = "* 直到您下次启动 TestStand 应用程序时更改才会生效"
ADP_CFG_INFO_ON_DEBUGGING_AND_TRACING = "使用与 VI 版本相匹配的 LabVIEW 开发系统版本进行调试。如果启用版本独立运行时选项，请使用 LabVIEW %1"

ADP_CFG_RTE_ENABLE_DEBUGGING_AND_TRACING_CHECKBOX = "启用调试和跟踪*"
ADP_CFG_RTE_DISPLAY_TCP_PORTS = "TCP 端口"
ADP_CFG_RTE_DISPLAY_TCP_PORT = "LabVIEW 运行时引擎 %1：%2\n"
ADP_CFG_RTE_DISPLAY_TCP_PORT_NONE_SUPPORTED = "未找到对 LabVIEW 运行时引擎的支持。"

ENABLE_BCRTE = "启用独立于版本的运行时引擎*"
BCRTE_ENFORCES_AUTODETECT_TOOLTIP_TEXT = "自启用版本独立运行时功能以来，已选择'使用 VI 版本自动检测'选项。要选择特定版本的运行时引擎，请CANCEL选中高级选项卡下的复选框 -> 选项 -> 启用版本独立运行时引擎"
BCRTE_ENABLED_WARNING = "当版本独立运行时功能启用时，LabVIEW 运行时引擎将无法在 LabVIEW 的文件夹（如 vi.lib、instr.lib 或 user.lib）中找到 VI 依赖项。创建部署以确保引入所有必需的依赖项. 有关详细信息，请参阅启用版本独立运行时功能的帮助。"

ADP_ADV_CFG_CAPTION = "高级"
ADP_GEN_CFG_CAPTION = "一般"

ADP_CFG_ALLOW_SWITCH_BINARY = "始终在打包项目库中运行 VI"
ADP_CFG_USE_SOURCE_MODULES = "始终运行 VI"
ADP_CFG_USE_PPL_MODULES = "始终运行打包项目库"
ADP_CFG_AUTO_BUILD_PPL = "在执行开始时自动构建打包项目库"

ARRAY_DIMENSIONS = "%1D "
INT8 = "I8"
UINT8 = "U8"
INT16 = "I16"
UINT16 = "U16"
INT32 = "I32"
UINT32 = "U32"
REAL32 = "SGL"
REAL64 = "DBL"
INT64 = "I64"
UINT64 = "U64"
EXT = "EXT"
ARRAY = "Array (%1)"
ARRAY_OF = "Array"
COMPLEX = "Complex"
COMPLEXNUMS = "复数数组"
CLUSTER = "簇"
CLUSTERS = "簇数组"
VARIANT = "变体"
VARIANTS = "变体数组"
ANYTHING_TYPE = "任何"
UNKNOWN_TYPE = "未知"
CLASS_OBJECT = "LabVIEW 类对象"
DOT_NET_OBJECT = "LabVIEW .NET 对象"

;;各种枚举类型的字符串。
PARAMETER_DIRECTION_IN = "in"
PARAMETER_DIRECTION_OUT = "out"
PARAMETER_DIRECTION_DEFAULT = "默认"
NOT_LEGACY_CLUSTER = "非遗留集群"
ERROR_OUT_CLUSTER = "集群错误"
TESTDATA_CLUSTER = "测试数据集群"
PARAM_REQUIRED = "必需"
PARAM_RECOMMENDED = "推荐"
PARAM_OPTIONAL = "可选"
IO = "IO"
ANALOG_WAVEFORM = "模拟波形"
DIGITAL_DATA = "数字数据"
DIGITAL_WAVEFORM = "数字波形"
DYNAMIC_DATA = "动态数据"
DOTNETREF = ".NET 对象"
LVOBJECT = "LabVIEW 对象"
OTHER = "LabVIEW 参考"
LVCLASS = "LabVIEW 类"
STRING_BINARY = "二进制字符串"
STRING_PATH = "路径"
STRING_TIMESTAMP = "时间戳"
STRING_ASCII = "ASCII 字符串"

IO_DEVICE_NAME = "设备名称"
IO_SESSION_NUMBER = "会话编号"
元素 = "元素"
ELEMENT = "真实"
IMAGINARY = "虚数"
COMPLEX_DISPLAY = "%1 + %2i"

STEP_DESC_UNSPECIFIED_ARG = "'??? <未知值>"
STEP_DESC_OPTIONAL_ARG = " "

STEP_DESC_REMOTE_HOST = "在服务器上：%1"
STEP_DESC_ALWAYS_USE_RTE = "始终使用运行时引擎运行"

EMPTY_EXPR_ERROR = "参数 '%1' 的表达式不能为空。"
EXPECTED_NON_EMPTY_DYNAMIC_DATA = "预期非空 LabVIEWDynamicData 数据类型实例。"

SYNTAX_ERR_NON_OPTIONAL_PARAM_EMPTY = "参数 %1 的值中存在语法错误：\n\n您必须为必需的参数指定值。\n\n该值会导致运行时错误。"
SYNTAX_ERR_PARAM = "参数 %1 的值存在语法错误：\n\n%2\n\n该值导致运行时错误。"
CLUSTER_ARG_ALL_OR_NOTHING = "您必须为簇 '%1' 指定所有参数或不指定任何参数。"
CLUSTER_ARG_MAPPING_INCOMPLETE = "您必须为簇 '%1' 指定所有元素或不指定任何元素。\n如果您使用参数映射，则必须映射所有元素。\n\n元素 '%2' 未映射。"
ARRAY_REAL_IMA_NOT_SAME_SIZE = "复数数组 '%1' 的数组大小不同。\n对于复数数组，实数组和虚数组的大小必须相同。\n\n实数组大小：%2\n虚数组大小: %3"

ARRAY_ELEMENT_NOT_MATCHING_CLUSTER = "数组 '%1' 的元素与 LabVIEW 簇不匹配，或者在数组元素类型定义中禁用了簇传递。"
ELEMENT_NOT_MATCHING_CLUSTER = "'%1' 的类型与 LabVIEW 簇 '%2' 不匹配，或者在 '%3' 的类型定义中禁用了簇传递。"
NO_MATCHING_FIELD_IN_TYPEDEF_WITH_ARG = "对于簇元素 '%3'，'%2' 类型的参数 '%1' 中没有对应的子属性"
CLUSTER_FIELD_WRONG_TYPE = "属性 '%1' 的类型与元素 '%2' 的簇定义不兼容。"
TYPE_NOT_VALID_FOR_ARRAY_OF_CLUSTERS = "参数 '%1' 的类型对于簇数组无效。该类型必须是与 LabVIEW 簇对应的自定义数据类型的数组，并且必须配置为支持 LabVIEW 簇传递。"
ARRAY_OF_CLUSTERS_CONTAINERS_SPECIFIED = "参数 '%1' 是一个非结构化容器数组，其中第一个元素具有类似于 LabVIEW 簇的对象结构，但其余元素可能不是。执行该步骤可能有效，但建议指定一个参数，它是一个自定义数据类型的数组，对应于 LabVIEW 集群，并配置为支持 LabVIEW 集群传递。"
INVALID_REPRESENTATION_FOR_ENUM = "‘%1’的数字表示与 LabVIEW 参数‘%2’的表示不兼容。预期的表示是：%3"
TYPE_NOT_VALID_FOR_ENUM = "自定义枚举类型 '%1' 必须与 LabVIEW 枚举参数 '%2' 完全匹配。"
STRING_NOT_VALID_FOR_ENUM = "字符串值 '%1' 必须至少与 LabVIEW 枚举参数 '%2' 的枚举数之一完全匹配。"
STRING_EMPTY_OR_DUPLICATE_IN = "LabVIEW 枚举的字符串参数不能是重复的枚举器值"
STRING_EMPTY_OR_DUPLICATE_OUT = "不能为字符串参数分配来自 LabVIEW 枚举参数的重复枚举器值"
ELEMENT_NOT_MATCHING_ENUM = "'%1' 的类型与 LabVIEW 枚举 '%2' 允许的类型不匹配"
NO_OF_ENUMERATORS_MISMATCH = "类型 '%1' 指定的枚举器数量与 LabVIEW 枚举不同"
ENUMERATORS_MISMATCH_IN_ENUM_TYPE = "'%1' 类型的枚举器与 LabVIEW 枚举的枚举器不匹配"
MISMATCH_IN_ENUMERATOR_VALUE = "枚举数 '%1' 在 TestStand 和 LabVIEW 枚举中的数值不同"
TS_ENUMERATOR_DOESNOT_MATCH_LV_ENUM = "TestStand 枚举器 '%1' 不匹配 LabVIEW 枚举参数 '%2' 中的任何枚举器\n"
TS_ENUMERATOR_VALUE_DOESNOT_MATCH_LV_ENUM = "枚举器 '%1' 的数值与参数 '%2' 不匹配\n"
FLAG_ENUMS_DO_NOT_SUPPORT_FLOATING_POINT_TYPES = "设置了 Flags Enumeration 选项的 TestStand 枚举 '%1' 不能分配给具有浮点表示（双精度、单精度或扩展精度）的 LabVIEW Ring 控件。Flags 应该是整数类型。"
FLAG_ENUMS_DO_NOT_SUPPORT_FLOATING_POINT_TYPES_OUTPUT = "LabVIEW 环形指示器具有浮点表示法（双精度、单精度或扩展精度），不能分配给设置了 Flags Enumeration 选项的 '%1' 枚举。Flags 应该是整数类型。"
PARAMETER_EXPRESSION_VALIDATION_FAILED = "由于以下错误，参数表达式验证失败：\n"
INCORRECT_ARGUMENT_TO_ENUM = "枚举参数只能接受数字、字符串或 TestStand 枚举类型的参数。"

COMPLEX_ARG_ALL_OR_NOTHING = "对于复数，您必须为 '%1' 指定实部和虚部。"

CANNOT_ASSIGN_VARIANT_TO_TYPE = "无法将变体分配给非容器类型的实例。\n将 '%1' 的类型更改为容器。"

EXPANDING_ARRAY_WARNING = "这个数组有超过 %1 个元素（有 %2 个）。\n构建元素可能需要很长时间。\n你想继续吗？"

WAVEFORM_ARRAY_DIMENSION_ERROR = "波形数组只需要一维数组。"
WAVEFORM_ARRAY_DIMENSION_WARNING = "参数 '%1' 是多于一维的波形数组。\n波形数组只需要一维数组。\n该参数导致运行时错误，并且 TestStand 禁用波形参数。"
ANALOG_WAVEFORM_INTERFACE_ERROR = "无法找到模拟波形接口。"
DIGITAL_WAVEFORM_INTERFACE_ERROR = "无法找到数字波形接口。"
INVALID_WAVEFORM_ATTRIBUTES_TYPE = "波形属性参数需要一个容器数组作为类型。"
EMPTY_ATTRIBUTE_NAME = "波形属性名称不能为空。"
INVALID_WAVEFORM_TIME_STAMP = "波形 t0 的时间戳必须具有有效值（具有'%1'）。"

IO_REFERENCE_NOT_SUPPORTED_ERROR = "您必须使用 LabVIEW 2013 SP1 或更高版本才能使用 LabVIEW I/O 引用。"
INVALID_DOT_NET_REFERENCE = ".NET 引用参数返回无效/空引用。如果 LabVIEW 无法加载指定的 .NET 类型及其所有依赖项，则可能会发生这种情况。"
LVCLASS_NOT_SUPPORTED_IN_EDIT_SUBSTEP = "当 VI 作为运行序列的一部分执行时，TestStand 仅支持使用 LabVIEW 类引用参数执行 VI。此错误可能发生在编辑子步骤和 OnNewStep 自定义子步骤中调用的代码模块，因为它们不作为序列的一部分执行执行。\n\n为防止此错误，您必须在将引用存储到 TestStand 变量之前将 LabVIEW 类引用序列化为字符串参数。"

CREATE_TYPE_FROM_CLUSTER_DLG_CAPTION = "从集群创建/更新自定义数据类型"
PURPOSE_LABEL = "使用此对话框根据您选择的 LabVIEW 集群创建或更新 TestStand 自定义数据类型。"

CREATE_RADIO_BUTTON_LABEL = "创建新类型"
UPDATE_RADIO_BUTTON_LABEL = "更新现有类型"

TYPE_NAME_LABEL = "类型名称："
CREATE_TYPE_IN_FILE = "创建自定义数据类型&In 文件："
UPDATE_TYPE_IN_FILES = "更新文件中的自定义数据类型："
FORCE_EXACT_MATCH = "强制完全匹配"
SELECTED_SEQ_FILE = " -- <选定的序列文件>"
TYPE_IN_MULTIPLE_FILES = "<多个文件>"
TYPE_FILE_NOT_FOUND = "<找不到文件>"

DUPLICATE_PROPERTY_NAMES_TITLE = "找到重复的属性名称"
DUPLICATE_PROPERTY_NAMES_1 = "在 '%1' 中找到以下重复的属性名称：\n"
DUPLICATE_PROPERTY_NAMES_2 Line0001= "\nTestStand 属性名称不区分大小写。标签 Element 和 ELEMENT\n指的是同一属性。\n\n"
DUPLICATE_PROPERTY_NAMES_2 Line0002= "在创建自定义数据类型之前，所有属性名称必须是唯一的。\n"

DUPLICATE_LABELS_TITLE = "找到重复的标签"
DUPLICATE_LABELS_1 = "发现以下重复的前面板端子标签\n连接到 VI 连线板：\n"
DUPLICATE_LABELS_2 Line0001= "\n连接到 VI 连接器的重复前面板端子标签\n面板会导致意外行为。\n使用唯一标签。"
DUPLICATE_LABELS_FOUND_LOAD = "无法加载 VI '%1'，因为重复的\n 前面板端子标签连接到连线板。\n\n本地 LabVIEW 版本不支持运行带有重复端子标签的远程 VI。\n"
EMPTY_LABELS_TITLE = "找到空标签"
EMPTY_LABELS = "在连接到 VI 接线板的前面板端子中发现一个或多个空标签。LabVIEW 要求连接到 VI 连接板的所有前面板端子在从 TestStand 调用时都具有非空标签。"
EMPTY_LABEL_FOUND = "无法加载 VI '%1'，因为它的一个或多个参数具有空标签。LabVIEW 要求从 TestStand 调用时所有参数都具有非空标签。"
EMPTY_LABEL = "<空标签>"
LABEL_NOT_APPLICABLE = "<N/A>"
TYPE_NOT_APPLICABLE = "<N/A>"
CREATE_NEW_DATA_TYPE = "<新数据类型>"
INVALID_NAME = "无效名称"
CREATE_NUMBER = "<数字>"

CHANGE_STRING_PASSING = "更改字符串传递"
CHANGE_PROPERTY_TYPE = "更改属性类型"
CHANGE_CLUSTER_ELEMENT_LABEL = "更改星团元素标签"
CHANGE_TESTSTAND_CLUSTER_LABEL = "更改 TestStand 集群标签"
ORIGINAL_NAME="原名："
NEW_NAME="新名称："
CHANGE_SUBPROPERTIES = "改变子属性"
CHANGE_CD_TYPE_SUBPROPERTIES = "更新自定义数据类型：更改子属性"
IGNORE_PROPERTY = "忽略属性"
EXCLUDE_PROPERTY_WHEN_PASSING_CLUSTER = "通过集群时排除属性"
DELETE_PROPERTY = "删除属性"
ADD_PROPERTY = "添加属性"

CUSTOM_TYPE_CREATED_SUCCESSFULLY = "已创建新的自定义数据类型 '%1'。"
CUSTOM_TYPE_UPDATED_SUCCESSFULLY = "自定义数据类型 '%1' 已更新。"
ERROR_CREATING_ENUM_TYPE_IN_CLUSTER = "从 LabVIEW 枚举参数元素 '%1' 创建/更新 TestStand 类型时发生以下错误： \n"

LV_CLASS_DOES_NOT_MATCH = "类型不匹配。LabVIEW 类与 VI 预期的类不匹配。\n\n您不能传递 LabVIEW 基类来调用最初在派生 LabVIEW 类中定义的方法。"
UNABLE_TO_GET_DEFAULT_VALUE = "无法读取参数 '%1' 的默认值。您必须拥有参数的默认值才能继续部分指定的参数。检查参数是否使用 LabVIEW 类引用。您不能部分指定使用的参数LabVIEW 类参考。"
PARTIALLY_SPECIFIED_VI = "由于它是部分指定的，因此需要参数的默认值才能继续。检查参数是否具有 LabVIEW 类引用。不支持部分指定具有 LabVIEW 类引用的参数。"
EXPECTED_LV_CLASS_REFERENCE = "LabVIEW 类对象的预期实例。"
LV_CLASS_REFERENCE_IS_NULL = "对象引用设置为无。"
LV_CLASS_REFERENCE_NOT_VALID = "LabVIEW 类对象在当前 LabVIEW 实例中不再有效。这种情况通常发生在您在运行 TestStand 执行时重新启动 LabVIEW 时。"

NUMBER_OF_DEFAULT_VALS_CHANGED = "\n自上次 TestStand 读取 VI 以来，数组 '%1' 的默认数组元素数从 '%2' 更改为 '%3'。\n使用步骤设置窗格或指定模块对话框中的模块选项卡框以更新默认值。\n"

VI_PATH_IS_DIFFERENT = "内存中已存在相同名称但来自不同路径的 VI。"
VI_CONPANES_DO_NOT_MATCH = "远程 VI 的连线板与本地 VI 的连线板不匹配。"
VI_NAMESPACE_MISMATCH = "VI 的命名空间：'%1' 已更改，无法运行。要运行该 VI，请重新加载 VI 原型。"

REMOTE_VI_PATH_IS_EMPTY = "远程 VI 路径为空。您必须提供路径才能进行远程调用。"

AUTOBUILD_PPL_NOT_SUPPORTED_IF_NO_LV_INSTALLED = "当未安装具有匹配位数的 LabVIEW 开发系统时，无法启用\"在执行开始时自动构建打包项目库\"选项。"
SOURCE_MODULE_LOADED = "始终在打包项目库中运行 VI"
OVERRIDE_MODULE_DESCRIPTION = "模块被覆盖"
OVERRIDE_MODULE_VI = "VI"
OVERRIDE_MODULE_PPL = "打包项目库"
UNABLE_TO_EDIT_OVERRIDE_BINARY_SETTINGS = "为打包项目库配置步骤时无法编辑二进制设置。"
UNABLE_TO_EDIT_OVERRIDE_SOURCE_SETTINGS = "为 VI 配置步骤时无法编辑源设置。"
OVERRIDE_VI_NAMESPACE_MISMATCH = "配置的 VI 和源 VI 不一样。"
OVERRIDE_VI_PPL_NAMESPACE_MISMATCH = "源 VI 和二进制 VI 不同。"
LVPROJECT_FILES_NOT_FOUND = "\nLabVIEW 项目 '%1' 缺少依赖项。在 LabVIEW 中打开 LabVIEW 项目以获得更多详细信息。"

CANT_ENABLE_DEBUGGING = "当使用端口 '%1' 在 LabVIEW Runtime Engine 上启用调试时，LabVIEW 返回了一个错误。已为该 TestStand 实例禁用调试。\n\nLabVIEW 错误：'%2'"

LV_PROJECT_EXTENSION = "lvproj"
BUILDPPL_FAILURE_STRING_TRIM_BLANKS_WINDOWS_REGEX = "(\r\n){3,}"
BUILDPPL_FAILURE_STRING_TRIM_BLANKS_UNIX_REGEX = "(\n){3,}"
BUILDPPL_FAILURE_STRING_TRIM_CLICK_REGEX = "点击。*"
LV_PPL_PROJECT_UNLOAD_ALL_MODULES = "\n如果在加载 LabVIEW 项目后构建打包项目库，在打包项目库中调用 VI 时使用的项目可能会报告文件丢失。您可以调用Unload All Modules? 重新加载 LabVIEW 项目并解决此错误"

;;使用 LabVIEW 面板指定模块对话框的字符串

STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
STEP_CFG_DLG_ADVANCE_SETTINGS_TAB_CAPTION = "高级设置"
STEP_CFG_DLG_SOURCE_MODULE_SETTINGS_TAB_CAPTION = "覆盖模块设置"

;验证覆盖错误
INVALID_OVERRIDE_SETTINGS = "覆盖设置无效。"
INVALID_OVERRIDE_VI_SETTINGS = "覆盖 VI 设置无效。"
INVALID_OVERRIDE_PPL_SETTINGS = "覆盖打包项目库设置无效。"
INVALID_OVERRIDE_VI_WITH_STEP = "覆盖 VI 设置与步骤模块设置不匹配。源 VI 路径应指定与 VI 路径中指定的相同 VI。"
INVALID_OVERRIDE_PPL_WITH_STEP = "覆盖打包项目库设置与步骤模块设置不匹配。打包项目库 VI 路径应指定与 VI 路径中指定的相同 VI。"
INVALID_OVERRIDE_VI_WITH_PPL = "指定的打包项目库 VI/类路径与构建规范确定的输出打包项目库 VI/类路径不匹配。"
INVALID_OVERRIDE_PPL_WITH_STEP_VI = "需要指定源设置才能使用打包项目库。"
MULTIPLE_OVERRIDE_ERRORS = "覆盖设置中发现多个错误"
INVALID_OVERRIDE_VI_WITH_STEP_PPL = "打包项目库 VI 名称和源 VI 名称应该匹配"

DEV = "开发系统"
RTE = "运行时引擎"
REMOTE="远程"

[CREATE_OR_UPDATE_TESTSTAND_ENUM_FROM_ADAPTER]
DIALOG_TITLE = "从枚举创建/更新自定义数据类型"
DEFAULT_VALUE_INFO = "(*) 表示默认枚举器值"
INVALID_NAME = "无效名称"
INVALID_STRING_VALUE = "<无效>"
ERROR_CREATING_OR_UPDATING_ENUM_TYPE = "创建/更新 TestStand 类型时发生以下错误。\n\n"

;;创建页面
CREATE_CAPTION = "根据来自适配器的枚举创建一个 TestStand 枚举数据类型。"
TYPE_NAME_LABEL = "类型&名称："
CREATE_TYPE_IN_FILE = "在文件中创建自定义数据类型："
SELECTED_SEQ_FILE = " -- <选定的序列文件>"
CREATE_BUTTON_LABEL = "创建&创建"
UPDATE_BUTTON_LABEL = "更新(&P)"

;;更新页面
UPDATE_CAPTION = "根据来自适配器的枚举更新 TestStand 枚举数据类型。"
SELECT_TYPE_LABEL = "选择&类型："
NO_TYPES_TO_UPDATE = "没有要更新的自定义数据类型。"

;;列标题
ITEMS_COLUMN = "物品"
VALUES_COLUMN = "值"
NEW_VALUES_COLUMN = "新值"
OLD_VALUES_COLUMN = "旧值"

;;错误字符串
ERROR = "从枚举对话框创建/更新自定义数据类型时出错。请联系 National Instruments 以获得支持。"
ENUM_TYPE_CREATED_SUCCESSFULLY = "一个新的枚举类型已经创建：%1"
ENUM_TYPE_UPDATED_SUCCESSFULLY = "枚举类型已更新。类型名称：%1"
ERROR_DIALOG_TITLE = "错误"

;; Python 特定的字符串
SELECT_PYTHON_MODULE_LABEL = "Python 模块路径："
SELECT_PYTHON_ENUM_LABEL = "从 Python 模块中选择一个枚举："

[CREATE_CLUSTER_DIALOG]
CREATE_RADIO_BUTTON_LABEL = "创建新类型"
UPDATE_RADIO_BUTTON_LABEL = "更新现有类型"
TYPE_NAME_LABEL = "类型&名称："
CREATE_TYPE_IN_FILE = "创建自定义数据类型&In 文件："
FORCE_EXACT_MATCH = "强制完全匹配"
CLUSTER_CREATE_BTN_LABEL = "创建&创建"
TESTSTAND_NAME_COLUMN = "测试站名称"
TESTSTAND_TYPE_COLUMN = "测试台类型"
SELECTED_SEQ_FILE = "-- <选定的序列文件>"
INVALID_NAME = "无效名称"
CUSTOM_TYPE_CREATED_SUCCESSFULLY = "已创建新的自定义数据类型 '%1'。"
CUSTOM_TYPE_UPDATED_SUCCESSFULLY = "自定义数据类型 '%1' 已更新。"
UPDATE_TYPE_IN_FILES = "更新文件中的自定义数据类型："
CLUSTER_UPDATE_BTN_LABEL = "升级&pdate"
TYPE_IN_MULTIPLE_FILES = "<多个文件>"
TYPE_FILE_NOT_FOUND = "<找不到文件>"
FORCE_EXACT_MATCH_WILL_DELETE_VALUES = "强制完全匹配将覆盖对话框中的当前值。您确定要继续吗？"
INVALID_STRING_VALUE = "<无效>"
CREATE_NEW_DATA_TYPE = "<新数据类型>"
ARRAY_OF = "数组"
CHANGE_CD_TYPE_SUBPROPERTIES = "更新自定义数据类型：更改子属性"
CHANGE_SUBPROPERTIES = "改变子属性"
IGNORE_PROPERTY = "忽略属性"
DELETE_PROPERTY = "删除属性"
ADD_PROPERTY = "添加属性"
MOVE_PROPERTY = "移动属性"
INCLUDE_PROPERTY = "包含属性"
NO_ACTION_NOTHING_CHANGED = "没有行动/没有改变"
CREATE_NUMBER = "<数字>"
EMPTY_LABEL = "<空标签>"
ORIGINAL_NAME = "原名："
NEW_NAME = "新名称："
TYPE_NOT_APPLICABLE = "<N/A>"
DUPLICATE_PROPERTY_NAMES_1 = "在 '%1' 中找到以下重复的属性名称：\n"
DUPLICATE_PROPERTY_NAMES_2 = ""
DUPLICATE_PROPERTY_NAMES_TITLE = "找到重复的属性名称"
UNSUPPORTED_TYPE_FOUND = "不支持的类型 '%1' 阻止打开创建自定义数据类型对话框。"

[LVNXG_ADAPTER]
MINIMUM_SUPPORTED_LVNXG_VERSION = "5.1"
MAXIMUM_SUPPORTED_LVNXG_VERSION = "5.1"
LV_NXG_DEVSYSTEM_TARGET = "开发系统"
LV_NXG_THISCOMPUTER_TARGET = "这台电脑"
LVNXG_NOT_INSTALLED = "TestStand 无法找到此计算机上安装的 LabVIEW NXG 开发系统的兼容版本 (%1)。\n"
NEED_LVNXG_VERSION_XX = "TestStand 需要 LabVIEW NXG 版本 %1。\nTestStand 无法连接到 LabVIEW NXG。"
ADAPTER_NOT_SUPPORTED_IN32BIT = "32 位 TestStand 不支持 LabVIEW NXG 适配器。"
NO_LONGER_SUPPORTED_ERROR_PROVIDER_MSG = "32 位 TestStand 不支持 LabVIEW NXG 适配器。\n该模块在加载或执行时将报告错误。"
ERROR_BUILD_COMPONENT = "无法构建组件"
LVNXG_DEV_SYSTEM = "LabVIEW NXG"
PROJECT_FILES_MSG = "LabVIEW NXG 项目文件"
GLL_FILES_MSG = "LabVIEW NXG 组件文件"
PROJECT_BROWSE_TITLE = "为步骤选择 LabVIEW NXG 项目文件"
GLL_BROWSE_TITLE = "为步骤选择 LabVIEW NXG GLL 文件"
STRING_BINARY = "二进制字符串"
STRING_ASCII = "ASCII 字符串"
ERROR_LOADING_LVNXGVI = "LabVIEW NXG 在从 '%2' 加载 '%1' 时报告错误。项目中可能缺少 VI。\n"
ERROR_LOADING_GVI_FROM_PROJECT = "在项目 '%2' 中找不到 '%1'。项目中可能缺少 VI。\n"
ERROR_LOADING_LVNXGVI_FROM_GLL = "无法在 GLL '%2' 中找到 VI，'%1'。"
ERROR_ADDING_LVNXGVI_TO_PROJECT = "LabVIEW NXG 在将 '%1' 添加到 '%2' 时报告错误。"
LVNXG_REPORTED_ERROR = "LabVIEW NXG 错误详情：\n"
ERROR_LOADING_FILE = "从磁盘读取文件信息时出错。文件路径：'%1'\n"
ERROR_WHEN_CALLING_LVNXG_COM_INTERFACE = "调用 LabVIEW NXG 的 COM 接口时发生错误\n"
NULL_REFERENCE_PASSED_IN = "传入此方法的参数为空。"
LVNXGVI_ABSOLUTE_QUALIFIED_NAME_IS_EMPTY = "无法解析 VI 的绝对限定名称。\n TestStand 只能加载存在于组件中的 VI。确保 VI 存在于指定的组件和目标下以修复任何错误。"
LVNXGVI_ABS_COMPONENT_NAME_IS_EMPTY = "组件的绝对限定名是空的。"
INVALID_PATH = "VI 路径无效。"
MUST_HAVE_GVI_EXT = "模块路径中的文件名必须使用 .gvi 扩展名，以便 TestStand 创建 VI。"
CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'。"
PROJECT_EMPTY = "项目路径不能为空"
GLL_EMPTY = "GLL 路径不能为空"
LVNXGVI_QUALIFIED_NAME_EMPTY = "VI限定名不能为空"
RTE_NOT_LOADED_ENGINE_SHUTTING_DOWN = "无法加载 LabVIEW NXG 运行时引擎，因为 TestStand 引擎正在关闭。"
PROJECT_INCORRECT_FORMAT = "指定的项目路径 '%1' 不是有效的 LabVIEW NXG 项目"
GLL_INCORRECT_FORMAT = "指定的 gll 路径 '%1' 不是有效的 LabVIEW NXG GLL"
LVNXGVI_INTERACTIVE_STRING = "交互式"
GLL_MISMATCH_RTE = "所选组件的输出 GLL 路径与配置的 gll 路径不匹配。\n单击此处清除配置的项目和模块限定名称。"
GLL_MISMATCH_DEV = "所选组件的输出 GLL 路径与配置的 GLL 路径不匹配。\n单击此处清除配置的 GLL。"
SHOW_FRONT_PANEL_VALUE_ERROR = "一个步骤可以设置 LabVIEWNXGModuleOptions_ShowFrontPanelModal 或 LabVIEWNXGModuleOptions_ShowFrontPanelModeless，但不能同时设置两者。"
UNSUPPORTED_ATTRIBUTE_TYPE = "不支持为此参数指定类型的波形属性。\n"
INVALID_PROPERTY_NODE_PARAMETERS = "项目路径和 VI 限定名不能为空"
ERROR_CREATING_PROPERTY_NODE = "创建属性节点 VI 失败"
ERROR_LOADING_NODE_LIBRARIES = "加载节点库失败"
ERROR_LOADING_NODE_CLASSES = "加载节点类失败"
ERROR_LOADING_NODE_PROPERTIES = "加载节点属性失败"


;;各种枚举类型的字符串。
PARAMETER_DIRECTION_IN = "In"
PARAMETER_DIRECTION_OUT = "Out"
PARAMETER_DIRECTION_DEFAULT = "默认"

ARRAY_DIMENSIONS = "%1D "
ARRAY = "数组 (%1)"

COULD_NOT_LOAD_LVNXGVI = "TestStand 无法加载 VI。"

SPEC_MOD_DLG_USING_CONFIG_VALUE = "<使用配置值>"
SPEC_MOD_DLG_OR = " 或 "
SPEC_MOD_DLG_VALUE = " [值：%1]"
SPEC_MOD_DLG_UNSPECIFIED_VALUE = "<未指定>"

BUILD_CONFIGURATION_OVERRIDE_DEFAULT = "使用默认配置，因为未找到适配器配置"
BUILD_CONFIGURATION_OVERRIDE = "构建配置已被适配器设置覆盖"

PARAMETERS_ADDED_MSG = "添加了以下参数：\n"
PARAMETERS_DELETED_MSG = "以下参数已删除：\n"
PARAMETERS_VERIFY_ARG_VALUES = "验证新参数具有正确的参数值。"

STEP_DESC_UNSPECIFIED_ARG = "'??? <未知值>"

;创建lvnxg vi
MODULE_BROWSE_TITLE = "为步骤选择代码模块"
LVNXGVI_FILES_MSG = "VI 文件"
FILE_ALREADY_EXISTS = "你指定的文件已经存在"

;;集群传递
CLUSTER_PROP_PAGE_TITLE = "集群通过"
ALLOW_CLUSTER_PASSING_LABEL = "允许这种类型的对象作为 LabVIEW NXG 簇传递(&Y)"
CLUSTER_PROP_LABEL = "属性："
CLUSTER_PROP_GROUPBOX_LABEL = "属性的内存布局"
CLUSTER_PROP_TYPE_LABEL = "类型："
CLUSTER_PROP_BINARY_STRING_LABEL = "是二进制字符串"
CLUSTER_MEMBER_LABEL = "集群项目&标签："
CLUSTER_PROP_EXCLUDE_LABEL = "通过集群时排除&x"
CLUSTER_MEMBER_NOT_ALLOWED_MESSAGE = "你不能在集群中包含指定的成员。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0001 = "该簇不能包含指定的成员，因为您不能将该类型的对象作为 LabVIEW NXG 中的簇传递。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_MESSAGE Line0002 = "您必须打开对象类型的属性表并启用\"允许此类型的对象作为 LabVIEW NXG 簇传递\"选项。"
CLUSTER_MEMBER_TYPE_NOT_ALLOWED_TITLE = "不能包括集群成员"
TESTSTAND_NAME_COLUMN = "测试站名称"
LABVIEW_LABEL_COLUMN = "LabVIEW NXG 标签"
TESTSTAND_TYPE_COLUMN = "测试台类型"
LABVIEW_TYPE_COLUMN = "LabVIEW NXG 类型"
UPDATE_ACTION_COLUMN = "集群映射操作"
CLUSTER_CREATE_BTN_LABEL = "创建&创建"
CLUSTER_UPDATE_BTN_LABEL = "升级&pdate"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL = "要启用此属性页上的控件，打开包含此属性的类型的属性表并启用"允许此类型的对象作为 LabVIEW NXG 集群传递"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL2 = "这是一个类型的实例。类型定义阻止您将其作为簇传递。要更改设置，打开类型定义的属性表并启用\"允许此类型的对象作为簇传递LabVIEW NXG 集群\"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL3 = "这是一个类型的实例。要修改它的属性，请打开类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL4 = "这个属性是一个类型的实例。要修改它的值，打开包含这个属性的类型定义的属性表。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL5 = "您不能将此容器属性作为集群传递。要更改设置，请打开容器属性父级的属性表并禁用"传递集群时排除"选项。"
SUBPROP_ALLOW_CLUSTER_PASSING_LABEL6 = "您不能将此属性的父项之一作为集群成员传递。要启用此属性页上的控件，请打开父项的属性表并禁用"传递集群时排除"选项。"

ARRAY_ELEMENT_NOT_MATCHING_CLUSTER = "数组 '%1' 的元素与 LabVIEW NXG 簇不匹配，或者在数组元素类型定义中禁用了簇传递。"
ELEMENT_NOT_MATCHING_CLUSTER = "'%1' 的类型与 LabVIEW NXG 簇 '%2' 不匹配，或者在 '%3' 的类型定义中禁用了簇传递。"
NO_MATCHING_FIELD_IN_TYPEDEF_WITH_ARG = "对于簇元素 '%3'，'%2' 类型的参数 '%1' 中没有对应的子属性"
CLUSTER_FIELD_WRONG_TYPE = "属性 '%1' 的类型与元素 '%2' 的簇定义不兼容。"
TYPE_NOT_VALID_FOR_ARRAY_OF_CLUSTERS = "参数 '%1' 的类型对于簇数组无效。该类型必须是与 LabVIEW NXG 簇对应的自定义数据类型的数组，并且必须配置为支持 LabVIEW NXG 簇传递。 "

;;创建集群类型对话框
CREATE_TYPE_FROM_CLUSTER_DLG_CAPTION = "从集群创建/更新自定义数据类型"
PURPOSE_LABEL = "使用此对话框根据您选择的 LabVIEW NXG 集群创建或更新 TestStand 自定义数据类型。"
G_ADP_MSG_TITLE = "LabVIEW NXG 适配器消息"
CHANGE_PROPERTY_TYPE = "更改属性类型"
CHANGE_CLUSTER_ELEMENT_LABEL = "更改星团元素标签"
CHANGE_TESTSTAND_CLUSTER_LABEL = "更改 TestStand 集群标签"
EXCLUDE_PROPERTY_WHEN_PASSING_CLUSTER = "通过集群时排除属性"

;;适配器配置
ADP_CFG_CAPTION = "LabVIEW NXG 适配器配置（抢先体验）"
ADP_CFG_SELECT_SERVER_HDR = "选择要使用的 LabVIEW NXG 服务器"
ADP_CFG_RTE_NUMBER_THREADS_LABEL = "线程数(&M)："
ADP_CFG_RTE_USE_MULTIPLE_THREADS_CHECKBOX = "使用多线程执行'与调用者相同'VIs(&X)"
ADP_CFG_RTE_THREADS_INHERIT_CPU_AFFINITY_CHECKBOX = "附加线程(&I)继承调用线程的 CPU 关联性"
ADP_CFG_NUM_RTE_THREADS_DEFAULT = "默认 (%1)"
ADP_CFG_INFO_TEXT = "(直到您下次启动 TestStand 应用程序时，更改才会生效。.)"
LVNXG_DEV = "LabVIEW NXG 开发系统版本：%1"
LVNXG_DEV_RTE = "（仅限 RTE）"
LVNXG_RTE = "LabVIEW NXG &运行时引擎"
ADP_CFG_AUTO_BUILD_GLL_CHECKBOX = "在执行开始时自动构建缺失或过时的 &GLL"
ADP_CFG_VALIDATE_GLL_PATH = "验证 GLL 路径"
ADP_CFG_DISABLE_EARLY_ACCESS_CHECKBOX = "禁用早期访问警告对话框"
ADP_CFG_SETTINGS = "适配器设置"
VERSION = "版本:"
OK = "确定"
HELP = "帮助"
CANCEL = "取消"
EARLY_ACCESS_CAPTION = "TestStand 2020 为 LabVIEW NXG 提供早期访问支持"
EARLY_ACCESS_TEXT = "TestStand 2020 为 LabVIEW NXG 提供有限功能的早期访问支持。National Instruments 建议您在将 LabVIEW NXG 用于 TestStand 系统之前对其进行全面评估。请注意以下限制："
EARLY_ACCESS_TEXT_OPTION_1 = "TestStand 2020 不支持 LabVIEW NXG 类。"
EARLY_ACCESS_TEXT_OPTION_2 = "无法从 VI 调用 LabVIEW NXG GLL。当尝试在大型 LabVIEW NXG/TestStand 架构中重用已编译代码时，这可能会影响系统。"
EARLY_ACCESS_TEXT_OPTION_3 = "TestStand 调试从 LabVIEW NXG 调用并在运行时引擎上执行的 GLL 的能力有限。要调试，用户将需要重建 GLL。"
EARLY_ACCESS_DO_NOT_SHOW_CHECKBOX = "不再显示此对话框(&S)"
MORE_DETAILS = "更多详情..."

;;使用 LabVIEW NXG 面板指定模块对话框的字符串
SPEC_MOD_DLG_CAPTION = "编辑 LabVIEW NXG VI 调用"
STEP_CFG_DLG_MODULE_TAB_CAPTION = "模块"
STEP_CFG_DLG_ADVANCE_SETTINGS_TAB_CAPTION = "高级设置"
STEP_CFG_DLG_GLL_SOURCE_CODE_TAB_CAPTION = "GLL 源代码"

;;复数
COMPLEX_DISPLAY = "(%1) + (%2)i"

;;I/O 引用
IO_DEVICE_NAME = "设备名称"
IO_SESSION_NUMBER = "会话编号"

LV_NXG_RT_DLL_NOT_FOUND = "TestStand 无法找到兼容的 LabVIEW NXG 运行时引擎。确保计算机上安装了版本 %1 的 LabVIEW NXG 运行时引擎。\n"
INCORRECT_QUALIFIED_NAME_FORMAT = "指定的绝对限定名称应采用以下格式：'<Target>:<ComponentName>.gcomp:<VIQualifiedName>'。示例：PC:TestSignals.gcomp:Aquire:GetSignalData.gvi。\n不在组件中，格式为 <Target>:<VIQualifiedName>"
LVNXGVI_TARGET_CANNOT_BE_EMPTY = "VI 目标不能为空。\n"
FAILED_TO_GET_EXEC_CONTEXT = "获取执行 VI 的执行上下文时出错"
LABVIEW_NXG_DEV_SYSTEM = "LabVIEW NXG 开发系统"
FAIL_TO_LOAD_LVNXGVI_IN_DEV = "无法从 %2 加载 VI %1，%3 版本为 %4。"
ERROR_IN_GLL = "从 gll %1 加载项目时出错：%2"
ERROR_CREATING_PARAMETERS = "从 LabVIEW NXG 获取参数信息时发生错误\n"
ERROR_BUILDING_COMPONENT = "从 LabVIEW NXG 构建组件时发生错误。检查 LabVIEW NXG 应用程序生成器许可证是否已激活。使用 TestStand 许可证激活 LabVIEW NXG 应用程序生成器。\n"
ERROR_CREATING_PROPERTYNODE = "在 LabVIEW NXG 中创建属性节点时发生错误\n"
INVALID_TYPE = "参数 '%1' 的 LabVIEW NXG 参数信息属于非预期类型。"
CLUSTER = "簇"
COMPLEX = "复杂"
VARIANT = "变体"
UNABLE_TO_GET_DEFAULT_VALUE = "无法读取参数 '%1' 的默认值\n"
UNABLE_TO_GET_PARAMETER_RUNTIME_DATA = "无法获取参数 '%1' 的执行数据\n"
UNABLE_TO_GET_PARAMETER_RUNTIME_DATA_COLLECTION = "无法从 LabVIEW NXG 获取参数执行数据\n"
PARTIALLY_SPECIFIED_LVNXGVI = "由于它是部分指定的，因此需要参数的默认值才能继续。检查参数是否具有 LabVIEW NXG 类引用。不支持部分指定具有 LabVIEW NXG 类引用的参数。"
PARAMETER = "参数 %1:\n%2"
ERROR_IN_DEFAULT_VALUES_PARAMETERS = "获取 VI 参数的默认值时发生错误"
LV_NXG_LOST_CONNECT = "失去与 LabVIEW NXG 服务器的 ActiveX 连接。LabVIEW NXG 适配器将尝试在下一次执行尝试时重新连接。"
STEP_DESC_ALWAYS_USE_RTE = "始终使用运行时引擎运行"
BUILD_CONFIG_EMPTY = "未找到有效的构建配置。指定的 VI 必须属于一个组件，并且该组件应该至少有一个输出 G 库的构建配置。"
GLLPATH_MISMATCH_WITH_BUILD_CONFIG_PATH = "在步骤 '%1' 中指定的 G 库与默认构建配置的输出路径不匹配。\n 默认构建配置：'%2'\n 构建配置输出路径：'%3' "
GLLPATH_CHANGED_WARNING = "重新加载 VI 原型已更改 GLL 路径。\n旧 GLL 路径：'%1'\n 当前 GLL 路径：'%2'"
SOURCE_CHANGED_WARNING = "来源信息已被删除"
GLL_NOT_BUILT = "在磁盘上找不到指定的 G 库文件。构建 G 库以在 LabVIEW NXG 运行时中执行模块"
GLL_NOT_SPECIFIED = "未指定执行此步骤所需的 GLL。\n如果机器上存在受支持的 LabVIEW NXG 开发系统并且在该步骤中指定了项目和模块限定名称，您可以重新加载该步骤以自动填充 GLL小路。"
BUILD_COMPONENT_FAILED = "无法构建所选的 LabVIEW NXG 组件。检查 LabVIEW NXG 应用程序生成器许可证是否已激活。使用 TestStand 许可证激活 LabVIEW NXG 应用程序生成器。附加信息：'%1'"
BUILD_NOT_INSIDE_COMPONENT = "选定的 VI 不在组件中"
COMPONENT_TARGETED_TO_SOURCE_OUTPUT = "所选组件的子类型设置为'源'。TestStand 只能在运行时引擎中加载和执行 GLL。要解决此问题，请将已配置组件的子类型更改为'GLL'。\n"
CURRENT_GLL_PATH = "当前 GLL 路径：'%1'\n"
COMPONENT_NAME_MISMATCH = "组件名称不匹配。\n 预期组件名称：'%1'，当前组件名称：'%2' "
INVALID_PROJECT_GLL_QUALIFIEDANME = "指定的项目或 gll 路径无效"
COM_ERROR_WHILE_PACKING_PARAM = "LabVIEW NXG COM 接口在将数据复制到参数时出错：来自 TestStand 的 %1"
COM_ERROR_WHILE_UNPACKING_PARAM = "LabVIEW NXG COM 接口在从参数复制数据时出错：%1 到 TestStand"

UNABLE_TO_EDIT_LV_NXG_PRJ_NOT_FOUND = "无法找到此步骤的 LabVIEW NXG 项目文件。确保 LabVIEW 项目文件存在于磁盘上。"
UNABLE_TO_LOAD_VI_IN_RTE = "在 labVIEW NXG Runtime Engine 中加载 %1 失败。\nVI 可能被破坏，因为另一个 GLL 与这个或它的一个依赖项同名，可能已经加载到内存中。这会导致交叉链接中断VI。"
RUN_TIME_CANNOT_LOAD_LVNXGVI_EXPRESS_OR_PROPNODE_INFO = "- 配置 LabVIEW NXG 适配器以使用 LabVIEW NXG 开发系统，然后从 TestStand 工具菜单运行'更新 VI/LV NXG VI 调用'。
LV_NXG_DEV_SYSTEM = "LabVIEW NXG 开发系统"
LVNXGVI_IS_BROKEN = "无法在 %2 中加载 VI %1，因为 VI 已损坏。\n\n可能缺少 VI 依赖项。"
INVALID_PROJECT_PATH = "项目路径无效。"
PROJECT_CREATE_TITLE = "选择要为步骤创建的 LabVIEW NXG 项目文件"
MUST_HAVE_LV_NXG_PRJ_EXT = "项目路径中的文件名必须使用 .lvproject 扩展名，以便 TestStand 创建 LabVIEW NXG 项目。"
NOT_RESPONDING = "LabVIEW NXG 没有响应"
ERROR_LOADING_PROTOTYPE = "加载 VI 原型时发生错误"
LOAD_PROJECT_FAILED = "打开 LabVIEW NXG 项目失败"
GLL_IS_STALE = "GLL，'%1'，在磁盘上有内存中不存在的更改。卸载所有模块以从更新的 GLL 中获取最新更改。"
NOT_A_PATH = "<不是路径>"

LVNXGVI_PROTOTYPE_CHANGED = "VI '%1' 的原型已更改。\n您必须在执行 VI 之前更新原型。\n使用 TestStand 序列编辑器更新原型。"

UNABLE_TO_LOAD_BROKEN_LVNXGVI_TITLE = "无法使用运行时引擎加载 VI"
EDIT_IN_LV_NXG = "\n\n您想在 LabVIEW NXG 中编辑 VI 吗？"

ERROR_EXPECTED_PATH_DATA_TYPE = "预期路径数组，找到容器数组。"
CANNOT_ASSIGN_VARIANT_TO_TYPE = "无法将变体分配给非容器类型的实例。\n将 '%1' 的类型更改为容器。"
NUMBER_OF_DEFAULT_VALS_CHANGED = "\n自上次 TestStand 读取 VI 以来，数组 '%1' 的默认数组元素数从 '%2' 更改为 '%3'。\n使用步骤设置窗格或指定模块对话框中的模块选项卡框以更新默认值。\n"
ARRAY_DIMENSIONS_ERROR = "数组参数 '%2' 需要 '%1' 维度，但收到 '%3' 维度。"
IMAGINARY = "虚数"
ARRAY_REAL_IMA_NOT_SAME_SIZE = "复数数组 '%1' 的数组大小不同。\n对于复数数组，实数组和虚数组的大小必须相同。\n\n实数组大小：%2\n虚数组大小: %3"
COMPLEX_ARG_ALL_OR_NOTHING = "对于复数，您必须为 '%1' 指定实部和虚部。"
ERROR_CREATING_SAFEARRAY = "创建安全数组以将参数数据传递给 LabVIEW NXG 时发生错误。\n"
ERROR_OBTAINING_CLUSTER_SAFEARRAY_FROM_LVNXG = "从 COM 接口获取带有簇数组数据的安全阵列时发生错误。安全阵列为空或参数数量与预期不同。"
REAL = "真实"
EMPTY_EXPR_ERROR = "参数 '%1' 的表达式不能为空。"
PARAM_REQUIRED = "必需"
PARAM_RECOMMENDED = "推荐"
PARAM_OPTIONAL = "可选"
UNKNOWN_TYPE = "未知"
STRING_PATH = "路径"
STRING_TIMESTAMP = "时间戳"
CLUSTERS = "簇数组"
COMPLEXNUMS = "复数数组"
VARIANTS = "变体数组"
IO = "IO"
DIGITAL_DATA = "数字数据"
ANALOG_WAVEFORM = "模拟波形"
DIGITAL_WAVEFORM = "数字波形"
DYNAMIC_DATA = "动态数据"
DOTNETREF = ".NET 对象"
LVOBJECT = "LabVIEW NXG 对象"
OTHER = "LabVIEW NXG 参考"
LVCLASS = "LabVIEW NXG 类"
UNABLE_TO_GET_DEFAULT_VALUE_FOR_LVNXGVI = "无法使用 LabVIEW NXG 运行时引擎获取 VI '%1' 的默认值。"
ANALOG_WAVEFORM_INTERFACE_ERROR = "无法找到模拟波形接口。"
DIGITAL_WAVEFORM_INTERFACE_ERROR = "无法找到数字波形接口。"
INVALID_WAVEFORM_TIME_STAMP = "波形 t0 的时间戳必须具有有效值（具有'%1'）。"
INVALID_STRING_VALUE = "<无效>"
INVALID_WAVEFORM_ATTRIBUTES_TYPE = "波形属性参数需要一个容器数组作为类型。"
EMPTY_ATTRIBUTE_NAME = "波形属性名称不能为空。"
ERROR_CREATING_ENUM_TYPE_IN_CLUSTER = "从 LabVIEW NXG 枚举参数元素 '%1' 创建/更新 TestStand 类型时发生以下错误：\n"

BAD_OBJECT = "传递了错误的对象类型"
UNKNOWN_PARAMETER_TYPE = "未知参数类型"
UNSUPPORTED_REFERENCE_TYPE = "不支持的引用类型"
UNKNOWN_NUMERIC_TYPE = "未知的数字类型"
INVALID_COMPLEX_TYPE = "无效的复杂数字类型"
INVALID_ARRAY_TYPE = "无效的数组类型"
UNKNOWN_ARRAY_TYPE = "未知数组类型"
UNKNOWN_CONTAINER_TYPE = "未知容器类型"
FOUND_ARRAY_IN_ARRAYS = "找到一个数组数组"
ERROR_SET_DEFAULT_VALUE_ARRAY_ELEMENT = "从 LabVIEW NXG 获取默认值时发生以下错误"
PROTOTYPE_CHANGED = "原型已更改"

INT8 = "I8"
UINT8 = "U8"
INT16 = "I16"
UINT16 = "U16"
INT32 = "I32"
UINT32 = "U32"
INT64 = "I64"
UINT64 = "U64"
REAL32 = "SGL"
REAL64 = "DBL"
EXT = "EXT"
ANYTHING_TYPE = "任何"

UNABLE_TO_CREATE_XML_PARSER = "无法创建 XML 解析器。\n无法解析 VI 原型。"
ELEMENT = "元素"
WAVEFORM_ARRAY_DIMENSION_WARNING = "参数 '%1' 是多于一维的波形数组。\n波形数组只需要一维数组。\n该参数导致运行时错误，并且 TestStand 禁用波形参数。"

FAIL_TO_LOAD_LVNXGVI_RTE = "无法在 LabVIEW NXG 运行时引擎中加载 VI '%1'。"

LV_NXG_AUTO_NOTREG = "'%1' ActiveX 自动化服务器未在此计算机上注册。"
LV_NXG_LAUNCH_FAILED = "无法启动 '%1' ActiveX 自动化服务器。"
LV_NXG_LAUNCH_FAILED_ADDITIONAL_DESCRIPTION = "CoCreateInstance 返回'%1'：\n%2"

ERROR_LOADING_TS_PLUGIN = "加载 LabVIEW NXG 所需的组件时发生错误。\n"
ERROR_PROJECT_LOADING = "加载 LabVIEW NXG 项目时出错。项目路径：%1\n"
ERROR_CREATING_PROJECT = "在该路径创建 LabVIEW NXG 项目时出错：%1\n"
ERROR_CLOSING_PROJECT = "关闭 LabVIEW NXG 项目 %1 时发生错误\n"

LV_NXG_CLASS_DOES_NOT_MATCH = "类型不匹配。LabVIEW NXG 类与 VI 预期的类不匹配。\n\n您不能传递基本 LabVIEW NXG 类来调用最初在派生 LabVIEW NXG 类中定义的方法。"
ERR_COMMUNICATING_WITH_LV_NXG Line0001 = "尝试访问 LabVIEW NXG 开发系统时发生错误。验证 LabVIEW NXG 中的以下 VI 服务器设置（工具->选项：VI 服务器：配置）：\n"
ERR_COMMUNICATING_WITH_LV_NXG Line0002 = "在协议部分，启用 ActiveX。\n在可访问服务器资源中，启用 VI 属性和方法以及应用程序方法和属性选项。\n"
ERR_COMMUNICATING_WITH_LV_NXG Line0003 = "确保 VI 服务器授予对导出 VI 列表中所有 VI 的访问权限。"
LV_NXG_NOT_INSTALLED = "此操作需要安装支持版本的 LabVIEW NXG 开发系统。"

;;枚举 LV NXG
ELEMENT_NOT_MATCHING_ENUM = "‘%1’的类型与 LabVIEW NXG 枚举‘%2’允许的类型不匹配"
STRING_EMPTY_OR_DUPLICATE_IN = "LabVIEW NXG 枚举的字符串参数不能是重复的枚举器值"
STRING_NOT_VALID_FOR_ENUM = "字符串值 '%1' 必须至少与 LabVIEW NXG 枚举参数 '%2' 的枚举数之一完全匹配。"
FLAG_ENUMS_DO_NOT_SUPPORT_FLOATING_POINT_TYPES = "设置了 Flags Enumeration 选项的 TestStand 枚举 '%1' 无法分配给具有浮点表示（双精度、单精度或扩展精度）的 LabVIEW NXG Ring 控件。Flags 应该是整数类型。 "
TS_ENUMERATOR_DOESNOT_MATCH_LV_ENUM = "TestStand 枚举器 '%1' 与 LabVIEW NXG 枚举参数 '%2' 中的任何枚举器都不匹配\n"
TS_ENUMERATOR_VALUE_DOESNOT_MATCH_LV_ENUM = "枚举器 '%1' 的数值与参数 '%2' 不匹配\n"
FLAG_ENUMS_DO_NOT_SUPPORT_FLOATING_POINT_TYPES_OUTPUT = "LabVIEW NXG Ring 指示器具有浮点表示法（双精度、单精度或扩展精度），不能分配给设置了 Flags Enumeration 选项的 '%1' 枚举。Flags 应该是整数类型。"
TYPE_NOT_VALID_FOR_ENUM = "自定义枚举类型 '%1' 必须与 LabVIEW NXG 枚举参数 '%2' 完全匹配。"
NO_OF_ENUMERATORS_MISMATCH = "类型 '%1' 指定的枚举器数量与 LabVIEW NXG 枚举不同"
ENUMERATORS_MISMATCH_IN_ENUM_TYPE = "'%1' 类型的枚举器与 LabVIEW NXG 枚举的枚举器不匹配"
MISMATCH_IN_ENUMERATOR_VALUE = "枚举数 '%1' 在 TestStand 和 LabVIEW NXG 枚举中的数值不同"
PARAMETER_EXPRESSION_VALIDATION_FAILED = "由于以下错误，参数表达式验证失败：\n"
INVALID_REPRESENTATION_FOR_ENUM = "类型 '%1' 的数字表示与 LabVIEW NXG 枚举 '%2' 的表示不兼容。预期的表示是：%3"


;;自动化适配器

[AUTOMATION_TYPE_LIB_READER]
RETURN_TYPE_NOT_AUTOMATION_COMPATIBLE = "该方法的返回类型与 ActiveX Automation 不兼容。"
METHOD_NOT_AUTOMATION_COMPATIBLE = "该方法与 ActiveX Automation 不兼容。"
PARAMETER_NOT_AUTOMATION_COMPATIBLE = "该方法的一个或多个参数与 ActiveX Automation 不兼容。"
PROPERTY_TYPE_NOT_AUTOMATION_COMPATIBLE = "属性类型与 ActiveX Automation 不兼容。"
TYPE_LIBRARY_NOT_AUTOMATION_COMPATIBLE = "服务器与 ActiveX Automation 不兼容。"
NEWER_TYPE_LIB_VERSION_ALREADY_REGISTERED Line0001 = "此服务器的更新版本已在此计算机上注册。\n"
NEWER_TYPE_LIB_VERSION_ALREADY_REGISTERED Line0002 = "如果你想从 TestStand 使用较早版本的服务器，你必须从这台计算机上卸载较新的版本。\n"
NEWER_TYPE_LIB_VERSION_ALREADY_REGISTERED Line0003 = "你想使用更新版本的服务器吗？"

[AUTOMATION_ADAPTER]
ERR_CANT_CONVERT_VALUE_TO_DATE = "无法将值转换为日期数据类型。"
ERR_CANT_CONVERT_VALUE_TO_CY = "无法将值转换为货币数据类型。"
SERVER_INFO_DLG_CAPTION = "服务器信息"
SERVER_INFO_DLG_OPEN_HELP_FILE = "&帮助"
SERVER_INFO_DLG_NAME = "名称 = "
SERVER_INFO_DLG_PATH = "路径 = "
SERVER_INFO_DLG_HELP_FILE = "帮助文件 = "
SERVER_INFO_DLG_GUID = "GUID = "
SERVER_INFO_DLG_FLAGS = "标志 = "
SERVER_INFO_DLG_LCID = "LCID = "
SERVER_LIST_ITEM_FMT_STRING = "%1（版本 %2）"
METHOD_NOT_TS_COMPAT = "方法 '%1' - 参数 '%2'\n"
PROP_NOT_TS_COMPAT = "属性 '%1'\n"
NOT_TS_COMPAT_MSG Line0001 = "以下成员有参数或返回"
NOT_TS_COMPAT_MSG Line0002 = "与 TestStand 不兼容且不可用的类型 "
NOT_TS_COMPAT_MSG Line0003 = "来自 ActiveX 适配器：\n\n"
NOT_TS_COMPAT_TOO_MANY = "\n\n...实例太多，无法显示所有项目..."
MODULE_DIALOG_TITLE = "编辑 ActiveX/COM 调用"
OBJECT_VARIABLE_LABEL = "对象和参考："
CREATE_OBJECT_LABEL = "&创建对象"
SERVER_LABEL = "自动化服务器:"
RELOAD_LABEL = "重新加载"
CLASS_LABEL = "对象类："
REMOTE_MACHINE_LABEL = "远程主机（可选）："
SPECIFY_BYEXPR_HOST_BTN_LABEL= "为主机指定表达式"
USE_LOAD_SPEC_FOR_LIFETIME_LABEL = "使用分步加载/卸载选项指定对象创建时间和生命周期"
NO_REGISTERED_TYPE_LIBS = "在系统注册表的\nHKEY_CLASSES_ROOT\\TypeLib\\ 项中不存在 ActiveX 自动化服务器。\n使用浏览按钮加载并注册 ActiveX 自动化服务器。"
NO_AUTOMATION_OBJECTS_IN_TYPE_LIB = "该服务器不导出任何 ActiveX 自动化对象。"
NO_TOP_LEVEL_OBJECTS_IN_TYPE_LIB = "此服务器不导出任何顶级 ActiveX 自动化对象。"
DO_CALL_LABEL = "调用方法或访问属性"
MEMBER_TYPE_LABEL = "行动离子："
METHOD_NAME_LABEL = "方法："
PROPERTY_NAME_LABEL = "属性："
PARAMETERs_LIST_LABEL = "参数："
EDIT_PARAMETER_LABEL = "编辑..."
TYPE_LIB_SELECT_DLG_TITLE = "选择类型库"
TYPE_LIBRARY_FILES = "类型库文件"
MEMBER_TYPE_METHOD_NOT_FOUND = "<未找到方法>"
MEMBER_TYPE_PROP_NOT_FOUND = "<未找到属性>"
MEMBER_TYPE_METHOD = "调用方法"
MEMBER_TYPE_GET_PROP = "获取财产"
MEMBER_TYPE_SET_PROP = "设置属性"
MEMBER_TYPE_SET_REF_PROP = "通过引用设置属性"
NO_MEMBERS_IN_CLASS = "此类中不存在任何属性或方法。"
CREATE_TYPE_DO_NOT_CREATE = "不创建"
CREATE_TYPE_NEW = "新建"
CREATE_TYPE_FROM_FILE = "从文件创建"
CREATE_TYPE_USE_EXISTING = "附加到活动"
CREATE_FROM_FILE_BROWSE_TITLE = "为对象选择一个初始化文件"
PARAMETER_LIST_NAME_COLUMN_HEAD = "名称"
PARAMETER_LIST_TYPE_COLUMN_HEAD = "类型"
PARAMETER_LIST_DIRECTION_COLUMN_HEAD = "方向"
PARAMETER_LIST_DEFAULT_COLUMN_HEAD = "默认"
PARAMETER_LIST_LOG_COLUMN_HEAD = "日志"
PARAMETER_LIST_VALUE_COLUMN_HEAD = "值"
RETURN_VALUE_PARAM_NAME = "返回值"
OPTIONAL_PARAMETER_LABEL = "（可选）"
PARAMETER_DIRECTION_IN = "in"
PARAMETER_DIRECTION_OUT = "out"
PARAMETER_DIRECTION_DELIMITER = "/"
PROTOTYPE_CHANGED_KEEP_VALUES_PROMPT Line0001 = "此步骤中的参数与类型库中的参数不匹配。\n"
PROTOTYPE_CHANGED_KEEP_VALUES_PROMPT Line0002 = "自从您上次配置该步骤后，服务器可能已更改。\n"
PROTOTYPE_CHANGED_KEEP_VALUES_PROMPT Line0003 = "你想保留参数值吗？"
PROTOTYPE_CHANGED_NO_NEW_PARAMS Line0001 = "此步骤中的参数与类型库中的参数不匹配。\n"
PROTOTYPE_CHANGED_NO_NEW_PARAMS Line0002 = "自从你上次配置该步骤后服务器可能已经改变。\n"
PROTOTYPE_CHANGED_NO_NEW_PARAMS Line0003 = "如果你想保留你的参数值，从指定模块对话框中CANCEL并将你的服务器恢复到它以前的状态。"
MEMBER_CHANGED_KEEP_VALUES_PROMPT = "你想保留参数值吗？"
AX_ERROR_ENUM_FIELD_WRONG_REPRESENTATION_WITH_ARG = "枚举类型 '%1' 的数字表示与枚举 '%2' 的类型库定义不兼容。需要默认 (Float64) 表示。"
AX_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_COUNT = "参数 '%1' 的类型与类型库中的枚举 '%2' 不匹配，因为它指定了不同数量的枚举数。"
AX_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_NAME = "参数 '%1' 的类型与类型库中的枚举 '%2' 不匹配，因为它没有 '%3' 的定义。"
AX_ELEMENT_NOT_MATCHING_ENUM_WITH_ARG_ENUM_VALUE = "参数 '%1' 的类型与类型库中的枚举 '%2' 不匹配，因为枚举器 '%3' 的数值不匹配。"
AX_ERROR_ENUM_FIELD_WRONG_REPRESENTATION = "参数的数字表示与枚举 '%1' 的类型库定义不兼容。需要默认 (Float64) 表示。"
AX_ELEMENT_NOT_MATCHING_ENUM_ENUM_NAME = "参数的类型与类型库中的枚举 '%1' 不匹配，因为它没有 '%2' 的定义。"
AX_ELEMENT_NOT_MATCHING_ENUM_ENUM_VALUE = "参数的类型与类型库中的枚举 '%1' 不匹配，因为枚举器 '%2' 的数值不匹配。"

USE_DEFAULT_LABEL = "使用默认值"
SYNTAX_ERR_NON_OPTIONAL_PARAM_EMPTY = "参数 %1 的值中存在语法错误：\n\n您必须为必需的参数指定值。\n\n该值会导致运行时错误。"
SYNTAX_ERR_PARAM = "参数 %1 的值存在语法错误：\n\n%2\n\n该值导致运行时错误。"
SYNTAX_ERR_ACTIVEX_REFERENCE_VAR = "对象引用变量 '%1'"
SYNTAX_ERR_REMOTE_HOST_EXPR_VAR = "远程主机表达式："
ACTIVEX_REFERENCE_VAR = "对象引用变量 '%1': %2"
SELECT_SERVER_LIST_ITEM = "<选择服务器>"
SELECT_CLASS_LIST_ITEM = "<选择对象类别>"
SELECT_MEMBER_TYPE_LIST_ITEM = "<选择一个动作>"
SELECT_MEMBER_LIST_ITEM = "<选择方法>"
SELECT_PROPERTY_LIST_ITEM = "<选择属性>"
CALL_MEMBER_WITH_NO_OBJECT_ERROR Line0001= "您不能访问未指定对象的成员。您必须在这一步中创建一个新对象或指定一个对象引用变量。这些设置会导致 "
CALL_MEMBER_WITH_NO_OBJECT_ERROR Line0002= "运行包含此步骤的序列时出错。"
HELP_STRING_DLG_TITLE = "项目帮助：%1"
STEP_SERVER_NOT_FOUND Line0001 = "'%1' 的类型信息未在此计算机上注册。\n如果该服务器存在于该计算机上，请使用浏览按钮找到并加载该服务器的类型库。\n"
STEP_SERVER_NOT_FOUND Line0002 = "如果您使用 Visual Basic 创建服务器，请确保您已注册该服务器或您正在 Visual Basic 环境中运行该服务器。"
STEP_CLASS_NOT_FOUND = "服务器未公开类 '%1'。\n自从您上次编辑此步骤以来，服务器的类型信息可能已更改。"
STEP_UPDATE_ID_FOR_NAME Line0001 = "类 '%1' 的标识符 (GUID) 已经更改。\n你想为这个类使用新的标识符（推荐）吗？\n\n在 ActiveX/COM 适配器中启用使用后期绑定选项配置 "
STEP_UPDATE_ID_FOR_NAME Line0002 = "始终更新 ID 的对话框。"
STEP_MEMBER_NOT_FOUND = "该步骤指定的类未公开成员 '%1'。\n自您上次编辑此步骤以来，服务器的类型信息可能已更改。"

STEP_DESC_UNSPECIFIED_ARG = "?"
STEP_DESC_OPTIONAL_ARG = " "
STEP_DESC_CREATE = "创建 %1"
STEP_DESC_CALL = "%0 %1.%2"
STEP_DESC_CALL_WITH_ARGS = "%0 %1.%2 (%3)"
STEP_DESC_CALL_WITH_ARGS_RETURN = "%4 = %0 %1.%2 (%3)"
STEP_DESC_CALL_WITH_RETURN = "%4 = %0 %1.%2"
STEP_DESC_MEMBER_INVOKE_CALL = "呼叫"
STEP_DESC_MEMBER_INVOKE_GET = "获取"
STEP_DESC_MEMBER_INVOKE_SET = "设置"
STEP_DESC_MEMBER_INVOKE_SETREF = "设置参考"

STEP_DESC_WITH_CREATE = "%1"
STEP_DESC_WITH_CREATE_AND_CALL = "%1; %2"
STEP_DESC_WITH_CALL = "%2"

PARAMETER = "参数 '%1': %2"
INVALID_TYPELIB_INFORMATION_FMT_MSG = "读取此服务器的类型信息时出错：\n%1"
ACTIVEX_REFERENCE_NULL = "对象引用变量 '%1' 为 NULL。"
EXCEPTION_OCCURRED = "在‘%3’的‘%2’中发生异常 %1"
ERROR_OCCURRED = "在‘%3’的‘%2’中发生错误 %1"
ACCESSING = "正在访问 '%1'"
CALLING = "正在呼叫‘%1’"
SOURCE = "来源："
INVALID_GUID_STRING = "'%1' 是无效的 GUID。\n"


TYPE_LIB_NOT_REGISTERED = "找不到 '%1' 的类型库信息。\n确保服务器已在计算机上注册。"
CLASS_NOT_FOUND_IN_TYPE_LIB = "找不到类 '%1'。"
MEMBER_NOT_FOUND_ON_DISPATCH = "在类 '%2' 中找不到成员 '%1'。"
MEMBER_NOT_FOUND_IN_INTERFACE = "在接口 '%2' 中找不到成员 '%1'。"
STEP_AUTOMATION_IDS_UPDATE_FAILURE_FMT_MSG = "序列 '%2' 中步骤 '%1' 的 ID 更新失败：\n %3"
FILE_AUTOMATION_IDS_UPDATE_FAILURE_FMT_MSG = "更新 '%1' 的 ID 时发生以下错误：\n"
UPDATE_IDS_TOOLMENU_ITEM = "更新自动化标识符"
UPDATE_IDS_PROCESSING = "正在处理序列文件..."
UPDATE_IDS_REPORTDLG_TITLE = "更新自动化标识符"
UPDATE_IDS_REPORT_SUCCESS = "更新完成且无错误。TestStand 对 %1 步骤进行了编辑。"
UPDATE_IDS_REPORT_NOSTEPSMODIFIED = "序列文件不包含任何需要更新的步骤。"
UPDATE_IDS_FAILURE_PROMPT_FOR_DETAILS = "更新 %2 个步骤时出错。\nTestStand 在 %1 个步骤上执行了成功的更新。\n\n你想查看详细的错误描述吗？"
INCORRECT_ACTIVEX_REFERENCE_TYPE = "'%1' 中的对象引用类型不正确。\n需要引用类型为 '%2' 的对象。"

LOADING_SERVERS_DLG_CAPTION = "正在加载："
LOADING_SERVERS_MESSAGE = "ActiveX 自动化服务器类型信息..."

ADP_CFG_DLG_CAPTION = "ActiveX/COM 适配器配置"
ADP_CFG_MATCH_BY_NAMES_CHECK_LABEL = "使用延迟绑定(&L)"
ADP_CFG_DO_RUN_TIME_DISPATCH_TYPE_CHECK_LABEL = "启用运行时 ActiveX 参考和类型检查"
ADP_CFG_UNLOAD_SERVERS_AFTER_EXEC_CHECK_LABEL = "执行后卸载未使用的 ActiveX 服务器(&U)"
ADP_CFG_SHOW_ACTIVEX_CONTROLS_CHECK_LABEL = "指定模块时显示 ActiveX 和控件"
ADP_CFG_SHOW_PARAMETERS_CHECK_LABEL = "在步骤描述中显示方法和参数"


[AUTOMATION_ADAPTER_TYPES]
VT_I2 = "数字（带符号的 16 位整数）"
VT_I4 = "数字（带符号的 32 位整数）"
VT_I8 = "数字（带符号的 64 位整数）"
VT_R4 = "数字（32 位浮点数）"
VT_R8 = "数字（64 位浮点数）"
VT_CY = "货币"
VT_DATE = "日期"
VT_BSTR = "字符串"
VT_DISPATCH = "对象引用"
VT_ERROR = "数字"
VT_BOOL = "布尔值"
VT_VARIANT = "变体"
VT_UNKNOWN = "对象引用"
VT_I1 = "数字（带符号的 8 位整数）"
VT_UI1 = "数字（无符号 8 位整数）"
VT_UI2 = "数字（无符号 16 位整数）"
VT_UI4 = "数字（无符号 32 位整数）"
VT_UI8 = "数字（无符号 64 位整数）"
VT_INT = "数字（带符号的 32 位整数）"
VT_UINT = "数字（无符号 32 位整数）"
VT_VOID = "无效"
VT_HRESULT = "HRESULT (数字)"
VT_SAFEARRAY = "阵列"
INVALID_VT_TYPE = "<不支持的类型>"
IDISPATCH_TYPE = "IDispatch"


;; HTBasic 适配器

[HTBASIC_ADAPTER]
NO_LONGER_SUPPORTED = "64 位 TestStand 不支持 HTBasic 适配器。"
NO_LONGER_SUPPORTED_ERROR_PROVIDER_MSG = "64 位 TestStand 不支持 HTBasic 适配器。\n加载或执行此模块时将报告错误。"
SPEC_MOD_DLG_CAPTION = "编辑 HTBasic 子程序调用"
SPEC_MOD_DLG_MOD_PATH_TXT = "子程序文件和路径名："
SPEC_MOD_DLG_EDIT_DECO_LABEL = "路径和执行"
SPEC_MOD_DLG_EDIT_DECO_LABEL_DISABLED = "在适配器配置对话框中，指定用于编辑和创建 HTBasic 代码模块的 HTBasic 开发服务器。"
SPEC_MOD_DLG_CREATE_BTN = "创建子程序..."
SPEC_MOD_DLG_EDIT_BTN = "编辑子程序..."
SPEC_MOD_DLG_FUNC_NAME_TXT = "子程序名称："
SPEC_MOD_DLG_SHOW_APP_TXT = "调用时显示 HTBasic 应用程序"
SPEC_MOD_DLG_WORK_DIR_PATH_TXT = "HT基本工作目录"
SPEC_MOD_DLG_SET_WORK_DIR_TXT = "设置工作目录"
SPEC_MOD_DLG_USE_HTBASIC_DIR_TXT = "使用 &HTBasic 目录"
SPEC_MOD_DLG_NONE = "不要改变工作目录"
SPEC_MOD_DLG_EXE_DIR = "HTBasic 服务器目录"
SPEC_MOD_DLG_FILE_DIR = "子程序文件目录"
SPEC_MOD_DLG_DEF_DIR = "使用适配器默认值"
SPEC_MOD_DLG_USER = "使用指定目录"

MODULE_BROWSE_TITLE = "为步骤选择代码模块"
PRO_FILES_MSG = "PRG 文件"
BAS_FILES_MSG = "BAS 文件"
PRO_AND_BAS_FILES_MSG = "PRG 和 BAS 文件"

CALL = "调用 %1 (%2)"
HT_SERVER_IS_NOT_EDITOR Line0001 = "HTBasic 适配器当前配置为在不支持编辑代码的环境中运行测试。"
HT_SERVER_IS_NOT_EDITOR Line0002 = "您必须在 HTBasic 适配器配置对话框中选择不同的 HTBasic 服务器"
HT_SERVER_IS_NOT_EDITOR Line0003 = "编辑或创建 HTBasic 代码。"
HT_ADP_MSG_TITLE = "HTBasic 适配器消息"
INVALID_PATH = "子程序路径无效。"
CODE_TMPL_NOT_FOUND = "无法找到代码模板文件 '%1'。"
MUST_SPEC_MODULE_FIRST = "你必须首先指定模块路径和参数。你想现在指定它们吗？"
UNABLE_TO_CREATE_PATH_NOT_ABS = "无法创建代码。\n你必须指定一个绝对路径来创建代码。"
UNABLE_TO_CREATE_PATH_NOT_VALID = "无法创建代码。\n你必须指定一个有效的路径来创建代码。"
PRELOAD_TIMEOUT_EXTERNAL_SUB = "HTBasic 正在执行另一个步骤，无法预加载 '%1'。"
HT_LOST_CONNECT = "与 HTBasic 服务器失去连接。HTBasic 适配器将尝试在下一次执行尝试时重新连接。"
UNABLE_TO_LAUNCH_HTBASIC_DEVENV = "无法启动 HTBasic 开发服务器。在 HTBasic 适配器配置对话框中配置 HTBasic 开发服务器。"
UNABLE_TO_EDIT_SRC_SRC_NOT_FOUND = "无法找到此步骤的源文件。确保模块源文件存在于磁盘上。"
NO_FUNC_NAME = "您必须先指定一个子程序名称，然后才能编辑代码。"
NO_PATH = "当您选择使用指定的目录选项时，您必须指定一个路径。"

ADP_CFG_CAPTION = "HTBasic 适配器配置"
ADP_CFG_FULL_EXE = "使用 HTBasic 开发服务器。"
ADP_CFG_RUNTIME_EXE = "使用 HTBasic &Runtime 服务器。"
ADP_CFG_DEF_WORK_DIR_TEXT = "HTBasic 默认及工作目录："
ADP_CFG_RT_PATH_TEXT = "HTBasic 运行时&服务器路径："
ADP_CFG_WHICH_EXE_TEXT = "要使用的 HTBasic 服务器"
ADP_CFG_BROWSE_TITLE = "选择 HTBasic 服务器"
EXE_FILES_MSG = "EXE 文件"


;;一般对话框

[DISPATCH_WARNING]
TITLE = "TestStand API 警告"
CUSTOM_PROP_WARNING = "您通过 Dispatch 接口访问了 TestStand 自定义属性。您可以重新编译调用代码以调用 PropertyObject GetValxxx 和 SetValxxx 方法以使用更快的 vtable 接口。\n\n您是否要为调用 TestStand 禁用此警告应用程序接口？"
STD_WARNING Line0001 = "您通过 Dispatch 接口调用了 TestStand API 方法或属性。您可以重新编译调用代码以使用更快的 vtable 接口。\n\n接口是 '%1'，方法 ID 是 %2。\ n\n"
STD_WARNING Line0002 = "使用 TS_<Interface>GetProperty 或 TS_<Interface>SetProperty 函数对 TestStand API 的 LabWindows/CVI 调用始终使用 Dispatch 接口。\n使用 TS_<Interface>Get<Property> 和 TS_<Interface>Set <Property> 函数通过 LabWindows/CVI 中的 vtable 接口访问属性。\n\n"
STD_WARNING Line0003 = "你想禁用调用 TestStand API 的警告吗？"

[TSUIUTIL_DLGS]
YES_YES2ALL_ABORT_DLG_TITLE = "问题"
YES_YES2ALL_NO_NO2ALL_DLG_TITLE = "问题"
YES_YES2ALL_ABORT_DLG_ABORT_BTN_LABEL = "中止"
RETRY_CANCEL_DLG_TITLE = "重试？"
RETRY_CANCEL_DLG_RETRY_BTN_LABEL = "重试"

[TS_UTIL]
OK="__确定"
CANCEL = "取消"
SAVE_AS = "另存为"
SYNTAX_ERROR_TITLE = "语法错误"
GOTO_ERR_BTN = "__转到错误"
IGNORE_BTN = "__忽略"
EMPTY_EXPR_ERR = "表达式不能为空。"
OVERWRITE_EXISTING_FILE = "已经存在。覆盖它？"
EVAL_ERROR_TIP_PREFIX = "表达式错误："
DEFAULT_EXPR_BTN_LABEL = "__浏览..."
EXPR_CANNOT_BE_EMPTY = "<表达式不能为空>"
EXPR_ERROR_TITLE = "表达错误"
EXPR_ERROR_PREFIX = "表达式错误"
ERROR_CODE = " [错误代码：%d]"
ERROR="错误"

[DISTRIBUTION_WIZARD_DIALOG]
startingMsg="正在启动 TestStand 部署实用程序\napplication..."
Distribution_Wizard="TestStand 部署实用程序"
64_BIT="（64 位）"
Default="默认"
WELCOME_MSG="欢迎使用 TestStand 部署实用程序。该程序将帮助您收集分发测试系统所需的文件。"
Welcome="系统源"
Incorrect_License_Type="您没有使用 TestStand 部署实用程序所需的正确许可类型。"
LabVIEW_VI_Options="LabVIEW VI 选项"
Deployed_Files="已部署文件"
Installer_Options="安装程序选项"
Pkg_Dist_Options="包分发选项"
Summary="构建状态"
Distribute_from_Workspace="来自 TestStand 工作区文件"
Distribute_From_Dir="来自目录"
Processing_Dir_Done="目录处理完成"
Processing_Dir_Start="处理目录"
Load_Wkspc_TS="在序列编辑器中加载工作区"
Distribute_TestStand_User_Files="来自 TestStand 公共目录"
Distribute_TestStand_Cfg_Files="来自 TestStand 配置目录"
Engine_Environment_Options="引擎环境选项"
Set_Environment_On_Target="使用环境文件来确定部署的文件目标"
Active_Environment_File="使用环境文件"
DISABLED_REQUIRES_ENV_FILE="仅当您指定环境文件时启用。"


Workspace_Source_Path="工作区文件路径："
Save_Distributed_Files="保存分布式文件"
Target_Directory="可部署映像的位置："
Include_Files_From_Dir="目录路径："
Include_SubDirs="包括子目录"
Cache_Installers="要在构建安装程序时尽量减少媒体提示，请将选定的安装程序和所有以后的安装程序复制到此计算机。此应用程序仅在以管理员身份运行时支持此选项。"
Do_Not_Update_Projects_or_Sequences="不更新工作区、项目或序列"
Show_Runtime_Installers_Only="只显示运行时安装程序"
Show_Runtime_Installers_Only_pkg="只显示运行时和用户构建的包"
PKG_SEARCH_FILTER = "搜索"
PPL_SOURCE_README Line0001 = "您可以使用这些源文件来重建部署到测试站的打包项目库。"
PPL_SOURCE_README Line0002 = "完成以下步骤以在修改源后重建打包的项目库：\n"
PPL_SOURCE_README Line0003 = "1. 在生成的项目中使用构建规范 '%s' 创建另一个打包项目库。构建规范生成文件 '%s'。\n"
PPL_SOURCE_README Line0004 = "2. 用新生成的文件替换您部署的打包项目库。" 
Load_BTN="加载..."
Save_BTN="保存"
Save_As="另存为..."
New_BTN="新建"
Help_BTN="帮助"
Build_BTN="构建"
Done_BTN="完成"
BROWSE ="浏览..."
NEW="新建"
EXPLORE="查看..."
Compile_VIs="编译VI（推荐）"
Lock_VIs="应用新密码"
Remove_VI_Diagrams="删除程序框图"
Password="密码"
Verify_Password="验证密码"
Exclude_Files_VI.LIB="从 vi.lib 中排除文件"
Exclude_Files_User.LIB="从 user.lib 中排除文件"
Exclude_Files_Instr.LIB="从 instr.lib 中排除文件"
Include_PPL_Files_VI.LIB="在构建之前从 vi.lib 复制文件"
Include_PPL_Files_User.LIB="在构建之前从 user.lib 复制文件"
Include_PPL_Files_Instr.LIB="在构建之前从 instr.lib 复制文件"
Remove_Unused_Library_Members="删除项目库中未使用的成员"
Modify_Library_File_After_Removing_Members="删除未使用的成员后修改项目库文件"
USE_BCRTE_FOR_PPL="允许未来版本的 LabVIEW 加载库"
Include_Substep_VIs = "包含 LabVIEW 子步骤的模块文件"
Include_Substep_GVIs = "包含 LabVIEW NXG 子步骤的模块文件"

Exclude_Dependent_Shared_Libraries="排除依赖共享库（LabVIEW 2014 及更高版本）"
Exclude_Dependent_PPLs="排除依赖打包库（LabVIEW 2014 及更高版本）"
Check_Broken_VIs="检查损坏的 VI"
Check_Broken_VIs_During_Analysis= "在分析过程中检查损坏的 VI"
Check_Broken_VIs_After_Build="在构建后检查损坏的 VI"
Include_Files_From_Module_Source="包含步骤中指定的打包库源文件"
Rebuild_PPLs_From_Module_Source="在构建期间重建打包库"

Remove_Unneeded_VIs="删除未使用的 VI 组件"
Source_Files="部署文件："
Global_Settings="全局设置："
Installer_Cache_Dialog="安装程序缓存"
Checked_Installers_will_be_copied_to_Cache="选择要复制到本地缓存的安装程序"
Tab_Control=" 选项卡控件"
SubVI_Location="子 VI 位置（在路径末尾使用 .LLB 将文件放置在 VI 库中）："
SubVI_Location_ErrMsg = "子 VI 位置（在 LabVIEW VI 选项对话框中指定）"
Distributed_Files="分布式文件"
File_Properties="文件属性："
Source_Path="来源路径："
Dest_Path="目标路径："

File_Settings_Do_Not_Process = "不处理"
File_Settings_Force_Install = "强制安装"
File_Settings_Create_Program_Item = "创建程序项：[%s]"
File_Settings_Shortcuts = "创建 %d 个快捷方式%s"
File_Settings_Activex_Server = "注册 ActiveX 服务器"
File_Settings_Include_VIs_In_LV_Project = "包括所有 VI"

Replacement_Path="替换路径："
TESTS_DIR="选择安装测试的目录"
TESTSTAND_INSTALL_DIR="选择安装TestStand的目录"
NO_LOC_INSTR=""
LOC_INSTR="查看以下目标目录。单击浏览按钮更改目录。单击下一步按钮继续。"
NIDIR_INSTALL_DIR="选择安装 National Instruments 产品的目录"
Installer_requires_teststand="此安装程序在 TestStand 目录中安装文件。您必须首先安装 TestStand 以创建 TestStand 目录。"
Installer_requires_64_bit_os="此安装程序需要 64 位操作系统。您不能在 32 位操作系统上安装。"
Installer_requires_windowsXP= "此安装程序需要 Windows XP 或更高版本。您不能在更早的操作系统上安装。"
Installer_Properties="安装程序属性："
Installation_Destination="安装目的地："
Installation_Destination_Subdirectory="安装目标子目录："
Installation_Destination_Subdirectory_browse_button="浏览..."
Register_AX_Server="注册为 ActiveX 自动化服务器"
Force_Install="强制安装文件"
Create_Program_Item="创建程序项"
PROGRAM_ITEM_NAME="程序项名称："
Shortcuts ="快捷方式..."
Do_Not_Process_Item="包含而不处理项目或依赖项"
Include_All_VIs_in_Project="包括LabVIEW项目中的所有文件"
ShortCut_List="快捷方式："
Shortcuts_Title="快捷方式"
Add_ShortCut="添加快捷方式"
Delete_ShortCut="删除快捷方式"
Shortcut_Base_Path="快捷方式基本路径："
Shortcut_Relative_Path="快捷方式相对路径："
Shortcut_Command_Line_Arguments="快捷方式命令行参数："
Shortcut_Start_In="开始于："
View="分布式文件："
View_Workspace="查看工作区"
view_Source="查看源代码"
view_Destination="查看目的地"
View_Build_Preview="查看构建预览"
View_Dependent_Destination="查看依赖目标"
View_Previous_Build_Destination="查看上一个构建目标"
View_Dependent_Destination_Version="查看依赖目标（v.%s）"
View_Previous_Build_Destination_Version="查看以前的构建目标（v. %s）"
MAX_CONFIG_MISSING = "在磁盘上找不到位于 %s 的硬件配置文件。"		
README_MISSING = "在磁盘上找不到 %s 安装程序的自述文件。"
WORKSPACE_FILE_MISSING="%s 的工作区文件在磁盘上找不到。"
USER_SOURCE_DIRECTORY_MISSING="在磁盘上找不到包含在 %s 部署中的目录。"
LICENSE_ARGEEMENT_MISSING = "在磁盘上找不到安装程序在 %s 的许可协议文件。"
CONTEXT_INTRO="同时"
CHECKING_VI="正在检查 VI:"
Hide_Non_Distributed_Files="隐藏非分布式文件"
Analyze_Workspace="分析源文件"
Force_Analyze_Workspace="您必须分析此文件以激活目标视图。保存当前 .tsd 文件以激活目标视图而不分析文件。"
Expand_All="全部展开"
Collapse_ALL="全部折叠"
Prompt_Analyze_Workspace="你想分析源文件吗？"
PathWithType="%s %s"
InvalidPathIllegalCharacters="以下路径无效，因为它们包含一个或多个文件名中不允许的字符："
InvalidPathEmpty="以下空路径无效："
InvalidPathRelativePath="以下路径无效。预期的相对路径。"
InvalidPathAbsolutePath="以下路径无效。需要绝对路径。"
ExpectedRelativePath="路径 \"%s\" 无效，需要相对路径而不是绝对路径。"
ExpectedAbsolutePath="路径 \"%s\" 无效，需要绝对路径而不是相对路径。"
ContainsIllegalCharacters= "路径包含非法字符。"
Create_Installer="创建安装程序"
Installation_Name="安装名称："
Installer_Directory="安装程序目录："
PKG_OUTPUT_DIR="输出目录："
Public_Destination_Subdirectory= "公共目标子目录："
Default_Install_Directory="默认安装子目录："
Default_Install_Directory_ErrMsg="默认安装子目录"
SelectDefaultInstallationDirectory="为默认安装目录选择一个绝对路径。"
Default_Install_Absolute_Directory="默认安装目录："
Start_Menu_Item_Group="开始菜单项组："
Start_Menu_Item_Group_ErrMsg="开始菜单项组："
Default_Install_Base_Directory="默认安装基本目录："
Lock_Install_Dir="不要向用户询问安装目录"
Installation_Language="安装语言："
NO_FILES_UNDER_SOURCE_DIRECTORY="<源目录下没有文件>"
MULTIPLE_DESTS="<多个目的地>"
DestinationPlaceHolderHeader="" 的 VI
MergedDestinationDisplayName="所有项目"
DestinationPlaceHolderFooter=""
English="英语"
French="法语"
German="德语"
Japanese="日语"
Korean="韩语"
Chinese_Simplified="简体中文"
Hide_License_Dialog="隐藏许可证对话框"
Import_Volume_License_Info="包括网络许可服务器设置"
Advanced_Options="高级选项..."
TestStand_Runtime="TestStand 运行时"
Install_TS_Engine="安装 TestStand 运行时"
Engine_Options="可选的测试台功能..."
Additional_Components="驱动程序和组件..."
Dependencies_btn="依赖关系..."
LabVIEW_OPTIONS="LabVIEW 选项..."
Options...="选项..."
Exclusions="排除"
Optimizations="优化"
PPL_Source_Destination="源目的地"
Source_Destination_Subdirectory="源目标子目录"
Packed_Library_Source="打包项目库源选项"
Include_Source_for_Rebuilding_Packed_Project_Libraries="包含用于重建打包项目库的源代码"
PPL_Source_Destination_Subdirectory="源目标子目录"
PPL_Options="打包项目库选项"
Base_Name="基础库名称"
Debug_Version="启用调试"
Use_Installer_Version="安装程序的版本"
Properties="属性"
Product_Name="产品名称"
Legal_Copyright="合法版权"
Company_Name="公司名称"
Internal_Name="内部名称"
Description="描述"
PassWord...="密码..."		
Passwords_Dont_Match="密码不匹配。密码未更改。"
Summary_Msg="您已到达实用程序的末尾"
Logfile="状态日志：按 F1 并参考 NI TestStand 帮助中的 TestStand 部署实用程序错误和警告主题，了解有关错误和警告的更多信息。"
Clear_Log="清除日志"
Save_Log="保存日志..."
SAVE_LOG_AS_ZIP="保存技术支持报告..."
Save_Log_As="将日志另存为..."
Save_Log_Prompt = "为日志选择一个文件名"
CANTDELETEFILE="不能删除下列文件："
CANTDELETEDIR="无法删除以下目录："
Abort="中止"
Aborted="中止"
Saving_Log_Failed="保存日志文件失败。请确保您选择的路径可写。"
File_Used_By_VIs="以下 VI 使用该文件："
LABVIEW_MISSING_DEPENDENCY="构建被中止，因为 LabVIEW 丢失了一个或多个文件。目前正在确定引用丢失文件的顶层 VI。"
GENERATING_ERROR_INFOMATION="生成错误信息..."
Error_Processing_VIs="无法处理 LabVIEW VI。在重建之前修复所有损坏的 VI。LabVIEW 错误："
Build_Progress="进度"
Build_Status="构建状态："
FILE_NOT_FOUND="（未找到文件）"
Following_VIS_are_Modified="以下 VI 已修改："
SAVE_MODIFIED_VIS="保存修改后的 VI？"
Save_VIs_Title="保存修改后的 VI？"
Prompt_Save_VIs="尝试读取 VI 的相关性时发生错误，可能是因为 VI 未保存在当前版本的 LabVIEW 中。是否要立即保存任何修改过的 VI？"
Engine_Options_Dialog="可选的测试台功能"
MDF_ERR="发生涉及安装程序功能的内部错误。这种类型的错误通常表示一个或多个 National Instruments 安装程序存在问题。是否要查看详细的安装程序日志以获取有关导致错误的产品的更多信息？"
MDF_LOG_PATH="发生涉及安装程序功能的内部错误。此类错误通常表示一个或多个 National Instruments 安装程序存在问题。打开以下日志文件以获取更多信息："
MDF_LOG_NOT_INITIALIZED="TestStand 部署实用程序无法写入详细的安装程序日志文件。确保当前没有其他 TestStand 部署实用程序实例正在运行。"
Yes="是"
No="否"
ExistsOverwrite="文件 %s 已经存在。你想覆盖它吗？"
ReadOnly="您不能保存文件 %s，因为它是只读的。"
Selectworkspacefile="选择工作区文件"
SelectImageDirectory="选择图像目录"
SelectInstallerDirectory="选择安装目录"
SELECT_INSTALLER_TO_PATCH="选择包含完整安装程序的目录"
SELECT_FILE_PATCH_WITH="选择要修补的文件"
SELECT_FILE_ADD="选择要添加的文件"
DeploymentFileFilter="TestStand 部署 (*.tsd)|*.tsd||"
WorkspaceFileFilter="工作区文件 (*.tsw)|*.tsw||"
RichTextFileFilter="富文本格式 (*.rtf)|*.rtf||"
DW_Progress="部署进度"
Progress="进度"
Application_Name="应用名称"
CUSTOM_COMD_BTN="自定义命令..."
CUSTOM_COMMANDS="自定义命令"
COMMAND_LIST="命令列表："
SUB_VI_PREFIX="<子VI：保存到'"
SUB_VIS_IN_PPL="<子 VI：未导出>"
PPL_SOURCE_PLACEHOLDER="<重建打包项目库的来源>"
IS_LLB="'>"
IS_DIR="'目录>"
TSD_VERSION_TOO_NEW="不正确的 .tsd 文件版本"
TSD_LAST_SAVED_VERSION_TOO_NEW="您尝试加载的 .tsd 文件需要更高版本的 TestStand 部署实用程序，至少是 TestStand 版本 %s。"
INVALID_FILE_FORMAT_MSG="无法打开文件。非预期的文件格式。"
INVALID_FILE_FORMAT_TITLE="无效文件格式"
ADD="添加"
DEL="删除"
MOVUP="上移"
MOVDN="下移"
SELECTED_COMMAND_ITEM_SETTINGS="所选自定义命令的设置"
COMMAND_BASE_DIR="命令目录"
COMMAND_AND_ARGS="命令和参数（请参阅可用目录宏的帮助）"
REQUEST_REBOOT="所有命令执行后请求重启"
SKIP_CUSTOM_COMMANDS_IN_SILENT_MODE="静默安装时跳过自定义命令"
SHOW_DIALOG="显示命令进度窗口"
Advanced_Installer_Options="高级安装程序选项"
GENERAL_SETTINGS = "常规设置"
TESTSTAND_SPECIFIC_SETTINGS = "TestStand 特定设置（需要包含 TestStand 运行时）"
Version="版本："
Auto_Increment="自动递增"
Installer_title="安装程序标题："
Installer_Name="安装程序可执行名称："
Author="作者："
Manufacturer="制造商："
Subject="主题："
Keywords="关键字："
Product_Code="产品代码："
Upgrade_Code="升级代码："
Generate="生成"
Comments="评论："
ReadMe_File="自述文件："
Unhandled_error_code="内部错误代码 %d %s"
License_Agreement="许可协议："
Media_Spanning="媒体传输（以 MB 为单位的大小）："
Media_None="无"
Media_Zip="压缩盘"
Media_Std_CD="标准光盘"
Media_Ext_CD="扩展CD"
Media_Jaz="Jaz Disk"
Media_DVD="DVD"
Specify_Configuration_Directory="指定配置目录："
Include_DOTNET_in_Installer="在安装程序中包含 .NET Framework 版本 2.0"
Destination="目的地："
Destination_Subdirectory="目标子目录："
Export_MAX_Config="导出测量与自动化资源管理器配置"
MAX_Config_File="配置文件路径"
Export="导出"
MAX_Config_Export="导出硬件配置信息时出错。"
Alt_Seq_File_Association=".seq 文件的备用关联："
ProcessModelsEngineInstaller="TestStand 运行时安装程序使用的进程模型（不更改开发计算机设置）："
Allow_Installer_Upgrade_TestStand="允许安装程序升级已安装的 TestStand 运行时"
No_Change="无变化"
Force_Default_Models="强制默认模型"
Force_Legacy="强制遗留模型"
Merge_Projects_for_Build= "合并文件项目共享"
Use_SSE_Instructions="启用 SSE2 优化"
PPL_Options_Category = "打包项目库选项"

PKG_ID = "包名称"
PKG_display_name = "显示名称"
PKG_Company = "公司"
PKG_Product = "产品"
PKG_DESCRIPTION="描述"
PKG_SYNOPSIS="包概要"
PKG_MAINTAINER_NAME="维护者"
PKG_MAINTAINER_EMAIL="联系邮箱"
PKG_HOMEPAGE="首页"
PKG_EULA_FILE="自定义许可协议"
PKG_INCLUDE_CERTIFICATES="包括 NI 证书包"
PKG_OPTIONS = "配置包属性"
PKG_ERR_EMPTY_FIELDS = "以下字段不能为空：%s"
ERR_DEST_NOT_SUPPORTED_SHORTCUT = "当前构建配置不支持快捷方式的基本路径"

PKG_INCLUDE_WITH_RUNTIME_DEPLOYMENT_PACKAGES = "显示在运行时部署包列表中"

PKG_CATEGORY = "类别"
PKG_CATEGORY_ANY = "<任何类别>"
PKG_CATEGORY_APPLICATION = "应用软件"
PKG_CATEGORY_ADDONS = "插件"
PKG_CATEGORY_DRIVERS = "驱动程序"
PKG_CATEGORY_RUNTIME = "运行时"
PKG_CATEGORY_UTILITIES = "实用工具"
PKG_CATEGORY_DOCUMENTATION = "文档"
PKG_CATEGORY_INFRASTRUCTURE = "基础设施（隐藏）"

PKG_FILTER_TITLE = "过滤器"
PKG_FILTER_VISIBLE_RUNTIME_ONLY = "仅限运行时部署包"
PKG_FILTER_VISIBLE_ONLY = "所有可见包"
PKG_FILTER_SHOW_ALL = "所有包（包括隐藏包）"


LabVIEW_Options_Tab = "LabVIEW 选项"
BLV_Options_Tab = "LabVIEW NXG 选项"
General_BLV_Options_Category = "常规选项"
Distribute_BLV_Source_Files = "包括 LabVIEW NXG 源文件"

General_LV_Options_Category="常规 LabVIEW VI 选项"
Build_PPL = "将 VI 输出到打包项目库"
NO_ASSOCIATION="无备用关联"
PROTECTED_SYSTEM_DIR="受保护的系统目录"
WORKSPACE_DIR="包含工作区目录"
SOURCE_DIR="包含用户源目录"
CANCEL_BTN="取消"
CANCEL="取消"
REMAP="重新映射"
PREVTSDIR="上一个 TestStand 目录"
REMAP_DIALOG_TITLE="重新映射 TestStand 目录"
PROMPT_OLD_TSDIR="您加载的 TSD 文件是用 TestStand %s 创建的，可能引用 TestStand %s 目录中的文件。要将这些文件映射到当前 TestStand 目录中的等效文件，请在用于的机器上输入 TestStand %s 目录在下面创建 TSD 文件，然后单击重新映射按钮。"
EngineOptionsChanged="TestStand 运行时选项已更改"
Reason_Engine_Options_Changed Line0001 ="自您保存 .tsd 文件后，TestStand 安装程序已更改。\n"
Reason_Engine_Options_Changed Line0002 ="TestStand 更新了 TestStand 运行时选项以维护您选择的功能。"
period="."
and_with_space=" and "
Feature_Changed_to="%s 已更改为 "
ChangesToEngineOptions="对 TestStand 运行时选项所做的更改："
OBSOLETE_ENGINE_OPTIONS="过时的 TestStand 运行时选项"
FOLLOWING_ENGINE_OPTIONS_OBSOLETE = "以下过时的 TestStand 运行时选项已删除："
Do_Not_Display_Dialog_Again="不再显示此对话框"
USER_DIRECTORIES_CHANGED_TO_PUBLIC_DIR Line0001 ="这个 .tsd 文件部署了 TestStand 用户目录中的文件。TestStand 4.1 重新组织了目录以移动其中的内容"
USER_DIRECTORIES_CHANGED_TO_PUBLIC_DIR Line0002 = "TestStand 用户目录到 <TestStand Public> 目录。TestStand 4.1 还添加了 National Instruments 的副本"
USER_DIRECTORIES_CHANGED_TO_PUBLIC_DIR Line0003 =" <TestStand Public> 目录的用户界面。您可能需要将文件复制到 <TestStand Public> 目录中。"
USER_DIRECTORIES_CHANGED_TO_PUBLIC_DIR Line0004 =" 查看当前包含的文件并考虑排除 National Instruments 用户界面。"
USER_DIRECTORIES_CHANGED ="TestStand 用户目录已更改。"
MISSING_ENGINE_OPTIONS="TestStand 运行时选项不可用"
FOLLOWING_ENGINE_OPTIONS_MISSING="以下 TestStand 运行时选项不可用："
INSTALL_READD_ENG_OPTIONS="您可能需要安装 National Instruments 软件包并重新加载 .tsd 文件。"
FOLLOWING_ADDITIONAL_COMPONENTS_MISSING="以下驱动程序和组件丢失："
MISSING_DRIVERS_AND_COMPONENTS_TITLE="缺少驱动程序和组件"
INSTALL_AND_ADD Line0001 ="您可能需要安装这些组件并重新加载 .tsd 文件。如果您更新\n"
" INSTALL_AND_ADD Line0002 ="一个驱动程序，在"驱动程序和组件"对话框中重新选择它。
Additional_Components_Title="驱动程序和组件"
Additional_Components_Title_PKG="依赖项"
Components_to_Include="要包含的组件"
Products_Selected_But_Not_Shown_Warning="某些安装程序已被选中但未显示。"
Product_Included_In_Baseline_Note="该产品已包含在基线分发中"

Merge_MAX_OPT="合并"
Replace_MAX_OPT="替换"
Preserve_MAX_OPT="保留"
MAX_Import_Options="Measurement & Automation Explorer 导入选项："
Copy_All_Future_Installers_To_This_Computer_When_Run="在运行时将所有未来的安装程序复制到这台计算机"
Display_Dialog_During_Import="导入时显示对话框"
Deployment_Installer_Clarification Line0001 ="您选择要包含在安装程序中的其他 National Instruments 安装程序仅包含当前安装在此的功能 "
Deployment_Installer_Clarification Line0002 ="计算机，因此可能不是原始产品的完整副本。有关详细信息，请参阅 NI TestStand 帮助。"
SETUP_EXE_WARNING_SHORT = "注意：不推荐使用名称'Setup.exe'。点击帮助按钮获取更多信息。"

Total_Disk_Cost="总磁盘成本"
Total_Disk_Cost_AutoInclude_Note="总磁盘成本（不包括自动包含的安装程序）"
Auto_Include_Required_Installers="自动包含必需的安装程序"
Auto_Include_Required_Packages="自动包含所需的包"
Install_Type="安装类型："
ConfgFileFilter="NI 配置导出文件 (*.nce)|*.nce|所有文件|*.*||"
ConfgFilePrompt="选择配置文件"
Hardware_Configuration_File="硬件配置文件"
INCLUDE_HW="包括来自 Measurement Automation Explorer 的硬件配置"
Installer_source_location="安装程序源位置"
Distribution_title="发行标题"
Distribution_title_PKG="包名"
Pkg_dependency_level="包依赖级别"
pkg_Version_requirements = "版本要求"
version_2="最大"
inclusive="包含"
Show_Hidden_Packages = "显示隐藏包"

pkg_required = "必需的依赖项"
pkg_recommended = "推荐依赖"
pkg_optional = "可选依赖项"

vrm_any = "任何版本"
vrm_equal = "特定版本"
vrm_greater = "大于"
vrm_less = "小于"
vrm_range = "在范围内"

vrm_ver = "版本"
vrm_min = "最低"
vrm_max = "最大值"

Required_by_TSEngine="\n[TestStand 运行时要求]"
Used_by_TSEngine="\n[由 TestStand 运行时使用]"
Required_by_product="要求："
Recommended_for_product="\n[推荐用于 %s]"
Present_In_Dependent_Dist="注意：不能选择该产品，因为它已经包含在基线分布中。"
PRODUCT_NOT_INSTALLED = "产品未安装"
PRODUCT_NOT_INSTALLED_DESCRIPTION="此产品未安装在系统上。您必须在构建前CANCEL选择此产品。"
INCLUDE_ACTIVE_TS_RUNTIME = "活动的 TestStand 运行时引擎"
PATCH_FOR_BASELINE_PRODUCT = "该产品是包含在基准发行版中的产品的升级或补丁。"
BAD_VERSION_FORMAT="版本格式不正确。需要 Major.Minor.Build 版本形式的数字。"
DIST_MISSING="分布缺失。"
NOT_DISTRIBUTION="不是发行版。"
REMOVABLE_MEDIA_NOT_PRESENT="可移动媒体不存在。"
NETWORK_LOCATION_INACCESSIBLE="无法访问网络位置。"
PATH_NOT_FOUND="找不到路径。"
INCORRECT_DISTRIBUTION="分配不正确。"
DIST_PROMPT Line0001 = "构建需要以下分布：\r\n\t%s。\r\n\r\n"
DIST_PROMPT Line0002 = "插入 CD/DVD，等待 CD/DVD 完全安装，然后单击确定。\r\n\r\n"
DIST_PROMPT Line0003 = "或者，浏览到分发的位置。\r\n"
DIST_PROMPT Line0004 = "该分发最近发现于：\r\n\t%s"
DIST_TITLE="%s 未找到"
MDF_INITIALIZE_FAILED="安装程序工具包初始化失败。保存分发并重新启动此应用程序。"
OK="确定"
OK_BTN="确定"
POPUPDIALOGTXT__DIR_NOT_FOUND="无法找到以下目录："
POPUPDIALOGTXT__FILE_NOT_FOUND="找不到以下文件："
Step="步骤"
Sequence="序列"
SequenceFile="序列文件"
Installer_Features="选择要包含在 TestStand Runtime 中的可选 TestStand 功能："
Dependency_Warnings="依赖警告："
MDAC_Version_to_Install="要安装的 MDAC 版本"
Read_MDAC_EULA="读取 MDAC EULA"
CANT_FIND_MMS="无法找到可重新分发的 TestStand Runtime 组件。"
FATAL_ERROR_OCCURED="发生致命错误。"
UNABLE_CREATE_ENGINE="无法创建 TestStand 引擎。正在关闭。"
ERROR_CODE="错误代码："
ERROR_INVALID_PATH="构建包含一个或多个无效路径："
ERROR_DIR_NOT_FOUND="以下目录不存在："
ERROR_LVPROJECTS_MISSING_PROVIDERS="以下 LabVIEW 项目缺少插件。确保您没有缺少 LabVIEW 模块。"
ERROR_CONFLICTS_IN_PROJECT="以下LabVIEW文件或项目项存在冲突。如果指定了一个或多个项目，打开项目查看并解决冲突。如果未指定项目，项目可能与另一个具有相同限定条件的VI冲突磁盘上不同位置的名称。"
ERROR_LV8_ABOVE_REQUIRED="处理以下文件需要 LabVIEW 8.0 或更高版本："
ERROR_CANTOPENSEQFILE="无法打开以下序列文件："
ERR_LV_VER_NOT_SUPPORTED= "此版本的 TestStand 不支持 LabVIEW 的活动版本。"
ERROR_TESTSTAND_ENGINE="TestStand 引擎报告了以下错误："
ERROR_READING_ENGINE_PARTS="%s（产品 ID：%s）"
SOURCE_BITFILE_MISSING="以下源位文件丢失。您可能需要为 FPGA VI 创建位文件。"
COULDNT_COPY_BITFILE="无法复制以下位文件："
COULDNT_GET_SOURCE_BITFILE_PATH="无法从项目中获取位文件路径。查看 FPGA 目标下的构建规范。"
COULDNT_GET_TEMP_BITFILE_PATH="无法从临时项目中获取位文件路径。联系 National Instruments 以获得支持。"
LV_VERSION_DOESNT_SUPPORT_PPL="您必须使用 LabVIEW 2010 来构建打包的项目库。有效的 LabVIEW 版本是："
Missing_ReadMe="自述文件丢失。"
Missing_License_File="许可证文件丢失。"
Shortcut_to_File="文件 %s 的快捷方式"
ProgramItem_to_File="文件 %s 的程序项的路径"
BUILD_CONTAINS_NO_FILES="部署不包含任何文件或组件。"
STARTING_LOG="正在为部署启动日志。"
SELECT_DEFAULT_INSTALLATION_DIR="选择默认安装目录。"
SELECT_TARGET_DIRECTORY="选择目标目录。"
SELECT_WORSPACE_TO_DISTRIBUTE="选择要分发的工作区文件。"
INSTALLER_NOT_MADE="一个错误阻止了安装程序的创建。"
BUILD_COMPLETE="构建过程完成。"
Unsupported_Engine_Options_Title="包含不支持的 TestStand 运行时附加组件"
Unsupported_Engine_Options="不再支持以下 TestStand 运行时附加组件："
LOADING_FILE="正在加载构建文件："
SAVING_FILE="正在保存构建文件："
NEW_DEPLOYMENT="新部署"
WIZARD_DONE="正在关闭。"
CouldNotSave="将构建文件保存到以下位置时发生错误：%s。\n\n请参阅状态日志以获取更多信息。"
readonly_files="以下目录包含只读文件："
workspacefile_not_found="找不到工作区文件。"
DU_REQ_LICENSE EDITING="TestStand 部署实用程序需要支持编辑序列的许可证。"
MDF_ERROR="生成安装程序构建时出错。"
MDF_WARNING="创建安装程序时出现内部警告。"
REQ_PRODUCT_NOT_INCLUDED="部署文件所需的产品未包含在安装程序中。"
REQ_PRODUCT_NEWER_THAN_INSTALLED_VER="系统上的产品版本低于部署中文件所需的版本。"
REQ_PRODUCT_NOT_INSTALLED="部署文件所需的产品未安装在系统上。"

UNABLE_LOAD_MDF="无法加载 National Instruments 安装程序架构工具。"
ERROR_VIS_NOT_IN_CURRENT_VERSION="批量编译以下VI，因为当前版本的LabVIEW未编译这些VI："
ERROR_EMPTY_WORKSPACEFILE="您没有指定工作区文件。"
ERROR_FILE_NOT_FOUND="TestStand 找不到文件 %s。"
ERR_BROKEN_VI="以下 VI 已损坏："
ERR_BROKEN_VI_BEFORE_BUILD="以下 VI 在源文件中损坏："
ERR_BROKEN_VI_AFTER_BUILD="以下 VI 在 LabVIEW 部署过程中损坏："
ERR_BROKEN_VI_CALLED_FROM="%s 呼叫自："
ERR_BROKEN_VI_INCLUDED_TOP_LEVEL="<作为顶级文件包含在部署中>"
ERR_DIST_VI_BROKEN="无法加载以下文件："
ERR_DIST_VI_CANNOT_RUN="无法执行以下文件："
ERR_DUPLICATE_VI_OR_LIBRARIES Line0001 ="以下 VI 或项目库名称重复。\n"
ERR_DUPLICATE_VI_OR_LIBRARIES Line0002 ="您必须更改重复的 VI 名称或将 VI 添加到项目库中。"
SHARED_VARIABLES_NOT_SUPPORTED_WITH_PPL="部署的文件包含共享变量。TestStand 不支持在打包的项目库中部署共享变量。以下库包含共享变量："
ERR_FILE_IN_MEMORY="LabVIEW 正在使用与其中一个目标文件同名的文件。National Instruments 建议您在构建部署之前关闭 LabVIEW。"
ERR_CANNOT_DELETE_SYSTEM_DIRECTORY="无法删除以下受保护目录："
ERR_NO_USER_SOURCE_SPECIFIED="从目录部署文件选项在系统源选项卡上启用，但未指定目录。"
ERR_INVALID_USER_SOURCE_SPECIFIED="您在从目录部署文件字段中指定的目录在磁盘上找不到"
ERR_LABVIEW_DEV_REQUIRED_TO_DEPLOY="部署 LabVIEW 文件需要 LabVIEW 开发系统。"
ERR_PATH_TOO_LONG_BUILDING_PPL Line0001 ="打包项目库中 VI 的总路径长度太长。缩短基本库名称或可部署映像的位置可能会解决此问题。\n"
ERR_PATH_TOO_LONG_BUILDING_PPL Line0002 ="受影响的打包项目库路径为："
ERR_UNEXPECTED_LIBRARY_NAME="在源分发中创建的库无效。联系 National Instruments 以获得支持。创建的文件是："
ERR_PPL_CANNOT_BE_READ="部署包含无法打开的打包项目库。部署前使用 LabVIEW 的活动版本重建打包项目库。"
ERR_COMPILER_OPTIMIZATION_SETTINGS_DONT_MATCH="LabVIEW 无法编译一个或多个 VI，因为目标或操作系统的 SSE 设置与您尝试构建的应用程序中的 VI 设置不匹配。"
ERR_METHOD_CALLS_NOT_SUPPORTED="当前版本的 LabVIEW 不支持调用 LabVIEW 类成员。"
LABVIEW_VERSION_NOT_SUPPORTED_32="此应用程序不支持 LabVIEW 的活动版本。支持的 LabVIEW 最低版本为 %s"
LABVIEW_VERSION_NOT_SUPPORTED_64="此应用程序不支持 LabVIEW 的活动版本。支持的最低 LabVIEW 版本是 %s"
LABVIEW_VERSION_NOT_SUPPORTED="此应用程序不支持 LabVIEW 的活动版本。支持的 LabVIEW 最低版本为 %s"
ERR_FILE_NEEDS_DEEPER_DEST_KEEP_RELATIVE_PATHS_DEPS= "以下打包项目库包含不在图像目录或其子目录中的依赖项："
ERR_FILE_WILL_NEVER_INSTALL Line0001 = "补丁安装程序中的以下文件不会替换之前的完整部署或补丁部署安装程序中的文件 "
ERR_FILE_WILL_NEVER_INSTALL Line0002 = "已安装，因为文件的版本号不大于完整部署中包含的文件的版本号"
ERR_FILE_WILL_NEVER_INSTALL Line0003 = "或之前的补丁部署："
ERR_FILE_ABOVE_INSTALLDIR="补丁部署中的以下文件被配置为安装在高于完整部署安装程序安装目录的目录中："
ERR_FILE_ABOVE_INSTALLDIR_DETAILS Line0001="补丁部署中的以下文件被配置为安装在高于完整部署安装程序安装目录的目录中。\n"
ERR_FILE_ABOVE_INSTALLDIR_DETAILS Line0002="完整分发的根目录是：\"%s\""
ERR_INSTALLER_TO_PATCH_NOT_CORRECT Line0001="安装程序选项选项卡上指定的完整部署安装程序没有预期的升级代码或版本号。"
ERR_INSTALLER_TO_PATCH_NOT_CORRECT Line0002="需要完整部署生成的安装程序才能创建补丁。"
ERR_DUPLICATE_DESTINATION_ADDED_FILE_AND_REPLACEMENT_PATH="补丁部署中的以下目标对于添加文件和替换文件是相同的："
ERR_INSTALLER_PATH_OVERWRITING_REQUIRED_INSTALLER="补丁部署安装程序配置为覆盖创建补丁部署所需的安装程序。为补丁安装程序选择另一个目录。"
ERR_DEPENDENT_INSTALLER_NOT_FOUND="未找到以下安装程序的部署信息。请联系 National Instruments 以获得支持。"
ERR_LV_VERSION_CHANGE_IN_PATCH="您正在使用不同版本的 LabVIEW 开发系统来创建补丁部署，而不是您用来创建完整部署的版本。"
ERR_LV_VERSION_CHANGE_IN_PATCH_DETAILS Line0001="用于依赖分布的版本是 %s。\n"
ERR_LV_VERSION_CHANGE_IN_PATCH_DETAILS Line0002="当前发行版使用的版本是 %s。"
ERR_INCONSISTANT_CASE="序列文件引用了以下路径中大小写不一致的代码模块。使用 TestStand 序列编辑器编辑序列文件并使大小写一致。"
ERR_INVALID_PROJECT_ITEM_PATH="以下文件的程序项路径无效："
ERR_CANNOT_SAVE_WITHOUT_BLOCK_DIAGRAM="LabVIEW 无法从一个或多个 VI 中删除程序框图，因为 VI 已损坏。使用"检查损坏的 VI"选项并重建部署以获得有关导致失败的特定 VI 的更多信息。"
ERR_MODULE_NOT_SPECIFIED="未指定以下步骤的代码模块："
ERR_MODULE_NOT_EXPORTED="无法导出以下步骤的代码模块："
ERR_BUILDING_GLL="使用项目 '%s' 构建 GLL 时发生错误。有关详细信息，请参阅附加错误信息日志消息。"
PSEUDOPATH_NOT_CONVERTED="TestStand 部署实用程序在加载 TSD 文件时无法解析相对路径。"
COULDNT_FIND_PROJECT_ITEM_ABSOLUTE_PATH Line0001="无法打开指定的工作区文件。\n"
COULDNT_FIND_PROJECT_ITEM_ABSOLUTE_PATH Line0002="受影响对象的显示名称是："
SETUP_ERROR="无法从注册表中读取所需信息。"
ERROR_PRODUCT_NOT_FOUND="以下 TestStand 功能未安装或安装未完成："
FEATURE_NOT_SUPPORTED_IN_LABVIEW="当前LabVIEW开发系统版本不支持以下功能：\n"
FEATURE_NOT_SUPPORTED_IN_LABVIEW_VERSION="LabVIEW 开发系统的活动版本 (%s) 不支持以下功能：\n"
FEATURE_NOT_SUPPORTED_PROJECTS="LabVIEW 2009 之前的版本不支持项目部署。"
FEATURE_NOT_SUPPORTED_METHOD_CALLS="LabVIEW 2012 之前的版本不支持使用方法调用部署序列。某些代码模块使用版本 %s 调用。"
FEATURE_NOT_SUPPORTED_PACKED_LIBRARIES="LabVIEW 2010 之前的版本不支持打包项目库的部署。"
LV_VERSION_DOESNT_SUPPORT_DEPLOYING_PROJECTS = "当前版本的 LabVIEW 不支持在项目中部署 VI。"
LV_VERSION_DOESNT_SUPPORT_DEPLOYING_PROJECTS_DETAILS="LabVIEW 2009 或更高版本支持项目部署。您当前使用的是版本 %s。"
COULDNT_GET_VI_CALLED_IN_PROJECT = "无法找到以下项目引用的 VI："
COULDNT_GET_CHILDREN_IN_PROJECT = "无法获得以下项目项目的子项："
COULDNT_GET_ROOT_OF_PROJECT = "无法获取以下项目的根目录："
ERR_READING_NIDIR="无法从注册表中读取 National Instruments 目录。"
SAME_AS_FIRST="（与第一个文件相同）"
ERR_VI_NOT_OPENABLE="LabVIEW 无法打开以下 VI："
OPENING_LV_PROJECT= "无法打开以下 LabVIEW 项目："
GETTING_TAG_NAMES = "无法获取以下 LabVIEW 项目的标签名称："
GETTING_MY_COMPUTER = "无法在以下 LabVIEW 项目中获取我的电脑目标："
CREATING_HASH_TABLE = "尝试创建哈希表错误信息："
CREATING_LV_PROJECT = "无法创建以下 LabVIEW 项目："
CREATING_LV_PROJECT_ITEM = "无法创建以下 LabVIEW 项目项："
SAVING_LV_PROJECT = "无法保存以下 LabVIEW 项目："
NO_CORRESPONDING_PRO_ITEM = "无法在目标项目中找到相应的项目项："
PROJECT_IN_MEMORY = "以下项目在 LabVIEW 开发系统中打开。在创建部署之前关闭所有项目。"
PPL_IN_MEMORY= "以下打包项目库在活动的 LabVIEW 开发系统中打开。关闭并重新启动 LabVIEW 开发系统以卸载所有文件。"
CANT_FIND_DOTNETPART= "缺少 .NET Framework 2.0 的可部署组件。"
DEST_PATH_TOO_LONG="以下目标路径太长："
LVLIBP_IN_PATH Line0001 ="部署中以下文件的目标路径包括扩展名 \".lvlibp\"。 "
" LVLIBP_IN_PATH Line0002 ="无法在打包的项目库中创建扩展名为 \.lvlibp\ 的目录。
FILE_MOVED="加载期间，更新了以下目录的目标："
INVALID_DIR="无法读取或写入以下目录："
SPECIFIC_INVALID_DIR="无法写入 %s 目录："
SPECIFIC_INVALID_DIR_TARGET="目标"
SPECIFIC_INVALID_DIR_INSTALLER="安装程序"
SPECIFIC_FILE_MOVED="将 %s 的位置更新为："
SPECIFIC_FILE_MOVED_TARGET="目标目录"
SPECIFIC_FILE_MOVED_INSTALLER="安装程序目录"
ERR_FILE_NOT_FOUND="未找到以下文件："
ERR_LINKER_FILE_NOT_FOUND="未找到以下 LabVIEW 文件。来自 LabVIEW 的其他错误信息记录在单独的消息中。"
ERR_SPECIFIC_FILE_NOT_FOUND="找不到 %s："
ERR_SPECIFIC_FILE_NOT_FOUND_README="自述文件"
ERR_SPECIFIC_FILE_NOT_FOUND_LICENSE="许可证文件"
ERR_SPECIFIC_FILE_NOT_FOUND_WORKSPACE="工作区文件"
ERR_UPDATING_PATHS = "更新序列文件中的模块路径时发生错误。"
ERR_UPDATING_PATHS_PPL_OVERRIDE_BUILD_SPEC = "TestStand 无法更新指定步骤的 PPL 覆盖对话框中的构建规范。验证 PPL 覆盖对话框中步骤的设置是否正确。"
ERR_INVALID_SETTING_VALUE = "为以下设置指定的值是空的或无效的。有关有效值的更多信息，请参阅所列设置的帮助。"

ERR_MULTIPLE_PPLS_SAME_SOURCE = "多个打包的项目库与相同的源文件关联：项目：%s，构建规范名称：%s"
ERR_BUILDING_VIS="在构建 VI 分发时 LabVIEW 发生错误。有关详细信息，请参阅具体的错误详细信息。"
ERR_CODE_MODULE_NOT_FOUND="未找到以下代码模块："
ERROR_REBUILDING_DISTRIBUTION_VIS="分发 VI 无法重建。部署将继续使用分发 VI 的缓存副本，这会对部署速度产生负面影响，但不会影响构建输出。请参阅下面的错误消息了解更多详细信息。"
ERROR_INCORRECTLY_SPECIFIED_CODE_MODULE="以下步骤中指定的代码模块路径为空、无效或无法在磁盘上找到。"
ERROR_VI_NAMESPACE_MISMATCH="以下 VI 没有预期的合格名称："
ERROR_COMPONENTS_NOT_INSTALLED=".tsd 文件中包含一个或多个未安装在系统上的产品。在构建安装程序之前，您必须在驱动程序和组件对话框中CANCEL选择这些产品。"
ERROR_INVALID_MAX_CONFIGURATION="MAX 硬件配置文件无效。确认在驱动程序和组件对话框中选择了所需的组件。确认驱动程序和组件对话框中的硬件配置文件设置指定了有效的配置文件路径。"
ERROR_PKG="构建包分发时出错"
ERROR_BUILD_GLL="重建指定的 GLL 时出错"
ERROR_NIPM_NOT_INSTALLED="要创建基于包的部署，必须在系统上安装 NI 包管理器和包部署支持。"
ERROR_NIPM_NO_INSTALLED_PACKAGES="系统中未找到 NI 包。确保已安装 NI 包管理器。"
NIPM_NOT_INSTALLED_DETAILS="您可以通过重新运行 TestStand 安装程序并在功能树中选择 NIPM 来安装所需的软件，或者通过从 ni.com 安装 NI Package Manager，然后在 NI Store 安装 TestStand %s feed。"
NIPM_DEPLOYMENT_NOT_INSTALLED_DETAILS="您可以通过重新运行 TestStand 安装程序并在功能树中选择 NIPM 来安装所需的软件，或者通过在 NI Package Manager 的 NI Store 中安装 TestStand %s feed。"
ERROR_NXG_NOT_INSTALLED="要部署LabVIEW NXG代码模块，您必须安装LabVIEW NXG开发系统。以下步骤参考LabVIEW NXG代码模块。"
ERROR_CREATING_PPL="无法在部署中创建的打包项目库中找到指定步骤的代码模块。"
INFO_ADDITIONAL_ERROR_INFO="附加错误信息："
DEPLOYMENT_SUPPORT_PKG_NOT_INSTALLED="生成存储库和包安装程序所需的'ni-package-manager-deployment-support'包未安装在系统上。"
ERR_GLL_NOT_SPECIFIED = "没有 GLL 与指定的步骤关联。为了部署使用 LabVIEW NXG 适配器的步骤，它必须有关联的 GLL。"
COMPONENT_NOT_MIGRATED="指定的 TestStand 组件未迁移到当前版本的 TestStand。验证是否在驱动程序和组件对话框中选择了所需的组件。"
COMPONENT_MIGRATED_TO_NEW_FEATURE="指定的 TestStand 组件是从以前版本的 TestStand 迁移的。验证是否在驱动程序和组件对话框中选择了所需的组件。"
CONSULT_ONLINE_HELP="有关解决部署错误的更多信息，请参阅 NI TestStand 帮助。"
MOVED_SOURCE_DEST_FROM_TO="已将源文件 %s 目标从 %s 移动到 %s。"
ERROR_WORKSPACEFILE_NOT_FOUND="无法在 TestStand 工作区中找到指定的文件。"
UNKNOWN_WARNING="以下文件生成警告代码 %d:"
SOURCE_GOING_TO_DESTINATION="%s 要去 %s"
PATH_IN_PATH="%s 在 %s"
FROM_PATH_TO_PATH="从 %s 到 %s"
ADD_SEARCH_DIR_TO_FIX="确保以下目录在搜索目录列表中，并且搜索目录包含在部署中。\n%s"
NO_SEARCH_DIR_FIX="无法确定部署计算机上所需的搜索目录，以将模块路径解析为文件目标。为确保可以找到代码模块，请创建并部署一个搜索目录，将模块路径解析为目标路径，或将模块文件的基本目标更改为 <%s>，以匹配调用方的基本目标。\n调用方路径：%s\n模块路径：%s\n目标路径：%s"
NO_SEARCH_DIR_FIX_PPL="无法确定部署计算机上所需的搜索目录，以将模块路径解析为文件目标。为确保可以找到代码模块，请创建并部署一个搜索目录，该目录将模块路径解析为目标路径，或将模块文件的基本目标更改为 <%s>，以匹配调用方的基本目标。\n调用方路径：%s\n上一个模块路径：%s\n更新的模块路径：%s\n目标路径：%秒"
PROJ_NESTED_IN_PROJ="%s 嵌套在 %s 中"
UPDATED_PATH_NOT_FOUND="原来在 %s 的文件在 %s 找不到"
WARN_AUTOBUILD_WARNING="从命令行参数对部署应用修改时出现以下警告。"
WARN_UPDATING_PATHS_MOVED_TSD="加载 .tsd 文件时，在原始位置或更新后的位置找不到以下文件："
WARN_NESTED_PROJECT_NOT_PROCESSED="以下项目文件被另一个项目引用，未被处理："
WARN_COULD_NOT_GET_CDS_FOR_PROJ = "无法获取以下 LabVIEW 项目的条件禁用符号："
WARN_CONSOLIDATE_HEADER = "无法合并项目共享的文件。在没有合并的情况下构建。解决此警告以减少构建时间。"
WARN_UNEQUAL_CDS_AMONG_PROJS = "无法合并 LabVIEW 项目，因为项目中定义的条件禁用符号对于以下 LabVIEW 项目是不同的："
WARN_COULDNT_CHECK_PROJECTS_OTHER_TARGETS = "无法检查除我的电脑以外的目标项目："
WARN_COULDNT_MERGE_LOOSE_VI_DIFFERENT_DESTS = "无法合并，因为部署将文件安装到多个安装目标。"
WARN_COULDNT_MERGE_PROJS_DIFFERENT_DESTS = "无法合并，因为一些项目文件位于多个安装目标中。"
WARN_MISSING_LVRTE = "安装程序不包含执行 VI 所需的以下 LabVIEW 运行时引擎。如果包含 LabVIEW 2017 运行时引擎或更高版本并在 LabVIEW 适配器设置中启用"向后兼容运行时引擎"选项，您可以忽略这个警告。"
WARN_MISSING_LVRTE_NOT_INSTALLED="安装程序不包括执行 VI 所需的以下 LabVIEW 运行时引擎，因为它们未安装在该系统中："
WARN_COULDNT_FIND_TARGET_WITH_SOURCEID="无法在项目中找到具有以下源 ID 的目标："
INC_LV_NO_RTE="此安装程序包括使用 LabVIEW %s 编译的 VI。"
WARN_PROJECTS_HAS_OTHER_TARGETS = "无法合并以下 LabVIEW 项目，因为这些项目包含的目标不是我的电脑："
WARN_COULDNT_CREATE_HASH_TABLE="无法创建哈希表。"
WARN_MERGING_CREATED_CONFLICTS = "无法合并 LabVIEW 项目，因为多个项目包含以下具有相同文件名的文件："
WARN_COPYING_TAGS_NULL_SOURCE="复制使用无效源调用的标签。"
WARN_COPYING_TAGS_NULL_DEST="复制使用无效目的地调用的标签。"
WARN_COULDNT_CHECK_FOR_CONFLICTS = "无法检查以下项目中的冲突："
WARN_COULDNT_FIND_CORRESPNDING_ITEM="无法找到具有以下名称的 LabVIEW 项目项："
WARN_UNEXPECT_PROJECT_ITEM_TYPE="对以下 LabVIEW 项目项类型使用默认处理："
WARN_NONASCII_PATHS_IN_ENGLISH_INSTALLER="以下文件名包含非 ASCII 字符并包含在英语安装程序中："
CUSTOM_SEQUENCE_FILES="您的部署包含自定义序列文件。自定义序列文件无法更新或搜索依赖项。"
WARN_COULDNT_SAVE_CUST_SEQUENCE_FILES="以下自定义序列文件尚未处理。确认所有相关文件都部署到正确的位置。"
WARN_NOT_PROCESSING_CUST_SEQUENCE_FILES="以下自定义序列文件未针对相关性进行处理。您必须包括这些文件中的所有相关性。"
WARN_VI_TOP_SUB_DIFF_LOCATIONS="部署包括将以下代码模块VI引用为顶级VI和子VI的序列文件，并且VI被配置为部署在两个不同的基本目录中。如果TestStand执行加载一个，这种情况会导致加载失败在将 VI 作为顶层 VI 加载之前，将这些 VI 作为子 VI。"
WARN_NO_PATH_BETWEEN_FILES="序列文件和代码模块之间不存在相对路径。"
WARN_DEP_NOT_SELECTED="检测到以下依赖项，但它们不会包含在部署中。您必须确定是否将这些文件包含在分布式文件选项卡上。"
WARN_INSTALLER_REQUIRES_TESTSTAND="因为此安装程序会复制 TestStand 目录中的文件，所以您必须在运行安装程序之前安装 TestStand。"
WARN_DESTINATION_CHANGED="以下文件的目标已更改，以防止与 National Instruments 产品发生冲突："
WARN_NI_DESTINATION="以下文件的目的地被配置为安装在标准的 National Instruments 目录中，这可能与 National Instruments 产品冲突："
WARN_DUPLICATE_NAME="以下文件有重名。您必须重命名文件以避免在构建可部署映像或安装程序时出错。"
WARN_GENERIC_VI_PROCESSING="处理 VI 时出现以下警告："
WARN_COULDNT_CHECK_VI="LabVIEW 开发系统的活动版本无法加载以下 VI："
WARN_BROKEN_VI="以下 VI 已损坏并在构建可部署映像或安装程序时导致错误："
WARN_ABS_PATH_IN_SUBSTEP="以下子步骤配置为使用绝对路径调用代码模块："
WARN_INVALID_PATH_IN_SUBSTEP="以下子步骤包含无效路径并在构建可部署映像或安装程序时导致错误："
WARN_NO_FILE_SPECIFIED="以下步骤没有指定任何文件："
WARN_FILE_NOT_FOUND="未找到以下文件，这会在构建可部署映像或安装程序时导致错误："
WARN_FILE_NOT_RTF="您选择了一个非富文本格式 (.rtf) 的文件："
WARN_SEQ_CALLED_FILE="您可能需要添加以下表达式引用的序列文件。如果您\n正在分发调用的文件，请忽略此消息。"
WARN_PPL_DEPENDENCIES_MISSING = "已部署库中的一个或多个文件在磁盘上丢失，这可能导致部署忽略您直接包含在部署中的打包项目库的依赖项。有关丢失文件的信息，请参阅详细信息。"
WARN_CANNOT_SWITCH_MODELS_64BIT = "64 位部署不支持'TestStand 运行时安装程序使用的流程模型'选项。部署将使用默认选项。要在已部署系统上使用遗留模型，请手动部署遗留流程模型，或运行目标计算机上的旧模型切换器工具。"
ERR_INVALID_ACTIVE_ENV_PATH="您指定的环境文件包含一个或多个无效的自定义路径。环境文件中的路径必须存在于磁盘上，此应用程序才能使用环境文件。此外，环境文件可能未存储在磁盘上指定的时间范围内环境路径"
ERR_INVALID_DEST_ENV_PATH="您指定的环境文件包含一个或多个无效的自定义路径。部署环境文件时，环境文件中指定的所有路径都必须是相对路径。"
ERR_NON_EXISTANT_ENV_FILE_PATH="磁盘上不存在指定的活动环境文件路径。"
ERR_INVALID_ENV_FILE_PATH="指定的活动环境文件路径无效。"
INFO_ACTIVE_ENVIRONMENT_CHANGED_IN_PATCH="活动环境文件中指定的自定义路径与构建完整部署时使用的路径不匹配。"
ERR_DEST_ENVIRONMENT_CHANGED_IN_PATCH="目标环境文件中指定的自定义路径与完全部署中部署的文件中的路径不匹配。"
WARN_ENV_FILE_HAS_NO_PATHS="指定的活动环境文件\"%s\" 没有定义此应用程序支持的任何自定义路径。"
WARN_DEST_ENV_FILE_HAS_NO_PATHS="指定的目标环境文件\"%s\" 没有定义此应用程序支持的任何自定义路径。"
WARN_REQUIRED_PKG_VER_NOT_INSTALLED="系统上安装的版本不满足指定包的版本要求。"
WARN_GLL_NOT_REL_TO_PROJ="对于以下步骤，GLL 相对于项目文件的位置已更改。该步骤将是可执行的，但您将无法在不更新 GLL 路径的情况下在目标机器上重建 GLL。"
WARN_NXG_NOT_SUPPORTED_32_BIT="部署中的一个或多个步骤调用 LabVIEW NXG 代码模块，32 位 TestStand 不支持这些模块。要部署 LabVIEW NXG 代码模块，您必须使用该应用程序的 64 位版本。"
WARN_NO_CORRESPONDING_PKG = "未安装提供以下必需产品的软件包。 在执行部署的文件之前，必须在测试站计算机上安装该产品。"
WARN_INSTALLER_SETUP = "由于已知的 Microsoft 安全漏洞，不推荐安装程序名称'Setup.exe'。您可以使用高级安装程序设置对话框中的'安装程序可执行文件名称'选项为安装程序可执行文件配置不同的名称。请参阅TestStand 帮助以获取更多信息。"
WARN_DUPLICATE_PPLS = "以下文件具有重复的限定名称，但位于磁盘上的多个位置。如果文件不相同，这可能会在运行测试系统时导致意外行为。"

INFO_USING_ENV_FILE="您选择的环境文件 \"%s\" 为一个或多个 TestStand 目录指定了自定义路径："
INFO_DEPLOYING_ENV_FILE="您选择的环境文件 \"%s\" 指定了以下 TestStand 目标目录的自定义路径。"
INFO_DEPLOYING_ENV_FILE_UI Line0001="根据您选择的环境文件设置，此部署要求测试站计算机上的用户界面使用以下环境文件才能正常运行。"
INFO_DEPLOYING_ENV_FILE_UI Line0002="请参阅 TestStand 帮助以获取有关将环境文件与 TestStand 用户界面一起使用的更多信息。"
INVALID_ENVIRONMENT_DIRECTORY="活动环境文件中指定的自定义路径是绝对的或无效的"
ENV_FEATURE_DISABLED="您指定了一个活动的环境文件，但是此机器上的 TestStand 环境功能被禁用。您必须删除指定的环境文件，或者通过删除 DisableTestStandEnvironments 注册表值来启用 TestStand 环境功能。请参阅 TestStand 帮助以获取更多信息有关此注册表值的信息。注意：如果更改此注册表值，则必须重新启动此应用程序才能使更改生效。"
ENV_FEATURE_DISABLED_TOOLTIP="TestStand 环境功能被注册表中的 DisableTestStandEnvironments 值禁用。"

SPECIFIED_PROCESS_MODEL="部署会将流程模型设置为以下值："
CANNOT_READ_DEPENDENCIES_MISMATCHED_BITNESS="无法读取 DLL 依赖项，因为部署实用程序的位数与 DLL 的位数不匹配。"
LEGACY_MODELS="遗留过程模型"
DEFAULT_MODELS="默认流程模型"
SPECIFIED_PATH_WITH_EXPRESSIONS="以下序列文件使用表达式来引用代码模块。"
SPECIFIED_PATH_WITH_EXPRESSIONS_DETAILS Line0001="序列文件：%s\n"
SPECIFIED_PATH_WITH_EXPRESSIONS_DETAILS Line0002="序列：%s\n"
SPECIFIED_PATH_WITH_EXPRESSIONS_DETAILS Line0003="步骤：%s\n"
SPECIFIED_PATH_WITH_EXPRESSIONS_DETAILS Line0004="表达式：%s"
WARN_PATH_NOT_UPDATED="无法使用部署中包含的文件的相对路径更新以下路径："
WARN_PROPLDR_EXPR="无法根据步骤中指定的表达式确定限制文件的路径。确保部署包括以下表达式所需的文件。\n\n表达式：\n"
NO_PROPLDR_FILE_SPECIFIED = "<没有为一个或多个源指定源文件>"
WARN_REL_PATH_AMBIGUOUS="以下相对路径无法映射到分发中的文件："
WARN_INVALID_PATH="以下无效路径会在构建可部署映像或安装程序时导致错误："
WARN_MM_MISSING="以下合并模块丢失："
WARN_VIS_MOVED_TO_LLB="以下 VI 的文件名包含无效字符，将被复制到 SupportVIs 目录中的 IllegalFilenames.llb："
WARN_MISSING_PRODUCT="无法找到以下产品和安装类型："
WARN_VIS_NOT_CURRENT_VERISON="部署以下 VI 可能会失败，因为 VI 未使用当前 LabVIEW 版本保存："
WARN_FILES_UNCHEKED="以下丢失文件旁边的复选标记已被删除，它们未包含在部署中。使用分布式文件选项卡上的源视图来定位并重新选择文件。"
WARN_UNPROCESSED_FILE_OVERWRITING_IN_IMAGE="图像目录中已经存在以下未处理的文件："
WARN_UNPROCESSED_FILE_OVERWRITING_VI="未处理的文件会覆盖以下 VI："
WARN_COULDNT_MERGE_LOOSE_VI_SHARED_WITH_PROJECTS="无法合并 LabVIEW 项目，因为一些 VI 被 LabVIEW 项目上下文和 LabVIEW 项目上下文中的测试序列引用。"
WARN_COULDNT_UPDATE_VIS_NAMESPACE="无法更新 VI 命名空间："
WARN_COULDNT_UPDATE_URL="无法更新 VI 路径："
WARN_TOP_LEVELS_FROM_LV_FOLDERS="部署包含来自 vi.lib 或 instr.lib 的顶级文件，如果您修改部署的文件，这可能导致交叉链接。"
WARN_CHANGED_PPL_NAME_FOR_USER_PROJECT Line0001="该部署包含具有相同名称且指向相同基本路径的项目。"
WARN_CHANGED_PPL_NAME_FOR_USER_PROJECT Line0002="National Instruments 建议您使用唯一的项目名称。"
WARN_CHANGED_PPL_NAME_FOR_USER_PROJECT Line0003="为避免名称冲突，修改了为以下项目创建的打包项目库的名称："
WARN_FILES_GOING_IN_SYSTEM_DIRECTORY Line0001="以下位置在受保护的目录中。无法删除此目录中的文件。"
WARN_FILES_GOING_IN_SYSTEM_DIRECTORY Line0002="National Instruments 强烈建议您为映像或安装程序目录选择另一个目录。"
WARN_LABVIEW_FILES_NO_LABVIEW_DEV ="部署 LabVIEW 文件需要 LabVIEW 开发系统。"
WARN_VIS_IN_FPGA_TARGET_NOT_INCLUDED Line0001="打包项目库的源代码不包含 FPGA 目标下的 VI。您可以使用包含的位文件构建打包项目库。\n"
WARN_VIS_IN_FPGA_TARGET_NOT_INCLUDED Line0002= "将要包含的 VI 从 FPGA 目标添加到 TestStand 工作区并启用包含而不处理\n"
WARN_VIS_IN_FPGA_TARGET_NOT_INCLUDED Line0003= "分布式文件选项卡上的项目或依赖项选项。"
WARN_MEMORY_LEAK="以下 LabVIEW 文件未正确关闭。如果报告的上下文包含'Build Context'，您可以忽略此警告。"
WARN_XNODE_IN_DEPLOYMENT="此部署包括 XNode。使用这些 XNode 的 VI 在 LabVIEW 运行时引擎中运行正常，但当您从 LabVIEW 打开文件时显示损坏。"
WARN_EXPECTED_RELATIVE_PATH="预期以下路径的相对路径："
WARN_EXPECTED_ABSOLUTE_PATH="预期以下路径的绝对路径："
WARN_FILTER_ADDED="以下文件已被过滤："
WARN_EXCLUSION_ADDED="以下文件已被排除："
WARN_TARGET_DIR_MOVED="已将可部署映像的位置更新为："
WARN_INSTALLER_DIR_MOVED="将安装程序目录更新为："
WARN_ENGINE_LEGACY_MODELS_LEGACY_MODELS_NOT_ACTIVE="当前活动的进程模型与 TestStand Runtime 安装程序将包含的进程模型不匹配。您的计算机当前具有默认进程模型，但安装程序将使用遗留进程模型。"
WARN_LEGACY_MODELS_ACTIVE_INSTALLER_USING_DEFMODELS="当前活动的进程模型与 TestStand Runtime 安装程序将包含的进程模型不匹配。您的计算机当前具有遗留进程模型，但安装程序将使用默认进程模型。"
WARN_NON_REFEREENCED_LV_PROJECT="以下 LabVIEW 项目未被 TestStand 序列文件中的任何步骤引用，也不会更新："
WARN_FILE_VERSION_NOT_GREATER="补丁部署中包含的以下文件的文件版本不高于完整部署中包含的文件的文件版本："
WARN_PATCH_REMOVED_VIS_FROM_LLB="以下 LLB 不包含依赖部署中包含的所有 VI："
WARN_COULDNT_GET_CRC_FOR_VI="无法获取以下文件的 CRC 值，调用这些文件的序列需要使用 Update VI Calls 工具进行更新："
WARN_SOURCE_PATH_CHANGED="以下文件的源文件路径与依赖部署中包含的文件的源文件路径不同："
WARN_SOURCE_MODIFIED_IMAGE_UNMODIFIED="以下源文件已修改，但图像文件未修改："
WARN_CURRENT_IMAGE_DOES_NOT_CONTAIN_FILE="当前图像不包含以下文件："
WARN_FILE_DESTINATION_CHANGED= "以下文件的目的地在当前补丁部署中发生了变化："
WARN_PROJECT_MISSING_FILES = "以下项目库未引用依赖部署中包含的同一组文件："
WARN_PROJECT_LIBRARY_MISSING_FILES = "以下项目库未引用依赖部署中包含的同一组文件："
WARN_PROJECT_LIBRARY_MISSING_EXPORTS = "以下打包项目库缺少完整部署中包含的导出："
WARN_UPGRADE_USING_DEFAULT_FLAVOR = "以下安装程序的安装程序类型与完整部署中使用的类型不匹配："
WARN_MODIFIED_MAX_CONFIGURATION_FILE= "指定的 MAX 配置文件已修改。考虑将其包含在补丁部署中。"
WARN_MODIFIED_NOT_INCLUDED_FILE="以下文件未包含在补丁部署中，因为文件状态设置为未包含，但文件已被修改："
WARN_COULDNT_GET_LV_REF_DID_NOT_RECORD_PROJLIB_CONTS="由于 LabVIEW 没有响应，部署中包含的项目库内容未被记录。"
WARN_DRIVER_DOWNGRADE="以下驱动程序和组件已降级："
LABVIEW_BITNESS_MISMATCHED="LabVIEW 的位数与该应用程序的位数不匹配。"
MACRO_NOT_SUPPORTED_IN_BITNESS="当前位数不支持宏"			
DESTINATION_NOT_SUPPORTED_IN_BITNESS="当前位数不支持目标"
ERROR_BITNESS_CHANGED_PATCH="生成补丁时更改了位数。补丁必须与完整部署具有相同的位数。"
using_macros="使用以下宏"
using_destination="使用以下目的地"
DRIVER_DOWNGRADE_EXPRESSION="%s 从版本 %s 降级到版本 %s"
FLAVOR_NO_LONGER_PRESENT_FORMAT="%s 旧类型 %s 新类型 %s"
DEST_CHANGED_FORMAT="%s 移动到 %s"
INVALID_DVRS="内部数据结构无效中止构建"
UpgradingInstaller="升级安装程序"
UpgradingTSEngine="正在将 TestStand 运行时升级到 "
FromStringToString="从 %s 到 %s。"
ADDED_FULL_FLAVOR_OF_NI_DAQ= "包括完整的 NI-DAQmx 以防止 NI-DAQmx 8.X 出现升级问题。"
InstallingPatchStringToString="%s 到 %s。"
PATCH_HEADER Line0001="创建补丁：\n"
PATCH_HEADER Line0002="部署版本：%s 构建于：%s\n"
PATCH_HEADER Line0003="补丁将更新：部署版本：%s 构建于：%s\n"
PATCH_HEADER Line0004="<图像目录> 是 %s\n"
REQUIRED_PATCH_NOT_INSTALLED="此安装程序需要安装依赖项部署（版本 %s）。安装所需的版本或联系支持以获取更多信息。"
PATCH_DID_NOT_ADD_FILES= "\n这个补丁不包含任何额外的新文件。"
PATCH_INCLUDED_INSTALLERS="此补丁包括以下更新和补丁："
PATCH_DID_NOT_ADD_INSTALLERS="这个补丁不包括对 NI 驱动程序和组件的任何更新或补丁。"
PATCH_ADDED_FOLLOWING_FILES= "\n这个补丁包括以下额外的新文件："
PATCH_DID_NOT_UPGRADE_FILES = "\n这个补丁没有升级文件。"
PATCH_UPGRADING_FOLLOWING_FILES= "\n这个补丁包括以下文件："
PATCH_DOES_NOT_HAVE_UNCHANGED_FILES = "\n这个补丁没有保留任何文件不变。"
PATCH_DID_NOT_UPDATE_FOLLOWING_FILES = "\n这个补丁不包括以下文件："
PATCH_REMOVED_PREV_PATCHES= "\n这个补丁不包括以前补丁中的以下文件："
NONVISUPGRADE="不可见升级。名称：%s；版本：%s；升级版本：%s；产品 ID：%s\n 描述：%s\n"
DRIVERORCOMPONENTNOTINSTALLED="不再安装以下驱动程序或组件：名称：%s 产品 ID：%s"
REQUIRED_BY="要求："
TOP_LEVEL_FILE="此文件由用户包含"
PATCH_IMAGE_DIRECTORY="<图像目录>\\"
EMBEDDED_EXPRESS_VI="内嵌Express VI"
FROM="来自"
FROM_SOURCE_FILES = "来自源文件："
PATCH_FILE_VERSION= "（版本："
SRC_MODIFIED= "（修改："
FILE_IN_PATCH= "补丁包括 "
FILE_IN_FULLDIST= "包含完整部署 "
SOURCE_CHECKSUM_ENTRY="源文件"
IMAGE_CHECKSUM_ENTRY="图像文件"
CHECKSUM_PATCH_LOG_ENTRY = "（校验和："
FILTERED_MATCHES_EXPRESSION="\"%s\" 被过滤，因为它匹配 \"%s\""
EXCLUDED_MATCHES_EXPRESSION_FILE="\"%s\" 被排除，因为它匹配排除的文件名 \"%s\"。\n（被文件名排除 \"%s\"" 排除）"
EXCLUDED_MATCHES_EXPRESSION_DIR="\"%s\" 被排除在外，因为它位于目录 \"%s\" 中。\n（被包含目录排除\"%s\"）"
EXCLUDED_MATCHES_EXPRESSION_PRODUCT="\"%s\" 被排除，因为它是排除产品\"%s\" 的组成部分。\n（被相关产品或公司排除\"%s\"）"
EXCLUDED_UNSUPPORTED_EXTENSION="\"%s\" 已被排除，因为它具有不受支持的文件扩展名 \".%s\""
EXCLUSION_DIR="目录"
EXCLUSION_PRODUCT="产品"
EXCLUSION_FILE="文件"
VIS_IN_MEMORY_TITLE="警告"
CONTINUE_VIS_IN_MEMORY="继续"
ABORT_VIS_IN_MEMORY="中止"
VIS_IN_MEMORY_MESSAGE="以下 VI 在 LabVIEW 开发系统中打开。%s\nNational Instruments 不建议在部署构建过程中打开任何 VI。是否要中止当前部署构建？"
ABORTED_BY_USER_VIS_IN_MEMORY="用户中止构建，因为 VI 在内存中。"
ERR_MEMORY_LEAK="以下 LabVIEW 文件未正确关闭。如果报告的上下文包含'Build Context'，您可以忽略此错误。"
ERR_DEPENDENCIES_IN_NESTED_LIBS="TestStand 不支持使用 LabVIEW 2010 部署使用嵌套库作为依赖项的打包项目库。"
Include_Feature="包含特征"
DIR_NOT_EMPTY="文件夹 %s 不为空。您要在构建之前从该文件夹中删除所有文件吗？"
Include_Feature_and_All_Sub_Features="包括特征和所有子特征"
Do_Not_Include_Feature="不包含特征"
INVALID_INSTALLER_DIR="无效的安装程序目录。"
MISSING_ENGINE_REQ="%s:\n %s 缺少要求 %s\n"
MISSING_DEP="%s 找不到相关性\n%s"
WINDOWS_KW="视窗"
WINDOWS_DIR_KW="Windows 目录"
TESTSTAND_KW="测试站目录"
SYSTEM_KW="系统"
SYSTEM32_KW="系统32"
TARGET_KW="安装目录"
PROFILES_KW="程序文件"
INSTALLATION_DIR="安装目录"
WINDOWS_SYSTEM_DIR="Windows 系统目录"
WINDOWS_SYSTEM32_DIR="Windows System32 目录"
PROGRAM_FILES_DIR="程序文件目录"
PROMENU_KW="程序菜单"
STARTUPDIR_KW="启动目录"
DSKTOPDIR_KW="桌面目录"
PERSONALDIR="个人目录"
PERSDIR_KW="个人目录"
TEMPDIR_KW="临时目录"
NIDIR_KW="美国国家仪器目录"
PUBDOCS_KW="TestStand 公共文档目录"
APPDATA_KW="TestStand 应用程序数据目录"
NIPUBDOCS_KW="美国国家仪器公共文件目录"
SYSWOW64_KW="系统WOW64目录"
GLOBALAPPDATA_KW="全球 TestStand 应用程序数据目录"
ABS_PATH_KW="绝对路径"
Installer_Exec_Directory = "安装程序可执行目录"
ALL_USERS_DIR="所有用户目录"
WINDOWS_VOLUME_KW="Windows 卷（例如，C:\）"
NO_DIRECTORY_SPEC="未指定"
SAVE_AS_OPTIONS="您要创建当前文件的备份，还是要基于当前文件创建一个新的安装程序以并行安装？"
SAVE_AS_OPTION_BACKUP="备份"
SAVE_AS_OPTION_NEW="新安装程序"

;;----------------------------------------
;;TestStand 引擎选项的说明
;;----------------------------------------
ENG="引擎"
ENGDES= "核心 TestStand 运行时的文件。"
;;CADP="C/C++ DLL 适配器"
;;CADPDES="在 C/C++ DLL 中调用代码所需的文件。"
LVADP="LabVIEW 适配器"
" LVADPDES ="调用 LabVIEW VI 和 LabVIEW 运行时引擎所需的文件。
LVREM="LabVIEW 远程执行支持"
LVFFRTE="LabVIEW 远程执行支持"
LVFFRTE_EIGHT="LabVIEW 7.0 - 8.0 远程执行支持"
LVFFRTE_EIGHTDES Line0001 = "包含 LabVIEW 适配器下载和调用远程计算机上的 LabVIEW VI 所需的文件。该组件支持远程执行 LabVIEW 7.0 到 8.0 VI。"
LVFFRTE_EIGHTDES Line0002 = "需要此组件才能将 VI 下载到运行 LabVIEW 7.0 和 7.1 实时模块的计算机。"
RTProviders="LabVIEW 实时模块下载支持"
LVRTDLDES="包含 LabVIEW 适配器将 LabVIEW VI 下载到运行 LabVIEW 实时模块的计算机所需的组件。"
LVREMDES="包含 LabVIEW 适配器在远程计算机上调用 LabVIEW VI 所需的组件。"
;;CVIADP="LabWindows/CVI 适配器"
;;CVIADPDES="调用用 LabWindows/CVI 编写的代码所需的文件。"
;;AADP="ActiveX/COM 适配器"
;;AADPDES="调用 ActiveX 自动化服务器所需的文件。"
;;NETADP=".NET 适配器"
;;NETADPDES Line0001="调用 .NET 程序集所需的文件。"
;;NETADPDES Line0002="此选项不包括 .NET Framework。"
;;NETADPDES Line0003="如果测试系统包含以 .NET 语言编写的组件，则必须单独安装 .NET Framework。"
;;HTBADP="HTBasic 适配器"
;;HTBADPDES="调用 HTBasic 子程序所需的文件。"
;;SEQADP="序列适配器"
;;SEQADPDES="调用 TestStand 序列所需的文件。"
;;NADP="<无> 适配器"
;;NADPDES="不调用代码模块的步骤所需的文件。"
XMLRPT="XML 报告生成"
XMLRPTDES="生成 XML 报告所需的文件。"
RENG="远程引擎"
RENGDES="支持远程序列执行所需的文件。"
VAR_ENG="NI 变量引擎"
VARENGDES Line0001 = "包含支持应用程序或共享库的组件，这些应用程序或共享库使用 NI 发布-订阅-协议 (PSP) 数据传输协议和共享变量来写入和 "
VARENGDES Line0002 = "读取实时数据。\n\n如果 TestStand 调用使用网络变量的 VI 或代码模块，或者如果 TestStand 部署网络变量，则包含此功能。"
LVRTE="NI LabVIEW 运行时引擎"
LV64RTE="NI LabVIEW 运行时引擎（64 位）"
LVRTEDES Line0001 = "包含 LabVIEW 运行时引擎 TestStand 用于运行 VI。用于保存 VI 的 LabVIEW 开发系统版本和用于保存 VI 的运行时引擎版本"
LVRTEDES Line0002 = "运行 VI 必须匹配。此外，整个 VI 层次结构必须存在于您部署测试系统的计算机上。部署将自动包括完整的层次结构"
LVRTEDES Line0003 = "部署中包含的所有顶级文件。"
DNFRAMEWORK=".NET Framework 安装程序"
DNFRAMEWORKDES="包含 Microsoft .NET Framework 的安装程序。"
TSDNSUPPORT="TestStand .NET 支持"
TSDNSUPPORTDES = "包含 TestStand 序列编辑器和 TestStand 用户界面控件使用的 .NET 程序集。此功能需要 .NET Framework。"
TOOLS="工具"
TOOLSDES="包含默认 TestStand 工具菜单中命令的序列文件和支持文件。"
PROMOD="默认流程模型"
PROMODDES="包含默认过程模型序列文件和支持文件，例如报告生成和数据库日志记录。"
GRAPH="图表控件"
GRAPHDES="包含用于在 TestStand 报告中显示图形的控件。"
DB="数据库和属性加载器步骤类型"
DBDES="包含数据库和属性加载器步骤类型，包括类型选项板文件和步骤类型的支持文件。"
IVI="IVI 步骤类型"
IVIDES Line0001 = "包含 IVI 步骤类型，包括类型选项板文件和步骤类型的支持文件。"
IVIDES Line0002 = "\n\n您必须安装 IVI 兼容包，可从 National Instruments 设备驱动程序 DVD 获得，以使用这些步骤类型。"
;;OI="用户界面"
;;OIDES="包含用户界面可执行文件和源文件。"
SEQED="序列编辑器"
SEQEDDES="包含 TestStand 序列编辑器应用程序和支持文件。"
DEBUGGING="调试"
DEBUGGINGDES="TestStand 功能对调试有用。"
DOCS="文档"
DOCSDES="包含位于 <TestStand>\\Doc 目录中的文档文件，包括 NI TestStand 帮助和手册的 PDF 版本。"
SRC="源代码"
SRCDES="包含 TestStand 中用户可修改的组件、API 和模板的源代码。"
EXAMP="例子"
EXAMPDES="包含位于 <TestStand>\\Examples 目录中的示例文件。"
APISOURCE="API 来源"
APISOURCEDES="TestStand ActiveX API 需要的文件。"
CODETEMPLATES="代码模板"
CODETEMPLATESDES="包含用于创建代码模块的模板的源文件。"
BCOMP="向后兼容性"
BCOMPDES="确保与早期版本的 TestStand 兼容的文件。"

;;MDAC="微软数据访问组件"
;;MDACDES="Microsoft 数据访问组件需要的文件。"
TUTORIAL="教程"
TUTORIALDES="TestStand 教程需要的文件。"
ANALYZER="TestStand 序列分析器"
ANALYZERDES="TestStand 序列分析器应用程序、内置规则和支持文件，用于定位错误、执行自定义开发指南以及收集有关 TestStand 系统的统计数据。"
;;LV61ENG="LabVIEW 6.1 运行时引擎"
;;LV61ENGDES="LabVIEW 6.1 运行时引擎需要的文件。"
;;LV71ENG="LabVIEW 7.1 运行时引擎"
;;LV71ENGDES="LabVIEW 7.1 运行时引擎需要的文件。"
;;ADAPTERS="适配器"
;;ADAPTERSDES="调用特定类型的代码模块所需的文件。"
;;FULL="全功能"
;;FULLDES="使用 TestStand 用户界面控件的全功能用户界面。"
;;SIMPLE="简单"
;;SIMPLEDES="使用 TestStand 用户界面控件的简单用户界面。"
COMPONENTS="TestStand 组件"
COMPONENTSDES="TestStand 使用的可选组件。"
OPTIONAL="TestStand 可选步骤类型"
OPTIONALDES="包含 TestStand Runtime 安装程序不包含的可选步骤类型的文件。"
DEV="TestStand 开发组件"
DEVDES="包含您通常用于开发测试系统的组件。"
;;FULLCVI="LabWindows/CVI"
;;FULLCVIDES="全功能 LabWindows/CVI 用户界面所需的文件。"
;;FULLCPP="C++ (MFC)"
;;FULLCPPDES="全功能 C++ 用户界面所需的文件。"
;;FULLCSHARP="C#"
;;FULLCSHARPDES="全功能 C# 用户界面所需的文件。"
;;FULLLV="LabVIEW"
;;FULLLVDES="全功能 LabVIEW 用户界面所需的文件。"
;;FULLVBNET="Visual Basic .NET"
;;FULLVBNETDES="全功能 Visual Basic .NET 用户界面所需的文件。"
;;SIMPLECPP="C++ (MFC)"
;;SIMPLECPPDES="简单 C++ 用户界面所需的文件。"
;;SIMPLECVI="LabWindows/CVI"
;;SIMPLECVIDES="简单 LabWindows/CVI 用户界面所需的文件。"
;;SIMPLECSHARP="C#"
;;SIMPLECSHARPDES="简单 C# 用户界面所需的文件。"
;;SIMPLELV="LabVIEW"
;;SIMPLELVDES="简单 LabVIEW 用户界面所需的文件。"
;;SIMPLEVBNET="Visual Basic .NET"
;;SIMPLEVBNETDES="简单的 Visual Basic .NET 用户界面需要的文件。"
;;TS201OIs="TestStand 2.0.1 操作界面（旧）"
;;TS201OIsDES="TestStand 2.0.1 包含的操作员界面，演示了如何直接使用 TestStand API 编写操作员界面。"
DEPLOYMENTUTILITY="TestStand 部署工具"
DEPLOYMENTUTILITYDES ="包含部署实用程序和支持文件。"

No_File_Info="<无文件信息；分析工作区>"
Awaiting_Analysis="<等待分析填充>"	
PROCESS_WORKSPACE="处理工作区：\"%s\""
TS_KW="测试台"
ERROR_OCCURED="部署测试系统时发生错误。"
GENERIC_WARNING="部署测试系统时出现警告。"
BUILD_DONE="构建完成。"
BUILD_DONE_PATCHING="如果您计划为此构建创建补丁，强烈建议您"
ERROR_DIALOGMSG="发生错误。有关详细信息，请参阅状态日志。"
BUILD_ERROR="构建过程中发生错误。有关详细信息，请参阅状态日志。"
ERROR_SEP="******************************************"
WARNING_SEP="------------------------------------"
BLD_ANALY_SEP="+++++++++++++++++++++++++++++++++++++++++"
ERR_DUP_EXPRESSNAME="以下步骤存在重复的 Express VI 名称："
FIX_DUP_EXPRESSNAME="使用位于 <TestStand>\\Components\\Tools 目录的 ForEach.seq 文件中的 GenNewUniqueStepIdsForDirectoryFix 序列来解决此问题。"
Module_Step_Sequence_File="代码模块'%s'，步骤'%s'，序列'%s'，序列文件'%s'"
ST_SEQ_SF="步骤'%s'，序列'%s'，序列文件'%s'"
EXP_ST_SEQ_SF="%s in 步骤 '%s'，序列 '%s'，序列文件 '%s'"
MM_ERROR="以下合并模块发生错误："
BUILD_WILL_DO_NOTHING="当前设置下构建不产生任何输出。"
INSTALLER_DONE="安装程序完成。"
PKG_DIST_DONE="包分发完成。"
REFERENCED_PACKAGES = "以下依赖包被主包引用"
GLL_BUILD_RESULT = "GLL 构建结果："
SUBSTEP_NOT_INCLUDED = "根据当前设置，部署中步骤类型指定的以下子步骤模块未包括在内。"
SUBSTEP_DEST_CHANGED = "部署中步骤类型指定的以下子步骤模块的目的地可能已更改。"
PYTHON_VIRTUAL_ENV_DETECTED = "以下 Python 虚拟环境目录由部署中的 Python 适配器步骤指定。确保在部署中包含这些目录。"
PYTHON_REFERENCED_VERSIONS = "部署中的 Python 适配器步骤需要以下 Python 解释器版本。确保在部署中包含这些版本的解释器。"
MAKING_INSTALLER="正在创建安装程序..."
MAKING_PKG_DIST="正在创建一个包分发..."
WARNING="警告"
ERROR="错误"
MISSING_REQ="缺少必需的功能："
ERR_COPYING_FILE="无法复制以下文件："
TO_FOR_COPY_ERROR=" 到 "
SOURCE_FILE_NOT_FOUND="无法找到以下源文件。如果您不想部署这些文件，请在分布式文件选项卡的查看构建预览视图中删除每个文件旁边的复选标记。"
FILES_CONFLICTING_DESTINATIONS="以下文件有冲突的目的地："
MAX_FOUR_REQUIRED="您必须安装 Measurement and Automation Explorer (MAX) 4.0 或更高版本才能构建包含硬件配置数据文件的安装程序。"
NOT_ENOUGH_DISK_SPACE_FOR_INSTALLER="磁盘空间不足，无法创建安装程序。"
INSTALLER_REQUIRES_MB= "此安装程序需要至少 %d MB 的可用空间。"
VI_VERSION_LATER_THAN_ACTIVE_VERSION="一个或多个子 VI 保存在比活动 LabVIEW 版本更新的 LabVIEW 版本中。"
PACKED_LIBRARY_CANNOT_BE_OPENED="顶级 VI 之一调用的打包库未保存在 LabVIEW 的活动版本中。"
READ_LINKER_ERROR="LabVIEW 在确定一个或多个顶层 VI 的依赖信息时报告了一个错误。有关详细信息，请参阅下面的错误详细信息。"
READ_LINKER_ERROR_MISSING_FILE="缺少的文件路径是：%s\n"
READ_LINKER_ERROR_MISSING_FILES="缺少 VI 的调用链：\n"
READ_LINKER_ERR_TOP_LEVEL="加载以下顶级 VI 并选择文件>>全部保存：\n%s"
LINKER_MISSING_VI="（缺失）"
NO_LINKER_RESULTS="LabVIEW 返回链接器错误，但未返回任何丢失的 VI。这可能意味着丢失的文件是 RC 文件或其他类似的依赖项。批量编译您的顶层文件并解决报告的错误。如果问题仍然存在，请联系 National支持工具。"
CALCULATING_LINKER_ERROR Line0001="检测到一个或多个缺失的依赖项。当前正在计算这些缺失依赖项的调用链。"
CALCULATING_LINKER_ERROR Line0002="请注意，这可能是一个耗时的过程。您可以随时CANCEL；如果您在缺少依赖项之前CANCEL"
CALCULATING_LINKER_ERROR Line0003="完全计算错误消息将包含到该点为止的最佳近似值，但可能不会列出一些缺失的 VI。"
PATH_TRANSFORMS_HEADER="源文件列表及其在构建中的目的地："
GENERIC_VI_PROCESSING_ERROR="处理 VI 时出现以下错误："
CANT_OPEN_MDF_ERROR="无法打开元部署工具包。保存您的工作并退出。"
INVALID_TARGET_DIR="目标目录无效。"
INVALID_WORKSPACE_SOURCE="工作区源路径无效。"
SELECT_INSTALLATION_DEST="选择安装目的地"
SELECT_INSTALLER_DIR="选择安装目录"
SELECT_WORKSPACE_TO_DISTRIBUTE="选择要分发的工作区文件"
BUILDING="建筑……"
SAVE_FILE_TITLE="保存文件"
BUILD_CHANGED_SAVE="部署配置已更改。是否保存？"
DISABLED_DEST_WARN="更改此选项将使为以下文件指定的安装目标无效。如果您继续，应用程序将在您分析文件时更新无效的安装目标，这是无法撤消的。\n\n%s\n \n 你确定要继续吗？"
DISABLED_DEST_WARN_FILE_ENTRY_FORMAT="%s（无效安装目标：%s）"
DISABLED_DEST_WARN_TITLE="更改文件目的地警告"
SAVE="保存"
WARN_SEQ_CALLED_EXPR="使用以下表达式调用了一个序列，TestStand 可能要到运行时才对其求值："
DISTRIB_VIS_REQ_LVDEVSYS="分发 VI 需要 LabVIEW 开发系统"
ERR_OPENING_LV="无法打开 LabVIEW。"
WORKSPACE_PROCESSED="已处理工作区"
SELECT_MSM_PATH="选择可再发行引擎组件目录"
PLEASE_BROWSE_TO_MSM="浏览到可再发行的引擎组件目录"
MSM_PATH="可再发行引擎组件目录"
Update_MM="更新合并模块"
Current_Path="当前路径"
UPDATE_MM_FEATURE="您可以为功能 %s 的合并模块分配一个版本号。"
UPDATE_MM_TEXT="浏览到合并模块文件并单击确定按钮以更改合并模块的版本。"
UPDATE_MM_TEXT2 ="单击CANCEL以保持当前的合并模块版本号。"
Log="日志"
EULA_DIALOG="最终用户许可协议"
EULAtext="最终用户许可协议文本"
Warning_Error_dialog="警告和错误"
Errors_and_Warnings="警告和错误"
REMOVING_OLD_FILES="正在删除旧文件"
COPYING_FILE="正在复制文件"
PROCESSING_VIS="正在处理 VI..."
END_PROCESSING_VIS="已完成处理 VI"
BEGIN_PACKING_VIS="构建 VI 图像..."
END_PACKING_VIS="构建 VI 图像"
BEGIN_BUILD="正在构建当前项目..."
END_BUILD="已完成构建当前项目"
PREPARING_VI="正在准备文件 %s"
READING_LINKER_INFO="正在从顶级 VI 读取链接信息..."
END_READING_LINKER_INFO="已阅读顶级 VI 的链接信息"
ABORTING="正在中止..."
SHUTTING_DOWN="正在关闭..."
CREATING_PROJECT="正在为部署创建临时项目"
CREATING_SOURCE_DIST="正在为部署创建源分发"
CREATING_PPL="正在创建用于部署的 LabVIEW 打包项目库"
UPDATING_LINKS="更新文件链接"
LOADING_SEQUENCE_FILE="正在更新文件链接加载"
UPDATING_SEQUENCEFILE_LINKS="正在更新文件链接"
FINISHED_PACKAGING="完成处理VI"
LOADING_MM="加载引擎组件"
ANALYZING_FILE="正在分析文件"
ANALYSIS_DONE="分析完成"
LISTING_FILE="获取文件列表"
ADDING_FILE="添加文件到源文件"
SORTING_SOURCE="排序源文件"
ARCH_32BIT="（32 位）"
ARCH_64BIT="（64 位）"
ARCH_IPF="(安腾 IA-64)"
UNKNOWN_VERSION="未知版本"
Windows_NT_6.1="Windows 7/Windows Server 2008 R2"
Windows_NT_6.0="Windows Vista/Windows Server 2008"
Windows_NT_5.2="Windows XP/Windows Server 2003/Windows 家庭服务器"
Windows_NT_5.1="Windows XP"
Windows_NT_5.0="Windows 2000"
CHANGED_CONNECTOR_CRC="连接器面板原型已在文件 '%s' 的序列 '%s' 中为步骤 '%s' 更新。"
LOADING_DYNAMIC_VI = "加载分布 VI。"
COMPILING_DYNAMIC_VI Line0001 = "编译分发 VI。此操作最多需要五分钟，在此期间不支持中止。"
COMPILING_DYNAMIC_VI Line0002 = "正在为您当前版本的 LabVIEW 创建一组新的分发 VI，以获取更多信息"
COMPILING_DYNAMIC_VI Line0003 = "信息参考 NI 网站 ni.com/info 并输入信息代码'TSDULabVIEWPerformance'。"
CALLING_DYNAMIC_VI="调用分配 VI"
GLL_DELIMITER=":"

;模式选项卡
MODE="模式"
DISTRIBUTION_VERSION="部署版本："
DISTRIBUTION_TYPE ="分发类型"
CREATE_NEW_FULL_DIST="创建新的完全部署"
CREATE_NEW_PATCH_DIST="创建新的补丁部署"
DEPEND_ON_PREVIOUS_FULL_DIST="取决于之前的完全部署"
DEPEND_ON_PREVIOUS_FULL_DIST_VER="取决于以前的完整部署（版本 %s）"
DEPEND_ON_PREVIOUS_PATCH_DIST="取决于之前的基线补丁部署"
DEPEND_ON_PREVIOUS_PATCH_DIST_VER="取决于以前的基准补丁部署（版本 %s）"

Distribution_Installer_Mode = "输出类型"
INSTALLEROPTION_IMAGE_ONLY = "仅可部署图像"
INSTALLEROPTION_MDF = "基于 MSI 的安装程序"
INSTALLEROPTION_NIPKG = "基于包的分发"
Installer_Mode_Help = "更多信息"

PKGOPTION_PACKAGE_ONLY = "单个包"
PKGOPTION_PACKAGE_AND_FEED = "仓库"
PKGOPTION_PACKAGE_INSTALLER = "包安装程序"

DISABLED_PACKAGE_DISTRIBUTION_MODE = "仅在选择基于包的分发模式时启用"
DISABLED_IN_PACKAGE_DISTRIBUTION_MODE = "选择了基于包的分发模式"
REQUIRES_FEED_OR_PKGINST = "仅在使用存储库或包安装程序模式的基于包的分发中启用"

INSTALLERMODESTRING_DISABLED = "安装禁用"
INSTALLERMODESTRING_MDF = "基于 MSI 的安装程序选项"
INSTALLERMODESTRING_NIPKG = "软件包分发选项"

FILE_INCLUSION="要包含的用户文件："
AUTOMATICALLY_INCLUDE_CHANGED_FILES="修改文件"
DO_NOT_INCLUDE_CHANGED_FILES="无"
MANUAL_MODE="手动模式"

NOT_INCLUDING_FILES_SKIP_ANALYSIS = "跳过分析，因为补丁选项设置为不包括文件。"
NOT_INCLUDING_FILES_SKIP_BUILDING_IMAGE= "跳过构建映像因为补丁选项设置为不包含文件。"

INSTALLER_INCLUSION="升级和补丁包括："
PATCH_INSTALLER_INCLUDE_BOTH="TestStand 运行时和驱动程序"
PATCH_INSTALLER_INCLUDE_ENGINE="TestStand 运行时"
PATCH_INSTALLER_INCLUDE_DRIVERS="驱动程序"
PATCH_INSTALLER_INCLUDE_NONE="无"
PRESS_F1_FOR_HELP="按 F1 寻求帮助"
MAKE_DEPENDABLE_PATCH_BTN="进行基线补丁部署"

;模式选项卡验证
INVALID_VERSION = "无效版本。版本必须大于依赖部署版本 (%s)。"
INVALID_VERSION_INSTALLER = "无效版本。版本必须大于依赖部署安装程序版本 (%s)。"
DESTINATION_CONFLICT="冲突"

;模式选项卡中的概述
概览="概览"
OVERVIEW_CREATE_NEW_FULL_DIST="在此模式下，部署实用程序会创建一个映像，并可选地创建一个包含系统源中所有文件的安装程序。"
OVERVIEW_CREATE_NEW_PATCH_DIST="在此模式下，部署实用程序创建补丁映像和可选的补丁安装程序"
OVERVIEW_CREATE_NEW_PATCH_ADD_ALL="包含自"以来添加或修改的所有文件
OVERVIEW_MANUAL_MODE="仅包含您选择的文件。如果您选择分析文件，部署实用程序会自动包含自"以来添加或修改的所有文件
OVERVIEW_CREATE_NEW_PATCH_ADD_NONE="没有来自"的任何文件
OVERVIEW_DEPEND_ON_PREVIOUS_FULL_DIST="最后一个依赖完全部署。"
OVERVIEW_DEPEND_ON_PREVIOUS_PATCH_DIST="最后一次依赖补丁部署。"

OVERVIEW_MANUAL_MODE_WARNING Line0001="仅当您不使用 LabVIEW 并且您确切知道需要修补哪些文件时才使用手动模式。"
OVERVIEW_MANUAL_MODE_WARNING Line0002="在手动模式下，部署实用程序不检查部署的文件和创建的补丁 "
OVERVIEW_MANUAL_MODE_WARNING Line0003="可能会破坏目标计算机上的部署。"
OVERVIEW_ADD_NO_FILES_WARNING="您可以使用此文件包含策略将更新和补丁部署到部署包含的其他安装程序。"

;分布式文件选项卡
HEADER_FILE_NAME="文件名"
HEADER_FILE_STATUS="文件设置"
File_Status="文件状态"
STATUS_INCLUDE_IF_REQUIRED="如果需要包含在补丁中"
STATUS_INCLUDED="强制包含在补丁中"
STATUS_NOT_INCLUDED="不包含在补丁中"
STATUS_DELETED="从部署的系统中移除"
Add_Patch_File="添加补丁文件"
Remove_Patch_File="删除补丁文件"
PROMPT_DELETE_USER_ADDED_FILE="删除用户添加的文件将需要在构建期间分析文件。您要继续吗？"
YES="是"
NO="否"
INVALID_PATCH_INCLUSION="此源文件的补丁包含选项无效。有关源文件的有效包含选项的信息，请参阅 NI TestStand 帮助。"
INCLUSION_REQUIRES_MAJOR_UPGRADE="从补丁中删除文件需要创建完整部署。您要继续吗？"
PROMPT_FORCE_ANALYSIS_ADVANCED="为了正确处理这个文件，必须在构建之前分析部署。你想处理这个文件吗？"
MAX_CONFIGURATION_FILE="指定的MAX配置文件"
INVALID_PATCH_WITH_PATHS="选定的替换文件无效。替换文件必须不同于部署中包含的当前文件，并且与要替换的文件具有相同的文件名。"
INVALID_PATCH_WITH_PATHS_ENV="所选的替换环境文件无效。替换文件必须与部署中包含的当前文件不同。"
ERR_CANNOT_ADD_USER_FILE="无法将所选文件添加到部署中。所选文件与部署中的另一个文件冲突。"
MAKE_DEPENDABLE_PATCH_EXPLANATION_TITLE="进行基线补丁部署"
MAKE_DEPENDABLE_PATCH_EXPLANATION="将以前的部署（版本 %s）转换为基线补丁部署。您创建的未来补丁可以依赖于基线补丁部署。"
MAKE_DEPENDABLE_PATH_EXPLANATION_PREV_PATCH Line0001="将以前的部署（版本 %s）转换为基线补丁部署。"
MAKE_DEPENDABLE_PATH_EXPLANATION_PREV_PATCH Line0002="此转换后，您无法再针对当前基准补丁部署（版本 %s）创建部署。\n"
MAKE_DEPENDABLE_PATH_EXPLANATION_PREV_PATCH Line0003="您创建的未来补丁将能够依赖于新的补丁基线补丁部署。"

LABVIEW_RTE_VERSION="LabVIEW %s (%s)"
LABVIEW_RTE_VERSION_64="64 位"
LABVIEW_RTE_VERSION_32="32 位"
LABVIEW_RTE_VERSION_UNKNOWN="未知位数"
RTE_NOT_INSTALLED="（未安装）"

Hierarchy_View="调用层次结构"

DELETED_IMAGE_DIRECTORY="图像目录已清除"
DELETED_INSTALLER_DIRECTORY="安装程序目录已清除"

;安装程序选项卡
Installer_To_Patch="完整安装程序路径"

;文件状态
UNKNOWN="未知"
UNMODIFIED = "未修改"
MODIFIED = "已修改"
DEPENDENCY="依赖"
NO_LONGER_A_DEPENDENCY = "不再需要"

;分布视图上下文菜单
COPY_FULL_PATH = "复制_源路径"
OPEN_CONTAINING_FOLDER = "_浏览到源路径"
COPY_FULL_PATH_DEST = "复制_目标路径"
OPEN_CONTAINING_FOLDER_DEST = "B_rowse 到目标路径"
FIND_ENVIRONMENT_FILE_DEST = "N_avigate 到活动环境文件"

;层级树
NO_DEPENDENCIES = "<无依赖关系>"

;文件对话框
ALL_FILES="所有文件 (*.*)"

;构建完成对话框
BUILD_FINISHED_DIALOG="部署完成"
BUILD_FINISHED = "部署已成功完成。"
SAVE_NOW Line0001= "如果你想在未来为这个部署创建补丁，National Instruments 强烈建议你现在保存你的 TSD 文件。\n"
SAVE_NOW Line0002= "您还可以通过按下面的浏览按钮浏览到可部署映像或安装程序目录。"
MAKE_DEPENDABLE_PATCH = "未来的补丁将能够依赖于基线补丁部署。你想让当前部署成为基线补丁部署吗？"
MAKE_DEPENDABLE_PATCH_CHECKBOX = "进行部署基线补丁部署"
SAVE_BTN="保存"
DONT_SAVE_BTN="不保存"

;自定义命令
CUSTOM_COMMANDS_FOR_DISTRIBUTION_TYPE="自定义命令"
CUSTOM_COMMANDS_FOR_PATCH_DISTRIBUTION="补丁部署的自定义命令"
CUSTOM_COMMANDS_FOR_FULL_DISTRIBUTION="完全部署的自定义命令"

;附加组件
ADDITIONAL_COMPONENTS_FOR_DISTRIBUTION_TYPE="附加组件"
ADDITIONAL_COMPONENTS_FOR_PATCH_DISTRIBUTION="补丁部署的附加组件"
ADDITIONAL_COMPONENTS_FOR_FULL_DISTRIBUTION="完全部署的附加组件"


;高级安装程序选项
ADVANCED_INSTALLER_OPTIONS_FOR_DISTRIBUTION_TYPE="高级安装程序选项"
ADVANCED_INSTALLER_OPTIONS_FOR_PATCH_DISTRIBUTION="补丁部署的高级安装程序选项"
ADVANCED_INSTALLER_OPTIONS_FOR_FULL_DISTRIBUTION="完全部署的高级安装程序选项"
ADVANCED_INSTALLER_OPTIONS_FOR_PKG="包配置"

LOCK_TO_DISTRIBUTION_VERSION="锁定到部署版本"
LOCK_VERSION_REQUIRES_BUMPING_DIST_VERSION="要继续，将更改部署版本以匹配当前安装程序版本。您要继续吗？"


;引擎选项
ENGINE_OPTIONS_FOR_DISTRIBUTION_TYPE Line0001 = "选择可选的 TestStand 功能以包含在 TestStand Runtime 中。注意：此应用程序维护不同的选择 "
ENGINE_OPTIONS_FOR_DISTRIBUTION_TYPE Line0002 = "选项取决于部署类型是设置为完全分发还是补丁分发。"

;工具提示
DISABLED_CREATE_DISTRIBUTION_TOOLTIP="仅在创建完全部署后启用。"
DISABLED_IN_PATCH_DISTRIBUTION_TOOLTIP="仅在补丁部署中启用。"
DISTRIBUTION_MODE_ENABLED_ONLY_IN_FULL_DISTRIBUTION_TOOLTIP="分发模式只能针对完整分发进行更改。对于补丁分发，分发模式将匹配相应完整分发中的设置。"
DISABLED_NOT_SUPPORTED_IN_PACKAGE_MODE_TOOLTIP="仅包分发不支持补丁分发"
DISABLED_CREATE_PATCH_FIRST_TOOLTIP="仅在创建基线补丁部署后启用。"
DISABLED_SELECT_DISTRIBUTED_SRC_ITEM="仅对正在分发的源项目启用。"
DISABLED_SELECT_DISTRIBUTED_SRC_ITEM_NOT_PROJECT="仅为正在分发且不属于项目或打包项目库的分发源项目启用。"
DISABLED_SELECT_DISTRIBUTED_SRC_ITEM_NOT_PPL_PATCH="仅对正在分发且不属于补丁部署中打包项目库的分布式源项目启用。"
DISABLED_SELECT_DISTRIBUTED_SRC_ITEM_NOT_PPL="仅为正在分发且不属于打包项目库的分发源项目启用。"
DISABLED_SELECT_LV_PROJECT="仅为 LabVIEW 项目启用。"
DISABLED_CREATE_PROGRAM_ITEM="仅当您创建程序项时启用。"
DISABLED_MANUAL_MODE="仅在手动模式下启用。"
DISABLED_ADDED_FILE_SET_MANUAL_MODE="仅对用户在手动模式下添加的文件启用。"
CANNOT_CHANGE_ENV_DEST_IN_PATCH="无法更改补丁分发中的环境文件目标"
DISABLED_SRC_NODE_MANUAL_MODE="仅在手动模式下对正在分发的源项目启用。"
disabled_dependable_dist_no_installer ="仅在选定的依赖部署（完整部署或基线补丁部署）具有安装程序时，才启用。"
DISABLED_CREATE_INSTALLER="仅在创建安装程序时启用。"
DISABLED_CREATE_PATCH_INSTALLER="仅在为补丁创建安装程序时启用。"
DISABLED_CREATE_NIPKG="仅在创建传统安装程序时启用。"
DISABLED_CREATE_INSTALLER_ENGINE="仅在创建包含 TestStand Runtime 的安装程序时启用。"
ENABLED_CREATE_INSTALLER_ENGINE="TestStand 运行时包括 TestStand 引擎和其他核心功能，例如适配器、步骤类型和用户界面控件。"
DISABLED_USING_VOLUME_LICENSING="仅在不使用批量许可时启用。"
DISABLED_DISTRIBUTE_WORKSPACE="仅在分发工作区时启用。"
DISABLED_DISTRIBUTE_WORKSPACE_FILE_EXISTS="仅在分发工作区且工作区文件存在时启用。"
DISABLED_DISTRIBUTE_DIRECTORY="仅在分发目录时启用。"
DISABLED_DISTRIBUTE_DIRECTORY_FILE_EXISTS="仅在分发目录且目录存在时启用。"
MAKE_DEPENDABLE_PATCH_TOOLTIP="未来的补丁可以依赖于一个以前的补丁部署。单击此按钮使您创建的最后一个补丁部署成为基线补丁部署。"
DISABLED_MAKE_DEPENDABLE_PATCH_TOOLTIP="仅当您已经创建补丁部署并且之前的补丁还不是基线补丁部署时才启用。"
DISABLED_NOT_AVAILABLE_IN_DESTINATION_VIEWS="仅当您选择了工作区视图、源代码视图或构建预览时才启用。\n此视图表示已部署的文件，因此您无法修改文件设置。"
DISABLED_REQUIRES_ENGINE_IN_BUILD="仅当 TestStand Runtime Engine包含在安装程序配置中时才启用。"
DISABLED_32_BIT_TSDU="仅在 64 位 TestStand 部署实用程序中启用。"

PATCH_WITH_TOOLTIP="浏览替换..."
DELETE_REPLACEMENT_TOOLTIP="删除替换"

;警告
WARN_AUTOBUILD_LOAD_FAILED = "无法对以下项目应用更改：%s"

;日志消息
PATH_IN_PROJECT="%s（在项目中调用：%s）"

UNEXPECTED_TYPE_READ_LINKER="读取以下文件的链接器信息时出现意外类型："

LABVIEW_VERSION="LabVIEW 版本"
OPERATING_SYSTEM="操作系统"
TESTSTAND_VERSION="测试台版本"
USER_NAME="用户名"
COMPUTER_NAME="计算机名"
TSD_FILE="TSD 文件"

SUBSTEP_IDENTIFIER="步骤类型\"%s\" - \"%s\"子步骤"
SUBSTEP_IDENTIFIER_NO_STEP_TYPE="\"%s\" 子步骤"

BUILD_INFORMATION="构建信息"
CURRENT_BUILD="当前版本"
DEPENDENT_BUILD="依赖构建"

BUILD_INFO="构建摘要"
SYSTEM_INFORMATION="系统信息"

FILE_CALLED_IN_PROJECT="%s（项目：%s）"

STARTING_ANALYSIS="开始分析"
FINISHED_ANALYSIS="完成分析"
STARTING_BUILD="开始构建"
FINISHED_BUILD="完成构建"
STARTING_DEPLOYMENT="开始部署构建"
FINISHED_DEPLOYMENT="已完成部署构建"

ERROR_CORRUPTED_PROJECT="以下 LabVIEW 源项目已损坏，无法合并。"
ERROR_CREATING_PROJECT="无法创建创建部署所需的合并项目。"
ERR_PUBDIR_NOT FOUND="找不到 TestStand 公共目录。"
ERR_CFGDIR_NOT FOUND="找不到 TestStand 配置目录。"
WARN_FILE_DEST_IS_ENV_PATH="由于部署环境文件中指定的自定义路径，以下文件的安装目标与 National Instruments 目录匹配。"

START_PHASE="开始 %s"
FINISHED_PHASE="完成 %s"
PHASE_EDIT="编辑时间"
PHASE_SETUP="设置"
PHASE_ANALYSIS="分析"
PHASE_BUILD="构建"
PHASE_INSTALLER="安装程序构建"
PHASE_PACKAGE_DISTRIBUTION="包分发构建"
PHASE_CLEANUP="清理"



;消息类型（用于文档创建者）
MESSAGE_TYPE_ERROR="错误"
MESSAGE_TYPE_WARNING="警告"
MESSAGE_TYPE_INFORMATION="信息消息"

NOT_FOUND_IN_SOURCE_FILES="在源文件视图中找不到："

DEPLOYED_VIS="部署的VI"
UNKNOWN_INSALLER_VERSION = "<未知版本>"
PROD_NOT_INSTALLED = "<产品未安装>"

[DISTRIBUTION_WIZARD_LOG]
;记录面板
FILTERING ="过滤"
SHOW_ERRORS = "显示错误"
SHOW_WARNINGS = "显示警告"
SHOW_INFO = "显示信息"
SHOW_DEBUG = "显示调试"
GROUP_BY = "分组依据"
EXPORT = "导出..."
DETAILS_MESSAGE Line0001 = "日期和时间：\n{0}\n\n"
DETAILS_MESSAGE Line0002 = "等级：\n{1}\n\n"
DETAILS_MESSAGE Line0003 = "消息：\n{2}\n\n"
DETAILS_MESSAGE Line0004 = "上下文：\n{3}\n\n"
DETAILS_MESSAGE Line0005 = "位置：\n{4}"

ADDITIONAL_HELP="帮助"
ADDITIONAL_HIERARCHY="其他详细信息"
TAB_BUILD_STATUS="构建状态"
TAB_LOG_HEADER="日志摘要"

COLUMN_SEVERITY="严重性"
COLUMN_TIME="时间"
COLUMN_ERROR_CODE="代码"
COLUMN_MESSAGE="消息"
COLUMN_LOCATION="位置"
COLUMN_CONTEXT="上下文"
COLUMN_DEPLOYMENT_VERSION="部署版本"
COLUMN_PHASE="阶段"
COLUMN_HIERARCHY="其他详细信息？"

COLUMN_VALUES="值"

COLUMN_DESCRIPTION="说明"
COLUMN_INSTALLER_VERSION="安装程序版本"
COLUMN_IMAGE_DIRECTORY="图像目录"
COLUMN_INSTALLER_DIRECTORY="安装目录"
COLUMN_BUILD_TIME="构建日期"
COLUMN_BUILD_TIME_SPAN="构建时间跨度"
COLUMN_INSTALLER_SIZE="安装程序大小"

COLUMN_INSTALLER_NAME="姓名"
COLUMN_INSTALLER_INCLUSION_STATE="包含状态"

COLUMN_INCLUSION_STATE="包含状态"
COLUMN_SOURCE_PATHS="源路径"
COLUMN_SOURCE_MODIFIED_DATES="来源修改日期"
COLUMN_OLD_CHECKSUM="旧图像校验和"
COLUMN_OLD_MODIFIED_DATE="旧图像修改日期"
COLUMN_OLD_VERSION="旧图像版本"
COLUMN_NEW_CHECKSUM="新图像校验和"
COLUMN_NEW_MODIFIED_DATE="新图像修改日期"
COLUMN_NEW_VERSION="新图像版本"

COLUMN_CHECKSUM="校验和"
COLUMN_VERSION="版本"

COLUMN_SEQUENCE_FILE="序列文件"
COLUMN_SEQUENCE="顺序"
COLUMN_STEP="步骤"
COLUMN_STEP_AND_ID="步骤（唯一步骤 ID）"
COLUMN_CODE_MODULE="代码模块"

COLUMN_ERROR_MESSAGE="错误信息"

COLUMN_TITLE="标题"
COLUMN_VALUE="值"

COLUMN_BENCHMARKS_DESCRIPTION="描述"
COLUMN_BENCHMARKS_TICK_COUNT="滴答计数"

COLUMN_DETAILS="详细信息"

COLUMN_VI_PATH="VI 路径"
COLUMN_ACTUAL_NAMESPACE="实际命名空间"
COLUMN_EXPECTED_NAMESPACE="预期命名空间"

COLUMN_BITNESS="位数"

COLUMN_FILES_USING_VERSION="文件使用版本"

COLUMN_FILE_NAME="文件名"
COLUMN_SOURCE_QUALIFIED_NAME="源限定名称"
COLUMN_DESTINATION_QUALIFIED_NAME="目标限定名称"

RELATION_CHANGED_DESTINATIONS="更改目的地"
COLUMN_ORIGINAL_PATH="原始路径"
COLUMN_NEW_PATH="新路径"

RELATION_PATH_TRANSFORMATIONS="路径转换"
COLUMN_SOURCE_PATH="来源路径"
COLUMN_MODIFIED_DATE="修改日期"
COLUMN_DESTINATION_PATH="目标路径"

COLUMN_PATH="路径"
COLUMN_SUBSTEP="子步骤"
COLUMN_DESTINATION="目的地"
COLUMN_FILTERED="过滤后的文件"
COLUMN_EXCLUDED="排除文件"
COLUMN_RELATIVE_PATHS="相对路径"
COLUMN_CHANGED_DESTINATION="更改的目的地"
COLUMN_RTE_VERSIONS="运行时引擎版本"

COLUMN_DEPENDENCY_NAME="产品名称"
COLUMN_INSTALLED_VERSION="当前安装的版本"
COLUMN_REQUIRED_VERSION="所需版本"
COLUMN_FILES_REQUIRING_PRODUCT="需要产品的文件"

RELATION_BUILD_INFO="构建摘要"
RELATION_INCLUDED_FILES="文件"
RELATION_INCLUDED_INSTALLERS="附加组件"
RELATION_PATCH_FILE_SOURCES="文件来源"
RELATION_ERROR_CLUSTER_INFORMATION="错误集群信息"
RELATION_SEQUENCE_LOCATION_INFORMATION="序列位置"
RELATION_SUMMARY_INFORMATION="系统信息"
RELATION_BENCHMARKS="基准"
RELATION_DETAILS="详细信息"
RELATION_NAMESPACE_MISMATCH_ERROR="文件"
SOFT_DEPENDENCIES_RELATION_NAME = "包含软依赖"

SUMMARY_MESSAGE_FORMAT = "{0}: {1}"

LAST_BUILD_RESULT="上次构建结果"
BUILD_SUCCESS="成功"
BUILD_FAILURE="失败"

BUILD_RESULT="没有构建"
BUILD_RUNNING="正在运行..."
BUILD_START_TIME="开始：{0}"
BUILD_END_TIME="结束：{0}"
BUILD_SUCCESSFUL="构建成功"
BUILD_FAILED="构建失败"

SAVE_LOG="保存日志..."
SAVE_LOG_AS_ZIP="保存技术支持报告..."
CLEAR_LOG="清除日志"

GROUP_BY_SEVERITY="严重性"
GROUP_BY_CODE="代码"
GROUP_BY_MESSAGE="消息"
GROUP_BY_PHASE="阶段"
GROUP_BY_DEPLOYMENT_VERSION="部署版本"
REMOVE_GROUP_BY="删除分组"
GOTO_LOCATION="转到位置"
COPY_XML="复制为 XML"
COPY="复制"
EXPAND_ALL="全部展开"
COLLAPSE_ALL="全部折叠"
OPEN_IN_LABVIEW="在 LabVIEW 中打开\"{0}\""
OPEN_IN_LABVIEW_TYPE="在 LabVIEW 中打开 {0}\"{1}\""
TOO_MANY_FILES_IN_CONTEXT_MENU="{0} 个文件。右键单击特定文件以获得更多选项"

OPEN_IN_TESTSTAND="在 TestStand 中打开\"{0}\""
OPEN_IN_TESTSTAND_TYPE="在 TestStand 中打开 {0}\"{1}\""

OPEN_IN_FILES_VIEW="在文件视图中选择\"{0}\""
OPEN_IN_FILES_VIEW_TYPE="在文件视图中选择 {0}\"{1}\""

OPEN_IN_EXPLORER="在资源管理器中打开\"{0}\""
OPEN_IN_EXPLORER_TYPE="在资源管理器中打开 {0}\"{1}\""

COULD_NOT_LAUNCH_LABVIEW="无法打开LabVIEW"

TYPE_IMAGE_DIRECTORY="图像目录"
TYPE_INSTALLER_DIRECTORY="安装程序目录"
TYPE_SEQUENCE_FILE="序列文件"
TYPE_CODE_MODULE="代码模块"

XML_FILE_FILTER="XML 文件"
TEXT_FILE_FILTER="文本文件"
TECHNICAL_REPORT_FILE_FILTER="压缩归档文件"
ALL_FILE_FILTER="所有文件"

ERR_EXPORTING_LOG="无法将日志保存到路径 {0}。错误消息：{1}。"
ERR_UNEXPECTED_ERROR="意外错误。请联系 National Instruments 以获得支持。"
ERR_SAVE_XML_LOG="保存日志时出现意外错误。请联系 National Instruments 以获得支持。"

;从 TSDU 部分复制的字符串导出
CONTEXT_INTRO="同时"
ERROR_SEP="******************************************"
WARNING_SEP="------------------------------------"
BLD_ANALY_SEP="+++++++++++++++++++++++++++++++++++++++++"

Module_Step_Sequence_File="代码模块'{0}'，步骤'{1}'，序列'{2}'，序列文件'{3}'"
ST_SEQ_SF="步骤'%s'，序列'%s'，序列文件'%s'"

MESSAGE_CODE="{1}（消息代码：{0}）"

PATCH_HEADER="创建补丁：\n"
FULL_DISTRIBUTION_HEADER="创建完整分发：\n"

BUILD_SUMMARY Line0001="部署版本：{0}\n"
BUILD_SUMMARY Line0002="构建于：{1}（构建时间跨度：{2}）\n"
BUILD_SUMMARY Line0003="<Image Directory> is {3}\n"
BUILD_SUMMARY Line0004="安装程序版本：{4}\n"
BUILD_SUMMARY Line0005="<安装程序目录> 是 {5}\n"
BUILD_SUMMARY Line0006="安装程序大小为 {6}\n"

PATCH_DID_NOT_ADD_FILES= "\n这个补丁不包含任何额外的新文件。"
PATCH_INCLUDED_INSTALLERS="此补丁包括以下更新和补丁："
PATCH_DID_NOT_ADD_INSTALLERS="这个补丁不包括对 NI 驱动程序和组件的任何更新或补丁。"
PATCH_ADDED_FOLLOWING_FILES= "\n这个补丁包括以下额外的新文件："
PATCH_DID_NOT_UPGRADE_FILES = "\n这个补丁没有升级文件。"
PATCH_UPGRADING_FOLLOWING_FILES= "\n这个补丁包括以下文件："
PATCH_DOES_NOT_HAVE_UNCHANGED_FILES = "\n这个补丁没有保留任何文件不变。"
PATCH_DID_NOT_UPDATE_FOLLOWING_FILES = "\n这个补丁不包括以下文件："
PATCH_REMOVED_PREV_PATCHES= "\n这个补丁不包括以前补丁中的以下文件："

FILE_INCLUSION_STATE_ADDED="已添加"
FILE_INCLUSION_STATE_MODIFIED="已修改"
FILE_INCLUSION_STATE_REMOVED="已删除"
FILE_INCLUSION_STATE_UNCHANGED="未更改"
FILE_INCLUSION_STATE_NOTPRESENT="不在源代码中"

INSTALLER_INCLUSION_STATE_ADDED="手动包含"
INSTALLER_INCLUSION_STATE_UPGRADED="升级或修补"

LOGGING_LEVEL_TRACE="跟踪"
LOGGING_LEVEL_DEBUG="调试"
LOGGING_LEVEL_PROCESS="进程"
LOGGING_LEVEL_INFO="信息"
LOGGING_LEVEL_WARN="警告"
LOGGING_LEVEL_ERROR="错误"
LOGGING_LEVEL_FATAL="致命"

PHASE_EDIT="编辑时间"
PHASE_SETUP="设置"
PHASE_ANALYSIS="分析"
PHASE_BUILD="构建"
PHASE_INSTALLER="安装程序创建"
PHASE_CLEANUP="清理"

DEPLOYMENT_CONTAINS_NO_INSTALLERS="<此部署不包含任何附加组件>"
DEPLOYMENT_CONTAINS_NO_FILES="<此部署不包含任何文件>"

NAMESPACE_ERROR_DETAILS="{0}（实际命名空间：{1}）（预期命名空间：{2}）"

REQUIRED_LABVIEW_RUNTIME_DETAILS Line0001="版本：{0} ({1})\n"
REQUIRED_LABVIEW_RUNTIME_DETAILS Line0002=" 要求：\n"
REQUIRED_LABVIEW_RUNTIME_DETAILS Line0003="{2}"
REQUIRED_LABVIEW_RUNTIME_PATH=" - {0}"

SOURCE_PATH = "来源"
DESTINATION_PATH = "目的地"
PATH_TRANSFORMS_DETAILS = "{0}（限定名称：{2}）-> {1}（限定名称：{3}）"
PATH_TRANSFORMS_DETAILS_NO_QUALIFIED_NAME = "{0} -> {1}"

[TYPES_MODIFIED_WARNING]
标题 = "警告"
MESSAGE = "文件 '%1' 包含已修改的类型。如果您稍后打开此文件，TestStand 可能会提示您解决类型冲突。"
MESSAGE_MODIFIED_IN_PREVIOUS_VERSION = "\n\n标有'*'的类型已在较早版本的 TestStand 中修改，并且在 TestStand %1 中未更改。"
MODIFIED_TYPES_LABEL = "&修改类型："
AUTOMATIC_INCREMENT_MSG = "您可以通过为每种类型使用一个版本并在您进行更改时递增版本来自动解决大多数类型冲突。使用以下选项来处理此文件中所有修改的类型："
AUTOMATIC_INCREMENT_RADIO = "&增量类型版本"
SAVE_WITHOUT_INCREMENTING_RADIO = "不增加类型版本(&D)"
VERSION_NUMBER_TO_INCREMENT_LABEL = "&要增加的版本号："
VERSION_NUM_VAL_MAJOR = "主要"
VERSION_NUM_VAL_MINOR = "次要"
VERSION_NUM_VAL_REVISION = "修订版"
VERSION_NUM_VAL_BUILD = "建造"
CLEAR_MODIFIED_FLAG_CHECK = "从类型中移除修改标记(&V)"
DISABLE_PROMPT = "保存这些设置并且不再提示。您可以稍后在站点选项对话框中编辑设置。"
SAVE_BTN_LABEL = "&确定"

[TYPE_PALETTE_FILE_LOAD_ERRORS_DLG]
TITLE = "类型选项板文件加载错误"
MESSAGE = "错误阻止 TestStand 加载某些类型调色板文件：\n"
ERROR_DESCR_FMT Line0001 = "[%1]\n"
ERROR_DESCR_FMT Line0002 = "%2\n"

[CODE_TEMPLATE_TYPES]
Unknown="未知"
Legacy="遗产"
LabVIEW = "LabVIEW"
CVI = "LabWindows/CVI"
C/C++ = "C/C++"
HTBasic = "HTBasic"
Visual C++ = "Visual C++ .NET"
Visual C# = "Visual C# .NET"
Visual Basic = "Visual Basic .NET"
LabVIEW NXG = "LabVIEW NXG"

[VS_INTEGRATION_SHARED]
EXIT_VS_WHILE_SUSPENDED_WARNING = "此时退出 Visual Studio 会导致 Visual Studio 窗口消失，而不会终止 Visual Studio 进程或 TestStand 进程。\nNational Instruments 建议您在关闭 Visual Studio 之前正常退出 TestStand 进程。\n\n是否要现在退出 Visual Studio？"
STOP_DEBUGGING_TESTSTAND_WARNING = "这个操作终止了 TestStand 进程，不允许 TestStand 执行它的正常清理操作。\n\n你想现在执行这个操作吗？"

SRC_BROWSE_TITLE = "选择源文件"
PRJ_BROWSE_TITLE = "选择项目文件"
SLN_BROWSE_TITLE = "选择解决方案文件"

FIND_OPEN_DTES_TITLE = "初始化 Visual Studio"
FIND_OPEN_DTES_MESSAGE = "TestStand 正在搜索打开的 Visual Studio 实例..."

STARTING_CODE_TEMPLATE_READER_DTE_TITLE = "初始化 Visual Studio"
STARTING_CODE_TEMPLATE_READER_DTE_MESSAGE = "TestStand 正在激活 Visual Studio 以读取代码模板..."

CREATING_CODE_IN_VS_TITLE = "初始化 Visual Studio"
CREATING_CODE_IN_VS_MESSAGE = "TestStand 正在 Visual Studio 中打开项目并插入源代码..."

UNABLE_TO_EDIT_SRC_SRC_NOT_FOUND = "无法找到此步骤的源文件。确保模块源文件存在于磁盘上。"
UNABLE_TO_EDIT_SRC_PRJ_NOT_FOUND = "无法找到此步骤的项目文件。确保模块项目文件存在于磁盘上。"
UNABLE_TO_EDIT_SRC_SLN_NOT_FOUND = "无法找到此步骤的解决方案文件。确保模块解决方案文件存在于磁盘上。"

STEP_CFG_DLG_DOTNET_SRC_MODULE_BROWSE_DLG_FILTER = "C#/VB .NET 源文件 (*.cs;*.vb)|*.cs;*.vb|C# .NET 源文件 (*.cs)|*.cs|VB .NET 源文件 (* .vb)|*.vb|所有文件 (*.*)|*.*||"
STEP_CFG_DLG_DOTNET_PRJ_MODULE_BROWSE_DLG_FILTER = "C#/VB .NET 项目文件 (*.csproj;*.vbproj)|*.csproj;*.vbproj|C# .NET 项目文件 (*.csproj)|*.csproj|VB .NET 项目文件 (* .vbproj)|*.vbproj|所有文件 (*.*)|*.*||"
STEP_CFG_DLG_VCPROJ_MODULE_BROWSE_DLG_FILTER = "C++ .NET 项目文件 (*.vcproj;*.vcxproj)|*.vcproj;*.vcxproj|所有文件 (*.*)|*.*||"
STEP_CFG_DLG_SLN_MODULE_BROWSE_DLG_FILTER = "Visual Studio 解决方案文件 (*.sln)|*.sln|所有文件 (*.*)|*.*||"

STEP_CFG_DLG_CREATE_CODE_BTN = "创建代码..."
STEP_CFG_DLG_EDIT_CODE_BTN = "编辑代码..."

INVALID_SRC_PATH = "无效的源文件路径。"
INVALID_PRJ_PATH = "无效的项目文件路径。"
INVALID_SLN_PATH = "无效的解决方案文件路径。"

MISSING_FUNC_NAME = "在执行此操作之前，您必须指定一个方法名称。"
INVALID_FUNC_NAME Line0001 = "名称 '%1' 不是有效的方法名称。方法名称必须以字母开头，并且只能包含字母、数字和下划线。"
INVALID_FUNC_NAME Line0002 = "您必须指定一个有效的方法名称才能执行此操作。"

MISSING_DOTNET_CLASS_NAME Line0001 = "在执行此操作之前，您必须指定有效的 .NET 程序集和该程序集中的类名。\n"
MISSING_DOTNET_CLASS_NAME Line0002 = "你现在要指定那些吗？"

MISSING_DOTNET_FUNC_NAME Line0001 = "在执行此操作之前，您必须在类中指定一个有效函数。\n"
MISSING_DOTNET_FUNC_NAME Line0002 = "你现在想指定一个吗？"

CONTEXT_MENU_MISSING_DOTNET_CLASS_NAME Line0001 = "在执行此操作之前，您必须指定一个有效的 .NET 程序集和该程序集中的类名。"
CONTEXT_MENU_MISSING_DOTNET_FUNC_NAME = "在执行此操作之前，您必须在类中指定一个有效函数。"

STEP_CFG_DLG_PRJ_PATH_TXT = "Visual Studio 和项目文件："
STEP_CFG_DLG_SRC_PATH_TXT = "包含函数的源文件及文件："
STEP_CFG_DLG_SLN_PATH_TXT = "Visual Studio 解决方案文件（可选）："

STEP_CFG_DLG_FUNC_NAME_TXT = "&要创建的方法名称："

STEP_CFG_DLG_EDIT_CODE_TAB_CAPTION = "源代码"

;;替换、在上方插入、在下方插入对话框
VS_REPLACE_FUNC_TITLE = "替换、插入上方或插入下方？"
VS_REPLACE_FUNC = "替换"
VS_INSERT_ABOVE = "插入上方"
VS_INSERT_BELOW = "插入下方"
VS_FUNC_LABEL = "方法名称："
VS_REPLACE_FUNC_PROMPT Line0001 = "您尝试创建的方法已经存在于源代码中。是否要替换"
VS_REPLACE_FUNC_PROMPT Line0002 = "已有方法，在上面插入新方法，还是在下面插入新方法？如果插入新方法"
VS_REPLACE_FUNC_PROMPT Line0003 = "现有方法之上或之下的方法，TestStand 使用以下方法名称："

VS_SRC_AND_PRJ_TYPES_DO_NOT_MATCH Line0001 = "源文件和项目文件不是同一种语言。指定一个项目文件"
VS_SRC_AND_PRJ_TYPES_DO_NOT_MATCH Line0002 = "匹配源文件的语言。"

VS_DOTNET_RECOMPILE_NEEDED = "您必须重新编译并重新加载项目，以便在您指定模块时出现新方法。"

VS_CPP_INVALID_PROJECT_FILE_TYPE = "在执行此操作之前，您必须指定有效的 Visual Studio C++ 项目文件（*.vcproj、*.vcxproj）。"
VS_CS_INVALID_PROJECT_FILE_TYPE = "在执行此操作之前，您必须指定有效的 Visual Studio C# 项目文件 (*.csproj)。"
VS_VB_INVALID_PROJECT_FILE_TYPE = "在执行此操作之前，您必须指定一个有效的 Visual Studio VB 项目文件 (*.vbproj)。"

VS_CPP_INVALID_SRC_FILE_TYPE = "在执行此操作之前，您必须指定有效的 Visual Studio C++ 源文件（*.cpp 或 *.c）。"

VS_DOTNET_INVALID_SRC_FILE_TYPE Line0001 = "无效的源文件类型。您必须指定有效的 Visual Studio C# 或 VB 源文件（*.cs 或 *.vb）"
VS_DOTNET_INVALID_SRC_FILE_TYPE Line0002 = "在您可以执行此操作之前。"

VS_INVALID_SLN_FILE_TYPE = "您必须先指定有效的 Visual Studio 解决方案文件 (*.sln)，然后才能执行此操作。"

VS_CPP_UNKNOWN_SRC_FILE_TYPE Line0001 = "未知源文件类型。您必须先指定有效的 C 或 C++ 源文件，然后才能"
VS_CPP_UNKNOWN_SRC_FILE_TYPE Line0002 = "执行此操作。"

VS_SOLUTION_NOT_SPECIFIED = "您没有指定 Visual Studio 解决方案文件。TestStand 将为您创建一个解决方案文件。"

VS_UNKNOWN_PARAM_TYPE Line0001 = "代码模板中的函数包含一个或多个不支持类型的参数。一些"
VS_UNKNOWN_PARAM_TYPE Line0002 = "代码模板需要 Measurement Studio 项目来创建代码。TestStand 创建了函数 "
VS_UNKNOWN_PARAM_TYPE Line0003 = "但没有更新模块选项卡。"

CPP_INVALID_FUNC_NAME Line0001 = "名称 '%1' 不是有效的函数名。函数名必须以字母开头，并且只能包含字母、数字和下划线。"
CPP_INVALID_FUNC_NAME Line0002 = "在执行此操作之前，您必须指定一个有效的函数名称或将函数名称留空。"
CPP_INVALID_FUNC_NAME Line0003 = "你现在要指定一个有效的函数名吗？"

VS_CHOOSE_NEW_FUNC_NAME = "选择一个新函数名称以在您指定的源文件中创建代码。"

VS_PROJECT_NOT_IN_SOLUTION Line0001 = "指定的解决方案 '%1' 不包含项目 '%2'。要继续此操作，TestStand 必须将项目文件添加到解决方案中。你想继续吗？\n\n"
VS_PROJECT_NOT_IN_SOLUTION Line0002 = "如果解决方案包含项目但项目不可用，您可能会看到此对话框。如果是这种情况，"
VS_PROJECT_NOT_IN_SOLUTION Line0003 = "单击否并重新加载项目，这样它就不会在 Visual Studio 解决方案资源管理器中标记为不可用 "
VS_PROJECT_NOT_IN_SOLUTION Line0004 = "在执行此操作之前。"
VS_SOURCE_NOT_IN_PROJECT = "指定的项目 '%1' 不包含源文件 '%2'。要继续此操作，TestStand 必须将源文件添加到项目中。你想继续吗？"

VS_PROJECT_OPEN_DIFF_SOLUTION Line0001 = "项目 '%1' 已经在解决方案 '%2' 中打开。"
VS_PROJECT_OPEN_DIFF_SOLUTION Line0002 = "你想改用那个解决方案吗？"

VS_CLOSE_PROJECT = "在执行当前操作之前关闭项目 '%1'。"

VS_PROJECT_NOT_VS_2003 Line0001 = "项目 '%1' 已经在 TestStand 不支持的 Visual Studio 版本中打开。关闭项目 "
VS_PROJECT_NOT_VS_2003 Line0002 = "在执行此操作之前。"

VS_SOLUTION_NOT_VS_2003 Line0001 = "解决方案 '%1' 已经在 TestStand 不支持的 Visual Studio 版本中打开。关闭解决方案 "
VS_SOLUTION_NOT_VS_2003 Line0002 = "在执行此操作之前。"

VS_INTEGRATION_PROMPT_CAPTION = "Visual Studio 集成"
VS_INTEGRATION_PROMPT_SAVE_SELECTION = "记住这个设置（你可以在 %1 适配器配置对话框中改变这个设置。）"
VS_INTEGRATION_PROMPT_CREATE_EDIT_CODE_VERSION = "选择使用此适配器创建或编辑代码的 Visual Studio 版本："
VS_INTEGRATION_PROMPT_DEBUG_VERSION = "选择用于调试此适配器的 Visual Studio 版本："

ADP_CFG_CREATE_CODE_VS_VERSION_LABEL = "用于创建和编辑代码的 Visual Studio 版本："
ADP_CFG_DEBUG_VS_VERSION_LABEL = "用于调试的 Visual Studio 版本(&D)："
ADP_CFG_ALWAYS_PROMPT = "总是提示版本"
ADP_CFG_MATCHING_VERSION = "使用与项目文件匹配的版本"
ADP_CFG_USE = "使用 %1"

[LICENSE_MGR_DLG]
DLG_TITLE = "NI TestStand %1 - 未授权版本"
EVAL_SESSION_EXPIRED Line0001 = "一小时的评估会话已过期。所有序列编辑"
EVAL_SESSION_EXPIRED Line0002 = "执行功能现已禁用。您需要重新启动应用程序才能启用这些功能。"
EXECUTION_TIMEOUT Line0001 = "%1\n"
EXECUTION_TIMEOUT Line0002 = "此执行已停止，因为它超过了 10 分钟的评估时间"
EXECUTION_TIMEOUT Line0003 = "时间限制。单击确定继续以评估模式运行软件。"

[FOREACH_WELCOME_DLG]
TITLE = "更新序列文件"
MESSAGE = "此工具自动加载、更新和保存序列文件。选择一个 &directory 以开始该过程并查看以下选项。"
RECURSE = "递归 &子目录"
MODIFIED_TYPE_OPTIONS_MSG = "如果序列文件包含在不增加版本的情况下修改和保存的类型："
FOREACH_PATH_BROWSE_DLG_TITLE = "选择文件夹"
AUTO_INCREMENT_TYPE_VERSION_YES = "自动递增类型版本"
AUTO_INCREMENT_TYPE_VERSION_NO = "不增加类型版本"
AUTO_INCREMENT_TYPE_VERSION_PROMPT = "提示增加类型版本"
TYPE_VERSION_NUMBER_TO_INCREMENT = "要增加的版本号(&M):"
VERSION_NUMBER_TO_INCREMENT = "&要增加的版本号："
VERSION_MAJOR = "主要"
VERSION_MINOR = "次要"
VERSION_REVISION = "修订版"
VERSION_BUILD = "构建"
TYPE_CONFLICT_OPTIONS_MSG = "如果序列文件包含的类型与当前加载到内存中的类型冲突:"
PROMPT_ON_TYPE_CONFLICT = "显示类型冲突解决对话框"
USE_TYPE_DEFINITION_FROM_TESTSTAND = "用当前加载的类型替换文件中的类型"
THROW_TYPE_CONFLICT_ERROR = "显示错误信息"
SKIP_TYPE_DEFINITION = "不要对任何类型进行任何更改"
USE_TYPE_DEFINITION_FROM_FILE = "用文件中的类型替换当前加载的类型"


BEGIN_BTN_LABEL = "开始"

[LEGACY_MODEL_SWITCHER]
EXPLANATION Line0001 = "TestStand 2012 及更高版本的过程模型包含重大更改，以实现模型序列文件的插件架构。TestStand 2012 及更高版本使用插件机制"
EXPLANATION Line0002 = "将结果处理与过程模型分离，从而简化模型序列文件。\n\n"
EXPLANATION Line0003 = "TestStand 2012 及更高版本的过程模型与为以前版本的 TestStand 过程模型编写的序列高度兼容。但是，存在一些不兼容性"
EXPLANATION Line0004 = "存在。单击帮助按钮以参考 NI TestStand 帮助，了解有关可能的不兼容性的更多信息。"
EXPLANATION Line0005 = "使用此工具将默认的 TestStand 过程模型替换为位于 <TestStand>\\Components\\Models\\TestStandModels\\ 中的等效遗留 TestStand 2010 过程模型"
EXPLANATION Line0006 = "反之亦然。此工具不影响任何自定义流程模型。\n\n"
EXPLANATION Line0007 = "您还可以使用命令行参数以编程方式选择要使用的 TestStand 过程模型。单击帮助按钮以参考 NI TestStand 帮助"
EXPLANATION Line0008 = "关于命令行参数的更多信息。"
TITLE = "旧版模型切换器"
USE_NEW_MODELS = "使用新模型"
USE_LEGACY_MODELS = "使用遗留模型"
ok = "确定"
CANCEL = "取消"
HELP = "帮助"
WRONG_EXE_DIRECTORY = "此实用程序只能从 TestStand 2010 Process Models (Legacy) 目录运行。"
ERROR_ACCESSING = "访问错误"
FAILED_TO_CREATE_COPY_OF = "创建副本失败"
AT_LOCATION = "在位置"
FAILED_TO_CREATE = "创建失败："
INVALID_MODEL_FILE = "验证模型文件 %1 时出错"
INVALID_COMMAND_LINE_ARGUMENT = "无效的命令行参数："
VALID_ARGUMENTS = "\n\n有效参数是：\n /new\n /legacy"
MIGRATE_REPORT_OPTIONS_FROM_LEGACY = "从旧模型迁移报告选项(&M)"
MIGRATE_REPORT_OPTIONS_FROM_LEGACY_NOT_FOUND = "从遗留模型迁移报告选项（遗留文件不存在）"
MIGRATE_DATABASE_OPTIONS_FROM_LEGACY = "从遗留模型迁移数据库选项(&M)"
MIGRATE_DATABASE_OPTIONS_FROM_LEGACY_NOT_FOUND = "从遗留模型迁移数据库选项（遗留文件不存在）"
MIGRATE_REPORT_OPTIONS_FROM_NEW = "从新模型迁移报告选项(&R)"
MIGRATE_DATABASE_OPTIONS_FROM_NEW = "从新模型迁移数据库选项(&M)"

MIGRATION_REPORT="迁移完成。进行了以下更改：\n"
REPORT_SWAPPED_MODELS="过程模型已交换。\n"
REPORT_MIGRATED_REPORT_OPTIONS="报告选项已迁移。\n"
REPORT_MIGRATED_DATABASE_OPTIONS="数据库选项已迁移。\n"
REPORT_LEGACY_TO_NEW="遗留模型已移至 <TestStand Components>\\Models\\TestStandModels。新模型的副本存储在 <TestStand Components>\\Models\\Saved Copies of TestStand Models。\n"
REPORT_NEW_TO_LEGACY="新模型已移至 <TestStand Components>\\Models\\TestStandModels。旧模型的副本存储在 <TestStand Components>\\Models\\TestStand 2010 Process Models (Legacy) 中。\n"
REPORT_NO_CHANGES="没有变化\n"
MIGRATION_REPORT_RESTART_TESTSTAND="\n您必须关闭并重新启动所有正在运行的 TestStand 应用程序才能使用流程模型。重新启动失败可能会导致意外行为。"

DEFAULT_CONFIGURATION_SET_NAME="旧模型的选项"
DEFAULT_REPORT_CONFIGURATION_NAME="报告（已迁移）"
DEFAULT_DATABASE_CONFIGURATION_NAME="数据库（已迁移）"

;错误
ERR_MODEL_SUPPORT_DLL_NOT_LOADABLE="遗留模型切换器无法加载模型支持DLL。。\n"
ERR_MODEL_SUPPORT_DLL_NOT_FOUND="Legacy Model Switcher 找不到ModelSupport DLL。"
ERR_MODEL_SUPPORT_FUNCTION_NOT_FOUND="Legacy Model Switcher 找不到方法 "
ERR_CALLING_DLL_NOT_LOADED="Legacy Model Switcher 在调用之前未加载 ModelSupport DLL。请联系 National Instruments 以获得支持。"
ERR_UNEXPECTED_TYPE="无法迁移未随 TestStand 一起提供的类型的选项。预期类型 %s，实际类型 %s。"
ERR_TYPE_IN_MEMORY="当类型在内存中时无法迁移类型。在继续之前从内存中删除类型 %s。"
ERR_INVALID_CONFIGURATION_SET_NAME="无法将配置集 %s 设置为活动配置集。指定的配置集不存在。"
ERR_CONFIG_NOT_FOUND="未找到所选配置。"

[UpdateLaaFlagDialog]
TITLE="更新大地址感知标志"
ADD_BUTTON="添加"
REMOVE_BUTTON="删除"
REMOVE_ALL_BUTTON="全部删除"
OK_BUTTON="应用应用"
CANCEL_BUTTON="关闭"
HELP_BUTTON="帮助"
SELECT_OPERATION="选择操作："
ENABLE_LAA_FLAG="启用大地址感知标志"
DISABLE_LAA_FLAG="禁用大地址感知标志"
FILE_PATH_COL_NAME="文件路径"
STATUS_COL_NAME="标记状态"
ENABLED_STATUS="启用"
DISABLED_STATUS="禁用"
OPEN_FILE_DIALOG_TEXT ="选择可执行文件以更新大地址感知标志"
ERROR_CAPTION="错误"
ERROR_UPDATE_FAILED_DESCRIPTION Line0001 = "无法更新以下可执行文件的 Large Address Aware 标志：\n %1 \n"
ERROR_UPDATE_FAILED_DESCRIPTION Line0002 = "确认可执行文件存在、有效、未标记为只读且当前未使用。如果可执行文件位于受保护的目录中，您可能需要管理员权限才能修改文件。右键单击在该实用程序中并选择"以管理员身份运行"以管理员身份运行该实用程序。"
ERROR_TS_VER="您必须将 TestStand 的当前活动版本设置为 TestStand 2013 或更高版本才能使用 Update Large Address Aware Flag 实用程序。"
ERROR_READ_FAILED_DESCRIPTION Line0001 = "无法读取以下可执行文件的大地址识别标志状态：\n %1 \n"
ERROR_READ_FAILED_DESCRIPTION Line0002 = "确认可执行文件存在且有效。如果可执行文件位于受保护的目录中，您可能需要管理员权限才能修改文件。右键单击实用程序并选择"以管理员身份运行"以管理员身份运行该实用程序。"

[CUSTOM_ENVIRONMENT_CONFIG_DLG]
CONFIGURE_CUSTOM_ENVIRONMENT_TITLE = "配置环境"
ENVIRONMENT_PATH = "环境路径"
GLOBAL_ENVIRONMENT = "<全局>"
CURRENT_ENVIRONMENT = "<当前>"
CUSTOM_DIRECTORIES = "自定义目录"
COMMONAPPDATA_DIR = "通用应用数据"
PUBLIC_DIR = "公开"
LOCALAPPDATA_DIR = "本地应用数据"
ENV_BROWSE_TOOL_TIP = "浏览.../创建新..."
BROWSE_TOOL_TIP = "浏览..."
OPEN = "加载"
SAVE = "保存"
SAVE_AS = "另存为..."
CLOSE = "关闭"
DISCARD_CHANGES_CAPTION = "放弃未保存的更改？"
DISCARD_CHANGES_TEXT = "环境已经修改。放弃未保存的更改？"
HELP = "帮助"
SET_ENGINE_ENVIRONMENT = "设置引擎环境(&E)"
SET_ENGINE_WARNING_TITLE = "重启 TestStand 引擎？"
SET_ENGINE_WARNING_MESSAGE = "结束所有执行，关闭所有序列文件，退出，并在指定环境中重新启动应用程序？"
SELECT_ENVIRONMENT_PATH = "选择环境路径"
SELECT_CUSTOM_COMMONAPPDATA_DIR = "选择自定义 CommonAppData 目录"
SELECT_CUSTOM_PUBLIC_DIR = "选择自定义公共目录"
SELECT_CUSTOM_LOCALAPPDATA_DIR = "选择自定义 LocalAppData 目录"
ERROR_TITLE = "错误"
ERROR_FILE_NOT_FOUND = "找不到文件 '%1'。"
USE_RELATIVE_PATH_TITLE = "使用相对路径？"
USE_RELATIVE_PATH_MESSAGE = "指定相对于环境文件位置的路径？"
ENVIRONMENTS_FEATURE_DISABLED = "此系统禁用了 TestStand 环境。"
SAVE_ENVIRONMENT_BEFORE_CHANGING = "环境文件尚未保存。请在设置引擎环境之前保存文件。"
CANNOT_SAVE_GLOBAL_ENVIRONMENT = "无法为 <Global> 环境设置自定义目录。请选择不同的环境文件以使用自定义目录。"

[WRITE_RECORD_DLG]
CONFIGURE_WRITE_RECORD = "配置写入记录"
EDIT_STEP_MENU_NAME = "配置写入记录..."

[NEW_CSV_FILE_OUTPUT_RECORD_STREAM_DLG]
CONFIGURE_NEW_CSV_FILE_OUTPUT_RECORD_STREAM = "配置新的 CSV 输出流"
EDIT_STEP_MENU_NAME = "配置新的 CSV 输出流..."

[NEW_CSV_FILE_INPUT_RECORD_STREAM_DLG]
CONFIGURE_NEW_CSV_FILE_INPUT_RECORD_STREAM = "配置新的 CSV 输入流"
EDIT_STEP_MENU_NAME = "配置新的 CSV 输入流..."

[STREAM_LOOP_DLG]
CONFIGURE_STREAM_LOOP = "配置流循环"
EDIT_STEP_MENU_NAME = "配置流循环..."

[SWEEP_LOOP_DLG]
CONFIGURE_SWEEP_LOOP = "配置扫描循环"
EDIT_STEP_MENU_NAME = "配置扫描循环..."

[AUTO_CUSTOM_DLG]
CONFIGURE_AUTO_CUSTOM = "配置 %1"
EDIT_STEP_MENU_NAME = "配置 %1..."

[IMPORT_AUTOPROPS_DLG]
DLG_TITLE = "从 .NET 程序集导入/更新自动属性面板类型"
DOTNET_ASSEMBLY_LABEL = ".NET 程序集："
PREFIX_LABEL = "前缀（可选）："
HELP = "帮助"
IMPORT = "导入"
CANCEL = "取消"
SELECT_FILE = "将类型导入文件："
IMPORT_WARNING = "导入类型将修改任何具有相同类型名称的 TestStand 类型。此操作无法撤消。点击"CANCEL"按钮以中止此操作。"
IMPORT_WARNING_CAPTION = "导入警告"
INVALID_PREFIX_NAME = "无效的前缀名。前缀可以字母或下划线开头，可以包含字母、数字和下划线。"
INVALID_PREFIX_NAME_CAPTION = "无效前缀"
CLASS_DESCRIPTION_SEPARATOR = "-"
NO_TYPES_WERE_UPDATED_CAPTION = "没有类型被更新"
NO_TYPES_WERE_UPDATED_TEXT = "没有类型被更新，因为相应的 TestStand 类型已经与 .NET 类型相匹配。"
TYPES_WERE_UPDATED_CAPTION = "类型已更新。"
TYPES_WERE_UPDATED_TEXT = "更新了以下类型："
STEP_DEFAULTS_WERE_UPDATED_CAPTION = "步骤默认值已更新。"
STEP_DEFAULTS_WERE_UPDATED_TEXT_1 = "步骤类型 %1 的默认值已更新。"
ERR_FINDING_TYPES_CAPTION = "查找要导入的 AutoProps 类型时出错。"
ERR_FINDING_TYPES_TEXT_1_2 = "在程序集 '%1' 中搜索 AutoProps 类型时出错：\n\n%2"
