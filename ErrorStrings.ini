;; ErrorStrings.ini - 引擎错误字符串
;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"


[错误]
STRING_NOT_IN_TABLE = "在语言资源文件中找不到字符串"
ERROR_32_BIT_POINTER_WITH_64_BIT_PLATFORM = "用于 64 位平台的 32 位指针。"

[TE_ERRORS]
TE_MEAS_STUDIO_INTERFACE_NOT_FOUND = "在 DLL 中找不到 TestStand/Measurement Studio 接口。您必须将 TestStand 支持类库添加到您的 Measurement Studio 项目或在您的项目中包含 tsdllparams.cpp。"
TE_RSTRING_NOT_FOUND = "未找到资源字符串。"
TE_OUT_OF_MEMORY = "内存不足。"
TE_UNABLE_TO_ALLOCATE_SYSTEM_RESOURCE = "无法分配系统资源。"
TE_UNABLE_TO_INITIALIZE_OLE_SYSTEM_DLLS = "无法初始化 OLE 系统 DLL。"
TE_STACK_OVERFLOW = "检测到堆栈溢出情况。"
TE_CONVERTED_ERROR_CODE = "一个非负错误代码被转换成这个错误代码，因为需要一个负错误代码。"
TE_INT32_OVERFLOW = "一个带符号的 32 位值溢出了。"
TE_UINT32_OVERFLOW = "一个无符号的 32 位值溢出了。"
TE_INT64_OVERFLOW = "一个带符号的 64 位值溢出了。"
TE_UINT64_OVERFLOW = "无符号 64 位值溢出。"
TE_EXTERNAL_SERVER_UNAVAILABLE = "外部服务器不可用。"
TE_PROGRAM_ERROR = "程序错误。"
TE_IO_ERROR = "一般 I/O 错误。"
TE_UNABLE_TO_OPEN_FILE = "无法打开文件。"
TE_UNABLE_TO_OPEN_DIR = "无法打开目录。"
TE_UNEXPECTED_END_OF_FILE = "文件意外结束。"
TE_BAD_NET_PATH = "网络路径错误，或网络无响应。"
TE_DRIVE_NOT_READY = "驱动器未就绪错误。"
TE_INVALID_PATHNAME = "路径名无效。"
TE_ACCESS_DENIED = "访问被拒绝。"
TE_FILE_ALREADY_EXISTS = "文件已经存在。"
TE_DISK_FULL = "磁盘已满。"
TE_FILE_NOT_FOUND = "找不到文件或目录。"
TE_SHARING_VIOLATION = "共享违规。"
TE_WRITE_PROTECTED = "磁盘写保护。"
TE_INVALID_DRIVE = "盘符无效。"
TE_PATH_NOT_FOUND = "找不到路径。"
TE_UNABLE_TO_CLOSE_FILE = "无法关闭文件。"
TE_OPERATION_FAILED = "操作失败。"
TE_OPERATION_TIMED_OUT = "操作超时。"
TE_REGISTRY_ACCESS_ERROR = "无法访问系统注册表。"
TE_REGISTRY_ITEM_NOT_FOUND = "在系统注册表中找不到项目。"
TE_DLL_NOT_LOADABLE = "无法加载 DLL 或库。"
TE_FUNC_NOT_IN_LIB = "无法在库中找到函数。"
TE_BAD_FILE_FORMAT = "文件格式不正确。"
TE_OUT_OF_DATE_FILE_FORMAT = "过时的文件格式。"
TE_NEWER_FILE_FORMAT = "由较新版本的 TestStand 创建的文件。"
TE_INVALID_OR_OUT_OF_RANGE = "值无效或超出范围。"
TE_INDEX_OUT_OF_RANGE = "索引超出范围。"
TE_NO_ITEMS_IN_LIST = "列表中没有项目。"
TE_TOO_MANY_ITEMS = "物品太多。"
TE_UNRECOGNIZED_VALUE = "无法识别的值。"
TE_DUPLICATE_ITEM_OR_VALUE = "重复的项目或价值。"
TE_UNEXPECTED_TYPE = "指定的值没有预期的类型。"
TE_ILLEGAL_OPERATION_ON_VALUE = "无法对指定值执行指定操作。"
TE_ARRAY_LOCKED = "阵列无法修改，因为它已被锁定。"
TE_UNEXPECTED_SYSTEM_ERROR = "意外的操作系统错误。"
TE_THREAD_CREATION_FAILED = "无法创建线程。"
TE_OPERATION_IN_PROGRESS = "错误，正在进行操作。"
TE_UNKNOWN_VAR_OR_PROP = "未知变量或属性名称。"
TE_UNKNOWN_TYPE = "未知类型名称。"
TE_NAME_ALREADY_IN_USE = "物品名称无效 - 已被使用。"
TE_MISSING_TYPE = "未知或缺失类型。"
TE_TYPE_CONFLICT = "无效类型 - 与现有类型冲突。"
TE_LVRTDLL_NOT_LOADED = "未加载 LabVIEW 运行时 DLL (lvrt.dll)。"
TE_READ_OBJECT_NOT_FOUND = "无法读取对象：找不到对象名称。"
TE_MEMORY_CHECKING = "内存检查错误。"
TE_INCOMPATIBLE_PARAMETERS = "无法接受传入的参数。"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER = "无法接受传入的参数。"
TE_OBJECT_TYPE_INCOMPATIBLE_WITH_PARAMETER = "无法接受传入的参数。"
TE_UNABLE_TO_PASS_BY_REFERENCE = "无法接受传入的参数。"
TE_EXPR_VALUE_NOT_SUPERSET_OF_PARAMETER = "无法接受传入的参数。"
TE_WRONG_NUMBER_OF_PARAMETERS = "参数数量错误。"
TE_EVALUATION_CONTEXT_NOT_AVAILABLE = "评估上下文不可用。"
TE_SINGLE_DIM_NUMERIC_ARRAY_EXPECTED = "需要一维数值数组。"
TE_TWO_DIM_NUMERIC_ARRAY_EXPECTED = "需要二维数值数组。"
TE_ARRAY_TYPE_EXPECTED = "类型不匹配。"
TE_ARRAY_DIMENSION_EXPECTED = "数组维度不匹配。"
TE_ARRAY_DIMENSION_SIZE_EXPECTED = "数组维度大小不匹配。"
TE_INVALID_POINTER = "无效指针。"
TE_EMPTY_EXPRESSION = "表达式不能为空。"
TE_MISMATCHED_ITEMS = "不匹配的物品或不匹配的物品。"
TE_OBJECT_LOCKED = "受保护对象已锁定，无法访问。"
TE_UNEXPECTED_CHANGE_COUNT = "意外的变化计数。"
TE_INVALID_REG_EXPR = "无效的正则表达式。"
TE_LVALUE_EXPECTED = "需要一个值或属性来接收结果值。"
TE_BAD_PROP_OR_VAR_NAME = "无效的变量或属性名称。"
TE_UNKNOWN_FUNCTION_OR_SEQUENCE_NAME = "未知函数或序列名称。"
TE_TYPE_MISMATCH_ERROR = "变量或属性类型不匹配或不兼容。"
TE_BAD_EXPRESSION = "表达式语法错误。"
TE_INVALID_WHEN_NOT_SUSPENDED = "只有在暂停执行时才允许操作。"
TE_ARRAY_INDEX_OUT_OF_BOUNDS = "数组索引越界。"
TE_WRONG_NUMBER_OF_ARRAY_INDICES = "数组索引数错误。"
TE_MISMATCHED_ARRAY_BOUNDS = "指定的数组边界不匹配。"
TE_OVER_MAX_ARRAY_BOUNDS = "%1 超出了最大数组大小 %2。"
TE_CURRENT_SEQFILE_NOT_AVAILABLE = "当前序列文件不可用。"
TE_UNABLE_TO_LAUNCH_CVI = "无法启动 CVI。"
TE_CVI_OLE_NOTREG = "CVI 自动化服务器没有在这台机器上注册。\n你必须至少运行一次 CVI 才能注册它自己。\n这个操作需要 CVI 版本 7.1.1 或更高版本。"
TE_CVI_OLE_ERROR = "访问 CVI ActiveX 自动化服务器时发生错误。"
TE_CVI_AUTO_CMD_FAILED = "CVI ActiveX 自动化服务器命令失败。"
TE_OS_EXCEPTION = "系统级异常。"
TE_NOT_SUPPORTED = "此版本的 TestStand 不支持。"
TE_MODULE_LOAD_FAILURE = "无法加载所需步骤的关联模块。"
TE_MODULE_NOT_SPECIFIED = "试图为尚未指定模块的步骤加载模块。"
TE_SEQUENCE_ABORTED = "序列中止。"
TE_SEQUENCE_TERMINATED = "序列终止。"
TE_OPERATION_CANCELED = "操作已取消。"
TE_ITEM_CANNOT_BE_DELETED = "项目被锁定、保护或正在使用中，无法删除。"
TE_TYPE_CANNOT_BE_DELETED = "类型被锁定、保护或正在使用中，无法删除。"
TE_TYPE_WITH_DEPENDING_INSTANCES_CANNOT_BE_DELETED = "无法删除具有依赖实例的类型。"
TE_OBJECT_CANNOT_BE_ADDED = "无法添加属性对象。"
TE_INVALID_ADAPTER_NAME = "无效的适配器名称。"
TE_STEP_TYPE_NOT_FOUND = "未找到步骤类型。"
TE_NEGATIVE_START_INDEX = "起始索引不能为负数。"

TE_CVI_REG_VALUE_TYPE_MISMATCH = "LabWindows/CVI 注册表项的类型与预期不同。"
TE_CVI_REG_VALUE_NOT_FOUND = "未找到 LabWindows/CVI 注册表项。"
TE_CVI_REG_KEY_NOT_FOUND = "未找到 LabWindows/CVI 注册表项。"
TE_CVI_REG_GENERIC_READ_ERROR = "读取 LabWindows/CVI 注册表项时出错。"
TE_CVI_MODULE_HAS_UNRESOLVED_REFERENCES = "一个 LabWindows/CVI 代码模块有无法解析的外部引用。"
TE_CVI_FUNC_NOT_FOUND_IN_MODULE = "在步骤的代码模块中找不到函数。"
TE_CVI_CANT_CONNECT_TO_TECRUN = "无法连接到 LabWindows/CVI 项目中的 tscvirun.dll。确保 tscvirun_supp.c 在 LabWindows/CVI 项目中并且该项目可运行。"
TE_CVI_UNABLE_TO_TERMINATE_USER_PROG = "无法在当前运行的 LabWindows/CVI 版本中终止用户程序。"
TE_CVI_NON_DLL_MODULE_NOT_SUPPORTED = "LabWindows/CVI 适配器不再支持以 .dll 以外的格式调用模块。如果可能，从现有的源 (.c)、对象 (.obj) 或库 (.lib) 文件创建一个 .dll。 "
TE_CVI_VERSION_NOT_SUPPORTED = "LabWindows/CVI 的活动版本不支持进程外运行 CVI 适配器步骤或 CVI 适配器的创建和编辑代码功能。配置 CVI 适配器以执行进程内步骤，或升级到 LabWindows/CVI 的最低支持版本。要更改 CVI 的活动版本，请启动要激活的 CVI 版本。"
TE_DISP_UNKNOWN_INTERFACE = "未知接口 ID。"
TE_DISP_UNKNOWN_MEMBER_NAME = "未知成员名称。"
TE_DISP_UNKNOWN_MEMBER_ID = "未知会员 ID。"
TE_DISP_OBSOLETE_MEMBER = "过时的成员。"
TE_DISP_UNKNOWN_PARAM_NAME = "命名参数的未知名称。"
TE_DISP_UNKNOWN_PARAM_ID = "命名参数的未知 ID。"
TE_DISP_MISSING_PARAM_NAME = "未传递预期的命名参数。"
TE_DISP_MISSING_PARAM_ID = "指定参数的预期 ID 未通过。"
TE_DISP_MISSING_ARG = "缺少必需的参数。"
TE_LV_AUTO_SERVER_ERR = "访问 LabVIEW ActiveX 自动化服务器时发生错误。"
TE_LV_REPORTED_ERR = "LabVIEW 报告了一个错误。有关如何解决此问题的更多详细信息，请参阅'LabVIEW：'消息。"
TE_LV_MISSING_REQUIRED_ARG = "缺少必需的参数。连接在 VI 中被标记为必需。"
TE_LV_RUN_TIME_ENGINE_ERR = "访问 LabVIEW 运行时引擎 DLL 时发生错误。"
TE_LV_TYPE_CONVERSION_ERR = "无法将 TestStand 类型转换为 LabVIEW 类型，反之亦然。"
TE_LV_VI_ABORTED_ERR = "LabVIEW VI 的执行被中止。"
TE_LV_NXG_AUTO_SERVER_ERR = "访问 LabVIEW NXG ActiveX 自动化服务器时发生错误。"
TE_LV_NXG_REPORTED_ERR = "LabVIEW NXG 报告了一个错误。"
TE_LV_NXG_MISSING_REQUIRED_ARG = "缺少必需的参数。连接在 VI 中被标记为必需。"
TE_LV_NXG_RUN_TIME_ENGINE_ERR = "访问 LabVIEW NXG 运行时引擎 DLL 时发生错误。"
TE_LV_NXG_TYPE_CONVERSION_ERR = "无法将 TestStand 类型转换为 LabVIEW NXG 类型，反之亦然。"
TE_LV_NXG_AUTO_BUILD_ERR = "构建 LabVIEW NXG GLL 时发生错误。"
TE_LV_NXG_RTEDLL_NOT_LOADED = "未加载 LabVIEW NXG 运行时 DLL (lvrt.dll)。"
TE_WRONG_NUM_POSITIONAL_PARAMS = "位置（未命名）参数的数量错误。"
TE_FILE_NOT_CONVERTABLE_TO_SEQFILE = "没有转换器可以将此文件转换为序列文件"
TE_FILE_NOT_CONVERTABLE_FROM_SEQFILE = "无法反向翻译序列文件"
TE_AUTO_OBJ_NOLONGER_VALID = "自动化对象不再有效。Release() 是此调度指针上唯一允许的操作。"

TE_DDE_FAIL = "DDE 交易失败。"
TE_NO_FILE_ASSOC = "没有应用程序与给定的文件扩展名关联。"
TE_ADAPTER_NO_CONNECT_TO_AUTO_SERVER = "无法连接到支持此适配器的自动化服务器。\n请验证 HTBasic 适配器配置是否指定了有效的 HTBasic 运行时或开发服务器。"
TE_ADAPTER_SERVER_CONNECTION_LOST = "与支持此适配器的自动化服务器的连接丢失。"
TE_FAIL_TO_REGISTER_CLIPFORMAT = "注册剪贴板格式失败。"
TE_TYPE_LIBRARY_READ_ERROR = "读取 ActiveX 自动化服务器类型库时发生错误。"
USER_DEFINED_ERR_CODE = "用户定义的错误代码。"

TE_REMOTE_SEQUENCE_ERROR = "远程执行错误。"
TE_REMOTE_SEQUENCE_ERROR_UNABLE_TO_CONNECT = "无法连接到远程 TestStand 引擎。"
TE_REMOTE_SEQUENCE_REMOTE_EXECUTION_DENIED = "与 TestStand 引擎的连接被拒绝。"
TE_REMOTE_HOST_NOT_SPECIFIED = "试图为尚未指定远程主机的远程序列调用步骤加载模块。"

TE_ACTIVEX_AUTOMATION_SERVER_EXCEPTION = "ActiveX 自动化服务器异常。"
TE_DOES_NOT_HAVE_PRIVILEGE = "用户没有所需的权限。"

SOURCE_CODE_CONTROL_ERROR = "执行源代码控制期间发生错误。"

TE_METHOD_OR_PROP_NOT_AVAILABLE = "该方法或属性对当前对象不可用。"
TE_VISUAL_STUDIO_AUTOMATION_ERROR = "Visual Studio 自动化期间发生错误。"
TE_XML_ERROR = "解析 XML 流时发生错误。"
TE_SOURCE_CODE_CONTROL_ERROR = "源代码控制错误。"
TE_WATCHEXPRESSION_ERROR = "观察表达式错误。"
TE_DNASSEMBLY_MISSING = "无法加载 .NET 支持 DLL。\n这是由无法解析的程序集路径引起的！"
TE_PROP_LOADER_AMBIGUITY = "重复的步骤名称。\n尝试导入/导出名称重复的步骤的步骤属性是不明确的。"
TE_ENUM_NOT_COMPATIBLE = "与该参数的类型库枚举不兼容。"

ERR_LVNXG_NOT_SUPPORTED_IN_32BIT = "32 位 TestStand 不支持此功能。"

ERR_EVALUATING_EXPRESSION_FOR_PROPERTY_1_2 Line0001 = "计算属性表达式时出错：%1"
ERR_EVALUATING_EXPRESSION_FOR_PROPERTY_1_2 Line0002 = "\n表达式：'%2'"

[ERR_DESCR]
CHANGE_STEP_TYPE_NOT_SUPPORTED_ON_RUNTIME_STEPS = "不支持更改步骤的运行时副本的步骤类型。步骤的步骤类型只能在编辑时更改。"
TYPE_DEF_PASSWORD_CANNOT_BE_EMPTY = "类型定义密码不能为空。"
TYPE_CONFLICT_RESOLUTION_WOULD_MODIFY_LOCKED_TYPE = "类型 '%1' 已锁定且无法修改。您可以通过在编辑器或用户界面中打开包含该类型的文件并使用所需密码解锁来解决此问题。"
CANT_SAVE_AS_PREV_DUE_TO_LOCKED_TYPE_DEF = "如果不先解锁它们，就无法保存具有锁定类型定义的文件，因为以前版本的 TestStand 不支持类型定义锁定。类型 '%1' 当前已锁定。"
RANGE_OPERATOR_WITH_STRING_ERROR = "使用字符串名称和范围运算符的下标无效。"
INVALID_ARGUMENT_NAME = "参数集合中不存在指定的参数名称 '%1'。"

STATION_GLOBALS_BACKUP_FILE_ELAB Line0001 = "如果您将站选项设置为创建站全局文件的备份（该设置位于站选项对话框的文件选项卡上。），"
STATION_GLOBALS_BACKUP_FILE_ELAB Line0002 = "您可以通过复制其中一个备份文件覆盖空间站全局文件来恢复备份。备份文件与空间站全局文件位于同一目录中。"
CONV_FUNC_ARG_MUST_HAVE_VALUE = "转换函数参数必须有一个值（即数组和容器不是有效参数）。"
INTEGER_DIVIDE_BY_ZERO = "不能将整数除以零。"
NOT_UINT64_1_2 = "%1 值 %2 不能精确表示为 64 位无符号整数。"
NOT_INT32_1_2 = "%1 值 %2 不能精确表示为 32 位有符号整数。"
INFO_FOR_32BIT_INPROC_COM_COCREATE_ERROR Line0001 = "此错误的一个可能原因是服务器可能是进程内 32 位 COM 服务器。当前运行的 TestStand 版本是 64 位进程和 Windows "
INFO_FOR_32BIT_INPROC_COM_COCREATE_ERROR Line0002 = "不允许在同一进程中混合使用 32 位和 64 位代码。TestStand 可以从进程外的 32 位 COM 服务器创建对象"
INFO_FOR_32BIT_INPROC_COM_COCREATE_ERROR Line0003 = "直接，但对于进程内 32 位 COM 服务器，您必须在外部 32 位进程中创建对象，并使用进程外服务器或 DLLSurrogate 将其传递到 TestStand。"
INFO_FOR_64BIT_INPROC_COM_COCREATE_ERROR Line0001 = "此错误的一个可能原因是服务器可能是进程内 64 位 COM 服务器。当前运行的 TestStand 版本是 32 位进程和 Windows "
INFO_FOR_64BIT_INPROC_COM_COCREATE_ERROR Line0002 = "不允许在同一进程中混合使用 32 位和 64 位代码。TestStand 可以从进程外的 64 位 COM 服务器创建对象"
INFO_FOR_64BIT_INPROC_COM_COCREATE_ERROR Line0003 = "直接，但对于进程内 64 位 COM 服务器，您必须在外部 64 位进程中创建对象，并使用进程外服务器或 DLLSurrogate 将其传递到 TestStand。"
ERROR_READING_TYPES_FROM_COMPAT_FILE = "从兼容性文件 '%1' 中读取类型以保存为以前的类型时出错。确保如果此文件与另一个兼容性文件具有相同的类型，则两个文件中的共同类型是相同的。"
FAILED_LOAD_MANAGED_DLL Line0001 = "无法加载 TestStand 管理的 DLL 'ManagedSupport.dll'。如果 "
FAILED_LOAD_MANAGED_DLL Line0002 = "DLL 丢失或者此计算机上未安装 .NET Framework v2.0。"
TS_ASSMBLIES_NOT_IN_GAC = "无法加载 TestStand .NET 程序集。验证 TestStand .NET 程序集是否已安装到全局程序集缓存 (GAC) 中。"
TOO_BIG_FOR_XML = "无法分配足够的内存来保存文件。您尝试保存的文件对于 XML 格式来说可能太大。尝试将格式更改为二进制或 ini 并重新保存文件。"
HAD_TO_FREE_EXE_DOC_CACHE_FOR_RESOURCES = "系统资源不足。序列编辑器正在释放缓存资源。关闭所有未使用的窗口。\n\n如果您反复看到此消息，请退出并重新启动序列编辑器。"
BINARY_FILE_CORRUPT = "二进制文件不可读。此文件可能已作为文本文件签入到源代码管理中，导致数据被源代码管理系统错误地修改。如果您正在使用源代码管理，请确保此文件被标记为二进制文件在您的源代码控制系统中。"
CANNOT_EDIT_INSTALLED_TYPE = "无法修改类型 '%1'，因为它是 NI 安装的类型。"
LOW_GDI_OR_USER_RESOURCES_FOR_EXECUTION Line0001 = "无法为执行 '%1' 创建窗口。可用于此进程的 GDI 或 USER 资源太少。关闭不需要的窗口以释放更多资源。"
LOW_GDI_OR_USER_RESOURCES_FOR_EXECUTION Line0002 = "为避免大量提示，此次执行将禁用跟踪。"
LOW_GDI_OR_USER_RESOURCES = "无法创建窗口。可用于此进程的 GDI 或 USER 资源太少。关闭不需要的窗口以释放更多资源。"
FILE_FORMAT_ERROR_INVALID_ATTRIBUTE_VALUE = "行 %2 字符 %3 的 XML 属性 '%1' 的值无效"
FILE_FORMAT_ERROR_UNEXPECTED_ATTRIBUTE = "行 %2 字符 %3 上出现意外的 XML 属性 '%1'"
FILE_FORMAT_ERROR_MISSING_XML_ATTRIBUTE = "第 %2 行字符 %3 上缺少 XML 属性 '%1'"
FILE_FORMAT_ERROR_NO_XML_ELEMENT = "第 %2 行字符 %3 缺少 XML 元素。未找到元素。"
FILE_FORMAT_ERROR_WRONG_TYPE_BOOL = "第 %2 行字符 %3 的 XML 值类型错误。需要布尔值。"
FILE_FORMAT_ERROR_WRONG_TYPE_DOUBLE = "第 %2 行字符 %3 的 XML 值类型错误。需要浮点数。"
FILE_FORMAT_ERROR_WRONG_TYPE_UINT = "第 %2 行字符 %3 上的 XML 值类型错误。应为无符号整数。"
FILE_FORMAT_ERROR_WRONG_TYPE_INT = "第 %2 行字符 %3 的 XML 值类型错误。应为整数。"
FILE_FORMAT_ERROR_WRONG_TYPE_UINT64 = "第 %2 行字符 %3 上的 XML 值类型错误。需要 64 位无符号整数。"
FILE_FORMAT_ERROR_WRONG_TYPE_INT64 = "第 %2 行字符 %3 的 XML 值类型错误。需要 64 位整数。"
FILE_FORMAT_ERROR_MISSING_XML_ELEMENT = "行 %2 字符 %3 上缺少 XML 元素"%1"
FILE_FORMAT_ERROR_MISSING_XML_ELEMENT_END = "第 %2 行字符 %3 上缺少 XML 元素结束 '%1'"
FILE_FORMAT_ERROR_MISSING_EXPECTED_STRING = "第 %2 行字符 %3 上缺少预期的字符串 '%1'"
FILE_FORMAT_ERROR_NON_TYPEDEF_MATCHING_PROP_MISSING = "找不到第 %2 行字符 %3 上指定的非 typedef 匹配属性 '%1'。"
WARNING_OVERWRITING_TEXT_FILE_WITH_BINARY Line0001 = "您正在将文件 '%1' 的格式从文本格式更改为二进制格式。如果您将此文件存储在源代码控制系统中，请将文件类型更改为源代码控制系统中的二进制文件，以便正确存储文件当您将其签入源代码管理时。"
WARNING_OVERWRITING_TEXT_FILE_WITH_BINARY Line0002 = "使用工具菜单中的序列文件格式转换器工具一次更改多个文件的格式。"
TYPE_NOT_IN_FILE_NO_GLOBAL = "在文件中找不到类型 '%1' 并且不存在该名称的全局类型。"
TYPE_NOT_IN_FILE_FOUND_TYPE_IS_WRONG_KIND = "无法在文件中找到类型 '%1'，该名称的全局类型是错误的类型。"
POSSIBLE_SYSTEM_ERROR = "可能的系统错误："
ERR_MIGHT_INVOLVE_MARSHALING Line0001 = "发生这种情况的一个原因是如果您的 COM 服务器的接口不能"
ERR_MIGHT_INVOLVE_MARSHALING Line0002 = "被编组。如果你的服务器没有使用默认的 OLE，就会发生这种情况"
ERR_MIGHT_INVOLVE_MARSHALING Line0003 = "编组实现并且没有实现自己的代理和存根"
ERR_MIGHT_INVOLVE_MARSHALING Line0004 = "代码。如果您使用 Visual C++ 编写服务器，您可以添加 "
ERR_MIGHT_INVOLVE_MARSHALING Line0005 = "oleautomation 属性到你的界面以便使用默认的 OLE "
ERR_MIGHT_INVOLVE_MARSHALING Line0006 = "编组实现。或者，COM 不需要编组"
ERR_MIGHT_INVOLVE_MARSHALING Line0007 = "如果服务器的线程模型与客户端线程的单元相同。"
ERR_MIGHT_INVOLVE_MARSHALING Line0008 = "您可以尝试更改服务器的线程模型或客户端线程的"
ERR_MIGHT_INVOLVE_MARSHALING Line0009 = "公寓避免编组接口的需要。"
ERR_MIGHT_INVOLVE_LONG_BREAKPOINT_IN_VC Line0001 = "尝试从全局接口表中检索 ActiveX 引用时发生以下错误：\n\n%1\n"
ERR_MIGHT_INVOLVE_LONG_BREAKPOINT_IN_VC Line0002 = "发生此错误的原因之一是您在 Visual Studio 中调试应用程序并且"
ERR_MIGHT_INVOLVE_LONG_BREAKPOINT_IN_VC Line0003 = "在断点处暂停了很长时间。您可能需要重新启动应用程序才能正常运行"
ERR_MIGHT_INVOLVE_LONG_BREAKPOINT_IN_VC Line0004 = "以避免不断出现此错误。"
CANT_GOTO_SEQ_BECAUSE_ITS_HIDDEN = "无法转到序列 '%1'，因为它是隐藏的。"
ERROR_WRONG_ENGINE_VER_REGISTERED Line0001 = "注意：当前注册的 TestStand 引擎版本不同于"
ERROR_WRONG_ENGINE_VER_REGISTERED Line0002 = "最初加载的版本。这可能是问题的根源。使用 TSVerSelect.exe 实用程序时可能会发生这种情况。确保切换回适当的版本。"
DEAD_LOCK_CAUSED_BY_LOAD_CALLBACKS = "无法从序列文件 '%2' 的加载回调调用序列文件 '%1'。这样做会导致该文件的加载回调死锁。涉及以下加载回调："
ERROR_ADDING_1ST_REF_WITHOUT_SEQ_FILE_CACHE_LOCK = "无法在不持有序列文件缓存锁的情况下添加第一个编辑器引用。"
LOAD_CALLBACK_DEADLOCK_ELAB_MSG_FMT = "文件 '%1' 的加载回调正在等待文件 '%2' 的加载回调。"
INVALID_PARAM_VALUE = "值 '%1' 对这种类型的参数无效。"
COULD_NOT_FIND_FILES_IN_WORKSPACE = "无法找到工作区引用的以下文件："
COULD_NOT_FIND_FILE_REFED_BY_OTHER_FILE = "找不到 '%2' 中序列调用引用的文件 '%1'。"
CANT_FIND_FILE = "找不到文件 '%1'。"
CANT_FIND_FILE_WITH_QUALIFIED_NAME_IN_PROJECT = "在项目 '%2' 中找不到具有限定名称 '%1' 的文件。"
NO_GLL_SPECIFIED = "没有指定 GLL。"
NO_PROJECT_SPECIFIED = "没有指定项目。"
CANT_FIND_FILE_WITH_QUALIFIED_NAME_IN_GLL = "在 GLL '%2' 中找不到具有限定名称 '%1' 的文件。"
CANT_FIND_ITEM_IN_LV_PACKED_LIBRARY = "无法在 LabVIEW 打包项目库 '%2' 中找到项目 '%1'。"
CANT_FIND_MEMBER_IN_LVCLASS = "无法在 LabVIEW 类 '%2' 中找到成员 '%1'。"
TE_CANT_READ_FILE_ELAB = "从文件 '%1' 读取错误。"
TE_UNABLE_TO_OPEN_FILE_DESC = "无法打开文件 '%1'。"
TE_IO_ERROR_DESC_1 = "文件 '%1' 的一般 I/O 错误。"
TE_UNABLE_TO_OPEN_DIR_DESC = "无法打开目录 '%1'。"
TE_CANT_WRITE_FILE_ELAB = "写入文件 '%1' 时出错。"
TE_CANT_WRITE_READONLY_FILE_ELAB = "无法写入只读文件 '%1'。"
TE_CANT_WRITE_CFG_DIR_MSG Line0001 = "\n\n注意：在 TestStand 配置中写入文件时可能会出现此错误 "
TE_CANT_WRITE_CFG_DIR_MSG Line0002 = "目录，如果你没有创建或写入文件的权限"
TE_CANT_WRITE_CFG_DIR_MSG Line0003 = "目录。要解决这个问题，您可以更改对 "
TE_CANT_WRITE_CFG_DIR_MSG Line0004 = "配置目录，改变配置目录的位置"
TE_CANT_WRITE_CFG_DIR_MSG Line0005 = "在 Station Options对话框的 Preferences 页面上，或更改在 "
TE_CANT_WRITE_CFG_DIR_MSG Line0006 = "HKEY_LOCAL_MACHINE\\SOFTWARE\\National Instruments\\TestStand\\<版本>\\CfgLocation 注册表项。"

CANT_ADD_FILE_TO_WORKSPACE = "无法将文件 '%1' 添加到工作区，因为它不存在。"

CANT_LOAD_DLL Line0001 = "无法加载 DLL 或外部库 '%1'。\nWin32 错误代码 = '%2'\n错误描述 = %3\n"
CANT_LOAD_DLL Line0002 = "此 DLL 可能正在尝试加载另一个 DLL。当 DLL1 加载 DLL2 时，Windows 根据 Windows DLL 搜索算法搜索附属 DLL2。"
CANT_LOAD_DLL Line0003 = "为确保 Windows 找到 DLL2，您可以将 DLL2 放在以下位置之一：\n"
CANT_LOAD_DLL Line0004 = "1) 包含 DLL1 的目录。\n"
CANT_LOAD_DLL Line0005 = "2) 应用程序可执行文件的目录，例如 C:\\TestStand\\Bin\\.\n"
CANT_LOAD_DLL Line0006 = "3)系统搜索路径。系统搜索路径包括系统目录（如C:\\WinNT\\System32\\或C:\\Windows\\System\\）、Windows目录（如C :\\WinNT\\ 或 C:\\Windows\\), "
CANT_LOAD_DLL Line0007 = "以及在 PATH 环境变量中列出的目录。\n"

CANT_LOAD_DLL_2 = "无法加载 DLL 或外部库 '%1'。"

CANT_LOAD_DLL_ELAB_MSG = "此 DLL 需要以下无法找到或加载的 DLL：\n"
DEPENDENT_DLL_NOT_FOUND = "%1（未找到）\n"
DEPENDENT_DLL_NOT_READABLE = "%1（读取文件时出错）\n"

LOAD_DLL_WRONG_BITNESS_ELAB_32 = "该 DLL 是 64 位 DLL，因此不能由 32 位 TestStand 加载。"
LOAD_DLL_WRONG_BITNESS_ELAB_64 = "该 DLL 是 32 位 DLL，因此不能由 64 位 TestStand 加载。"

CANT_LOAD_DLL_3 = "无法加载 DLL '%1'。\nWin32 错误代码 = '%2'\n错误消息 = %3\n"

ACTIVATION_CONTEXT_FUNCTION_FAILED = "无法加载 cviauto.dll 以创建 CAObjHandle，因为 %1 函数失败。\nWin32 错误代码 = '%2'\n错误消息 = %3\n"

CANT_FIND_FUNC_IN_DLL = "在 DLL（或外部模块）'%2' 中找不到函数 '%1'。"
CANT_LOAD_LV_BUILT_DLL = "此 DLL 需要 LabVIEW 运行时引擎版本 %1，但在此计算机上找不到。"
SYSTEM_ERR_31 = "无法加载 DLL 或系统设备不工作"
CANT_LOAD_SXS_CVI_DLL = "无法加载 DLL 所需的 SxS 版本的 cvirte.dll。确认您安装了 SxS CVI 运行时引擎。函数 %1 失败。\nWin32 错误代码 = '%2'\n错误消息 = %3\n "

REGEXPR_OutOfMemory = "内存不足"
REGEXPR_UnmatchedChar = "不匹配 '%1'"
REGEXPR_InvalidCharInRange = "范围内的无效字符 ('%1')"
REGEXPR_EndWithBackslash = "不能以 '\\\\' 结尾"
REGEXPR_InvalidHexValue = "'\\\\x' 后的十六进制值无效"
REGEXPR_OperatorOnEmptyPattern = "'%1' 应用于空模式"
REGEXPR_EmptyLeftSide = "'|' 的左侧是空的"
REGEXPR_EmptyRightSide = "'|' 的右侧是空的"
REGEXPR_EmptyGroup = "空组"
REGEXPR_InvalidRange = "无效范围"
REGEXPR_EmptySet = "空集"
REGEXPR_EmptyInputString = "空输入字符串"
REGEXPR_NullInputString = "NULL 输入字符串"
REGEXPR_MultibyteCharsNotAllowedInRange = "范围内不允许多字节字符"
REGEXPR_UnknownError = "未知错误"

LV_RTDLL_NOT_INITIALIZED = "LabVIEW 运行时引擎 DLL 未初始化"
LV_RTDLL_FAILED_INITIALIZED = "无法初始化 LabVIEW 运行时引擎 DLL '%1'。"


;NXG适配器
LV_NXG_RTDLL_NOT_INITIALIZED = "LabVIEW NXG 运行时引擎 DLL 未初始化"
LV_NXG_RTDLL_FAILED_INITIALIZED = "未能初始化 LabVIEW NXG 运行时引擎 DLL '%1'。"
LV_NXG_API_IS_OBSOLETE = "此 LabVIEW NXG 适配器 API 方法/属性已过时，不应使用。有关详细信息，请参阅 NI TestStand 帮助。"

UNKNOWN_ERROR = "未知错误"

;; XML 错误
XML_PARSE_DETAILS = "\n\nXML 的失败部分：\n%1"
XML_DOM_DOC_CREATION_ERROR = "创建新的 DOM 文档对象以解析 XML 流时出错 (%1)。"
XML_SCHEMA_CACHE_CREATION_ERROR = "创建新的架构缓存对象以验证 XML 流时出错 (%1)。"
XML_COM_ERROR = "XML 字符串中的错误：\n%1\n代码 = %2\n代码含义 = %3\n来源 = %4\n错误描述 = %5\n"
XML_PARSE_ERROR = "解析 XML 字符串失败：\n 原因 = %1\n 代码 = 0x%2\n 行 = %3\n 位置 = %4\n 文本 = %5"
XML_NO_ROOT_ELEMENT_ERROR = "访问 XML 流中的根元素时出错 (%1)。"
XML_MISSING_OR_INVALID_TYPE = "在类型属性中发现缺失值、无效值或未知值\n Type='%1'。"
XML_MISSING_ATTRIBUTE = "XML 流中缺少预期的属性 '%1'。"
XML_INVALID_NUMERIC_VALUE = "XML 数值 '%1' 无效。"
XML_INVALID_HEXIDECIMAL_VALUE = "字符串（十六进制）XML 值 '%1' 无效。"
XML_INVALID_BOOLEAN_VALUE = "布尔 XML 值 '%1' 无效。"
XML_INVALID_VALUE = "字符串 XML 值 '%1' 无效。"
XML_PARSE_CONTEXTS_ERROR = "访问 XML 流 (%1) 上下文时发生意外错误。"
XML_INVALID_ID_ATTRIBUTE = "在流中指定了无效的 ID 属性值 '%1'。"
XML_EMPTY_ID_ATTRIBUTE = "在流中发现空属性值 %1=''。"
XML_UNKNOWN_TYPE = "找不到类型 '%1'。在处理 XML 流之前，该类型必须存在于加载的类型选项板或序列文件中。"
XML_INVALID_DIMENSIONS = "无法设置数组的维度。"

;;无效路径消息
INVALID_PATHNAME_1 = "无效路径：'%1'"
IO_ERROR_PATHNAME_1 = "路径的 I/O 错误：'%1'"
PATH_NOT_ABSOLUTE_1 = "路径不是绝对路径：'%1'"
PATH_SEP_MUST_FOLLOW_DRIVE_SPEC = "路径分隔符 (\\) 必须遵循驱动规范。"
UNC_PATH_INVALID_NETWORK_NAME = "路径包含无效的网络名称。"
UNC_PATH_INVALID_SHAREDIR = "路径包含无效目录名。"
UNC_PATH_MISSING_DIRECTORY = "路径在网络名称后缺少目录名称。"
UNC_PATH_MISSING_NETWORK_NAME = "路径缺少网络名称。"
PATH_BEGINS_WITH_SEPARATOR = "路径以分隔符 (\\) 开头。\n路径必须以驱动器说明 (C:) 或网络名称 (\\\\machine\\C) 开头。"
PATH_HAS_EMPTY_COMPONENT = "路径包含两个相邻的路径分隔符 (\\\\)。"
PATH_HAS_INVALID_CHARS = "一个或多个路径组件包含无效字符：(< > | : / \\ \" * ?)。
PATH_HAS_INVALID_CHARS_LABVIEW_NXG = "一个或多个路径组件包含无效字符：(< > | / \\ \" * ?)。"
PATH_IS_EMPTY = "路径为空。"
COPY_FILE_FAILED = "无法将 '%1' 复制到 '%2'。"
MOVE_FILE_FAILED = "无法将 '%1' 移动到 '%2'。"
DELETE_FILE_FAILED = "无法删除文件 '%1'。"
REMOVE_DIR_FAILED = "无法删除目录 '%1'。"
REMOVE_DIR_FAILED_NON_EMPTY = "无法删除目录 '%1'，因为它不是空的。"
FILE_ALREADY_EXISTS_WITH_PATHNAME = "路径名为 '%1' 的文件已经存在。"

ERROR_ACCESSING_REGISTRY_KEY = "无法访问注册表项 %1：%2"
ERROR_ACCESSING_REGISTRY_VALUE = "无法访问注册表值 %1：%2"
ERROR_REGISTRY_VALUE_HAS_WRONG_TYPE = "注册表值 %1 没有预期的类型。"
CANT_FIND_REGISTRY_ITEM = "在系统注册表中找不到项目 '%1'。"

TE_UNKNOWN_TYPE_DESC = "未知类型名称'%1'。"

SCC_PROVIDER_NOT_FOUND = "在注册表中找不到提供者。"
SCC_ALREADY_CONNECTED = "已经连接到提供商。"
SCC_PROVIDER_NOT_COMPATABLE = "与 SCC 提供商不兼容。"
SCC_NOT_INITIALIZED = "SCC 系统尚未初始化。"
SCC_INVALID_OPTION = "无效选项。"
SCC_NOT_FOUND_ERROR = "'%1' 未找到。"
SCC_REGISTRY_ERROR = "访问注册表时出错。"
SCC_PROVIDER_NOT_FOUND_IN_REG = "工作区 '%1' 未能找到并连接到源代码控制提供程序 '%2'。\n您的计算机上可能未安装此提供程序。"

SCC_INITIALIZE_FAILED = "'%1' 无法初始化。"
SCC_UNKNOWN_PROJECT = "项目 '%1' 对源代码控制提供商来说是未知的。"
SCC_COULD_NOT_CREATE_PROJECT = "无法创建项目。"
SCC_NOT_CHECKED_OUT = "用户没有签出文件所以不能签入。"
SCC_ALREADY_CHECKED_OUT = "用户已经签出文件。"
SCC_FILE_IS_LOCKED = "文件被锁定禁止创建新版本。"
SCC_FILE_OUT_EXCLUSIVE = "其他人对此进行了独占检查。"
SCC_ACCESS_FAILURE = "访问源代码控制系统时出现问题，\n可能是由于网络或争用问题。\n请稍后重试。"
SCC_CHECK_IN_CONFLICT = "签入失败，因为另一个提前签入并且 AutoReconcile 是错误的。"
SCC_FILE_ALREADY_EXISTS = "所选文件已在源代码管理之下。"
SCC_FILE_NOT_CONTROLLED = "所选文件不受源代码控制。"
SCC_FILE_IS_CHECKED_OUT = "用户已经签出文件。"
SCC_NO_SPECIFIED_VERSION = "指定了一个无效的版本或日期/时间。"
SCC_OP_NOT_SUPPORTED = "源代码控制系统不支持此操作。"
SCC_NON_SPECIFIC_ERROR = "非特定故障，文件未同步。"
SCC_OP_NOT_PERFORMED = "操作未执行。"
SCC_TYPE_NOT_SUPPORTED = "SCC 系统不支持该文件类型。"
SCC_VERIFY_MERGE = "文件已自动合并，但尚未在等待用户验证时检查。"
SCC_FIX_MERGE = "文件已自动合并，但由于必须手动解决的合并冲突\n而未签入。"
SCC_SHELL_FAILURE = "外壳故障。"
SCC_INVALID_USER = "用户无法登录到 SCC 提供商。"
SCC_PROJECT_ALREADY_OPEN = "项目 '%1' 已经打开。"
SCC_PROJECT_SYNTAX_ERROR = "项目 '%1' 的项目语法无效。"
SCC_INVALID_FILE_PATH = "无效或不可用的文件路径。"
SCC_PROJECT_NOT_OPEN = "没有打开任何项目。"
SCC_NOT_AUTHORIZED = "不允许用户执行此操作。"
SCC_FILE_SYNTAX_ERROR = "文件语法错误。"
SCC_FILE_NOT_EXIST = "找不到本地文件。"
SCC_CONNECTION_FAILURE = "连接失败。"
SCC_SERVER_UNAVAILABLE = "SCC 提供程序失败。\n要继续使用源代码控制集成，请退出并重新启动序列编辑器。"

INTERACTIVE_ARGS_NOT_SUPPORTED_BY_REMOTE_SEQ = "远程序列调用不支持交互式执行。"
HIERARCHICAL_EXE_NOT_SUPPORTED_BY_REMOTE_SEQ = "远程序列调用不支持分层执行。"
SPRINTF_FORMATTING_ERROR = "格式化字符串时发生错误。"
CSV_CANNOT_USE_QUOTE_AS_A_DELIMIER = "不能使用引号 (\") 作为分隔符。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC Line0001 = "DLL %1 不导出 TestStand 将 Measurement Studio、MFC 或 _bstr_t 数据传递给该 DLL 中的函数所必需的函数。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC Line0002 = "如果此 DLL 是 Measurement Studio DLL，请使用 Measurement Studio 中的添加/删除类库向导将 TestStand 支持类库添加到您的项目中。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC Line0003 = "Measurement Studio 支持需要 Measurement Studio 企业版 7.0 或更高版本。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC Line0004 = "如果此 DLL 不是 Measurement Studio DLL，请通过包含 tsdllparams.cpp 将 TestStand 对 MFC 和 _bstr_t 类的支持添加到您的 DLL 中"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC Line0005 = "<TestStand>\\API\\VC 目录中的文件，位于您的 Visual Studio 项目的源文件之一中。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC_X64 = "Measurement Studio 类与 64 位 TestStand 不兼容。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC_X64_MS Line0001 = "DLL %1 不导出 TestStand 将 MFC 或 _bstr_t 数据传递给该 DLL 中的函数所必需的函数。"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC_X64_MS Line0002 = "您可以通过包含 tsdllparams.cpp 将 TestStand 对 MFC 和 _bstr_t 类的支持添加到您的 DLL 中"
MEAS_STUDIO_INTERFACE_NOT_FOUND_DESC_X64_MS Line0003 = "<TestStand>\\API\\VC 目录中的文件，位于您的 Visual Studio 项目的一个源文件中。"
MFC_CLASS_SUPPORT_NOT_FOUND_DESC Line0001 = "DLL %1 没有导出 TestStand 将 CString 或 CStringArray 数据传递给该 DLL 中的函数所必需的函数。"
MFC_CLASS_SUPPORT_NOT_FOUND_DESC Line0002 = "要使用这些类，请将您的 Visual Studio 项目设置更改为使用 MFC 并使用多字节字符集。"

REPLACE_FAILED_CANNOT_EDIT_NAMES_IN_EXECONTXT = "你不能从执行窗口编辑属性名称。"
REPLACE_VALUE_FAILED_NOT_VALID = "对象没有可以替换的值。"
REPLACE_FAILED_MATCH_NOT_VALID = "匹配不再有效，因为该值之前已被替换值操作更改。"
REPLACE_FAILED_NO_TYPE_EDIT_PRIVILEGES = "无法编辑类型。当前用户没有该权限。"
REPLACE_FAILED_FILE_NOT_EDITABLE = "无法编辑 '%1'。文件正在被执行使用、标记为只读，或者您没有必要的用户权限。"
REPLACE_FAILED_BECAUSE_EDITED_ERR = "所做的编辑使匹配无效。"
REPLACE_FAILED_TYPE_NAME_MATCH = "类型名称匹配不支持替换。"
REPLACE_FAILED_BECAUSE_ERROR_ERR = "尝试替换匹配项时发生以下错误：\n\n%1"
REPLACE_FAILED_COMMENT_NOT_EDITABLE = "无法编辑评论，因为该属性具有标志 PropFlags_CommentNotEditable。"
REPLACE_FAILED_NOT_DELETABLE = "这个属性有标志 PropFlags_NotDeletable。"
REPLACE_FAILED_NAME_NOT_EDITABLE = "这个属性有标志 PropFlags_NameNotEditable。"
REPLACE_FAILED_NOT_EDITABLE = "这个属性有标志 PropFlags_NotEditable。"
REPLACE_FAILED_NOT_EDITABLE_SUBPROP_NAMES = "此属性无法重命名，因为其父属性具有标志 PropFlags_NotEditable。"
REPLACE_FAILED_SHARED_ERR = "此属性在其所在类型的所有实例之间共享。您必须编辑类型才能更改它。"
REPLACE_FAILED_TYPE_NAME_CANT_CHANGE_ERR = "此属性是类型实例的结构化部分，无法重命名。您必须编辑类型才能更改名称。"
REPLACE_FAILED_TYPE_LOCKED = "此属性是锁定类型定义的一部分。您必须先解锁类型定义，然后才能对其进行编辑。"
CANT_OPEN_CLIPBOARD = "无法打开剪贴板。剪贴板正在被另一个应用程序使用。"
CLIPBOARD_ERROR = "剪贴板错误。"
CLIPBOARD_ERROR_TITLE = "剪贴板错误"
CLIPBOARD_ERROR_DESC = "剪贴板错误。"
INVALID_NUMBER_VALUE = "无效的数值。"
INVALID_ACCESS_OF_FOREIGN_ENGINE = "对属于不同进程或机器中的 TestStand 引擎实例的对象的无效引用。"
LOST_CONNECT_TO_SYNCMGR_ON_REMOTE_MACHINE Line0001 = "与远程机器上的同步管理器失去连接。"
LOST_CONNECT_TO_SYNCMGR_ON_REMOTE_MACHINE Line0002 = "TestStand 将在该机器上使用同步的下一步执行时尝试重新连接。"
LOST_CONNECT_TO_SYNCMGR Line0001 = "失去与同步管理器的连接。"
LOST_CONNECT_TO_SYNCMGR Line0002 = "TestStand 将在使用同步的下一步执行时尝试重新连接。"
SYNCMGR_BITNESS_PREFIX_NOT_SUPPORTED = "您为同步对象指定了位数前缀。删除前缀以连接到同步管理器的默认位数。"
EXE_NOT_RESTARTABLE = "此执行不可重启。"
INVALID_OPERATION_ON_FILE = "对此类文件的操作无效。"
INVALID_OPERATION_ON_STANDALONE_MODULE = "操作对于不属于步骤的模块无效。"
IMAGE_TYPE_MUST_BE_ICON = "无效的图像类型。仅支持图标。"
IMAGECOLLECTION_NOT_FOUND = "找不到具有给定名称或索引 ('%1') 的图像"
INVALID_OPTIONAL_ARRAY_OF_IDISPATCH = "无效的可选参数。应为 IDispatch 指针的 SAFEARRAY。"
INVALID_OPTIONAL_ARRAY_OF_BSTR = "无效的可选参数。应为 BSTR 的 SAFEARRAY。"
INVALID_OPTIONAL_BOOLEAN = "无效的可选参数。应为布尔值。"
INVALID_OPTIONAL_NUMBER = "无效的可选参数。预期数量。"
INVALID_WORKSPACE_OBJ_TYPE = "无效的工作区对象类型：'%1'"
OPERATION_VALID_ONLY_ON_TYPES = "操作仅对类型有效。"
OPERATION_NOT_VALID_ON_ENUMS = "操作 '%1' 对枚举类型无效。"
ENUM_NOT_FLAGS = "操作 %1 对于非标志枚举无效。（%2 不是标志枚举。）"
ENUM_TYPE_MISMATCH = "预期类型 %1。找到类型 %2。"
ENUM_OUT_OF_RANGE = "值 '%1' 超出枚举 %2 的范围。"
ENUM_CAN_NOT_BE_VALID = "注意：没有定义枚举数。请使用编辑枚举数对话框添加枚举数。"
ENUM_NOT_VALID = "无效状态错误：枚举器 '%1' 对于类型 %2 无效。"
ENUM_INVALID_ENUMERATOR = "{无效} "
ENUM_NOT_ROOT_TYPE = "操作仅支持根类型定义。"
ENUM_EMPTY_STR_INVALID = "不允许空字符串枚举器。"
ENUM_NAME_INVALID_FOR_FLAGS = "名称 '%1' 对标志枚举器无效。标志枚举器名称只能包含字母、数字和下划线，并且不能以数字开头。"
INVALID_TYPE_LIST = "无效的类型列表说明符：'%1'"
STEP_MUTEX_ERROR = "在步骤上执行锁定操作时发生错误。"
STEP_BATCH_SYNC_ERROR = "在步骤上执行批处理同步时出错。"
DUP_STEP_NAME_WARNING Line0001 = "您选择的步骤与步骤组中的另一个步骤同名。"
DUP_STEP_NAME_WARNING Line0002 = "当步骤组中的步骤名称重复时，TestStand 会将名称解释为指的是第一步"
DUP_STEP_NAME_WARNING Line0003 = "用那个名字。"
DUP_STEP_NAME_WARNING_2 Line0001 = "您选择的步骤 '%1'与步骤组中的另一个步骤同名。"
DUP_STEP_NAME_WARNING_2 Line0002 = "当步骤组中的步骤具有重复名称时，TestStand 会将名称解释为引用第一步"
DUP_STEP_NAME_WARNING_2 Line0003 = "用那个名字。"
PROPERTY_NAME_NOT_IDENTIFIER = "名称 '%1' 不是有效名称。\n属性对象名称只能包含字母、数字和下划线，不能包含空格或以数字开头。"
PROPERTY_NAME_EMPTY = "属性对象名称无效，因为它是空的。"
PROPERTY_NAME_RESERVED = "名称 '%1' 已保留，不是有效的属性对象名称。"
TYPE_NAME_EMPTY = "类型名称无效，因为它是空的。"
TYPE_NAME_NOT_IDENTIFIER = "名称 '%1' 不是有效名称。\n类型名称只能包含字母、数字和下划线，不能包含空格或以数字开头。"
NO_TYPE_UPDATES_WHILE_EXECUTIONS_RUNNING = "序列执行时不能更新类型。"
TYPE_IS_UP_TO_DATE ="所选类型已经是最新的。未进行任何更改。"
CANNOT_BACKUP_FILE = "无法重命名文件\n \t'%1'\ninto\t'%2'\n\n备份失败"
CANNOT_MODIFY_ENGINE_REF_OBJ = "该引用必须始终引用当前引擎。"
ERROR_CREATING_TYPE = "创建类型对象时出错。\n"
INVALID_DATA_TYPE = "无法创建类型，因为一个或多个元素具有不受支持的数据类型。"

ERROR_FROM_CREATE_C_TYPE_FROM_CLUSTER_DIALOG_BOX = "从集群对话框创建/更新自定义数据类型时出错。请联系 National Instruments 以获得支持。"

UNEXPECTED_TOKEN_EXPR_ERR = "意外的令牌：%1"

REMOTE_PATH_MUST_BE_UNC_FOR_OPENING = "模块文件在远程机器上，路径未使用 UNC 指定。"

COULD_NOT_EXECUTE_SEQ_SPECIFIED_ON_CMDLINE = "无法按照命令行指定的方式对序列文件 '%2' 执行 '%1'。"
COULD_NOT_OPEN_FILES_SPECIFIED_ON_CMDLINE = "无法打开命令行指定的序列文件。"
VALUE_NOT_SUPPORTED_BY_OBSOLETE_PROPERTY = "内部值与您正在使用的过时属性不兼容。有关详细信息，请参阅 TestStand API 帮助文件。"
OPERATION_NOT_VALID_ON_RUNTIME_STEP = "该操作对运行时步骤无效。"

EXT_PROCESS_COMMUNICATION_FAILED = "无法注册/取消注册序列。重新启动应用程序并重试。"
SEQUNCE_CALLBACK_REG_ID_INVALID = "无效的序列回调注册 ID '%1'。"

NAMED_SEQUENCE_DOES_NOT_EXIST = "序列 '%1' 不存在。"
NAMED_SEQUENCE_DOES_NOT_EXIST_IN_FILE = "序列 '%1' 不存在于序列文件 '%2' 中。"
LOOKUP_STRING_CANNOT_BE_EMPTY = "此方法的 lookupString 参数不能为空。"
DOES_NOT_CONTAIN_IDISPATCH = "对象不包含 IDispatch 接口。"
RTE_ERROR_DESC = "'%3' 中序列 '%2' 的步骤 '%1'："
RTE_ERROR_DESC_LOCATION = "'%3' 中序列 '%2' 的步骤 '%1'"
SOCKET_RTE_ERROR_DESC_LOCATION = "测试插槽 %1。"
RTE_ERROR_DESC_REMOTE = ", 在远程计算机 '%1' 上"
RTE_NO_DETAILS_MSG = "没有可用的细节。"
CANT_LOAD_TYPES = "无法从 '%1' 加载类型。"
CANT_LOAD_TYPE_DUE_TO_UNKNOWN_TYPE_DESC = "（可能缺少步骤或步骤类型所需的适配器）"

UNKNOWN_GOTO_TARGET = "无法找到目标。步骤 '%1' 不在当前序列中。"
CANT_LOAD_CONV_DLL = "无法加载序列转换器 DLL '%1'。\nWin32 错误代码 = '%2'\n错误消息 = %3\n"
CANT_FIND_CONV_FUNC = "在序列转换器 DLL '%1' 中找不到所需的函数。"
CANT_LOAD_ADAPTER_DLL = "无法加载测试适配器 DLL '%1'。"
CANT_FIND_ADAPTER_FUNC = "在测试适配器 DLL '%1' 中找不到所需的函数。"
CANT_OPEN_CVI_PRJ = "无法在 CVI 中打开以下项目：\n%1"
CANT_BUILD_CVI_PRJ = "在项目的 CVI 中构建项目失败：\n%1"
CANT_RUN_CVI_PRJ = "无法在 CVI 中运行以下项目：\n%1"
CVI_CANT_SET_PRJ_CONFIG = "无法设置项目配置以匹配当前平台。"
CVI_CANT_SAVE_PRJ = "CVI 无法保存当前项目"
CVI_CANT_CREATE_OBJ = "CVI 无法创建目标文件：\n%1"
CVI_CANT_OPEN_SRC = "CVI 无法打开源文件：\n%1"
CVI_CANT_GEN_CODE = "CVI 无法生成源代码到源窗口"
CVI_CANT_SCROLL_TO_FUNC = "CVI 无法滚动到源窗口中的指定函数"
CVI_CANT_SET_PROJECT_TARGET_PATH = "CVI 无法将项目目标路径设置为：\n%1"
CVI_CANT_ADD_FILE_TO_PROJECT = "CVI 无法将以下文件添加到当前项目：\n%1"
CVI_CANT_LOAD_INSTRUMENT = "CVI 无法加载以下仪器文件：\n%1"
CVI_CANT_CONTINUE_USER_INPUT_PENDING = "TestStand 无法继续。CVI 正在等待用户对对话框的响应。"
RETURN_VALUE_ERROR = "返回值错误。"
; %1 为参数号，%2 为参数名
PARAMETER_ERROR = "参数 %1 错误，'%2'。"
EXPR_FUNC_ERROR_WITH_PARAM = "调用表达式函数 %3 时参数 %1、%2 出错。"
EXPR_ARRAY_LITERAL_ELEMENT_ERROR = "数组文字元素 %1、%2 出错。"
EXPR_FUNC_ERROR = "调用表达式函数 %3 时出错。"
TE_REPORT_ACCESS_DENIED_ELAB = "该文件可能在另一个应用程序中打开。如果文件访问间歇性被拒绝，您应该尝试禁用 Microsoft FindFast 实用程序。"
TE_UNKNOWN_FUNCTION_OR_SEQUENCE_NAME_DESC = "未知函数或序列名称'%1'。"
TE_UNKNOWN_VAR_OR_PROP_DESC = "未知变量或属性名称'%1'。"
CANNOT_SET_TOP_LEVEL_OBJECT = "无法将顶级属性对象设置为另一个对象。"
TE_UNRECOGNIZED_VALUE_DESC = "无法识别的值 '%1'。"
TE_INCOMPATIBLE_PARAMETERS_DESC = "预期 %1，通过 %2。"
TE_INCOMPATIBLE_PARAMETERS_DESC2 = "预期 %1 或 %2，超过 %3。"
TE_INCOMPATIBLE_PARAMETER_FOR_PASS_BY_POINTER = "对于此参数，只能'%1'类型的值'通过引用'传递。"
TE_INCOMPATIBLE_STRUCT_PARAMETERS_DESC = "预期类型 %1 的实例，已通过类型 %2 的实例。"
TE_INCOMPATIBLE_STRUCT_PARAMETERS_DESC2 = "类型为 %1 的预期实例，传递的对象没有类型。"
TE_CADAPTER_STRUCT_PASSING_DISABLED_DESC = "C 结构传递在类型 '%1' 中被禁用。"
TE_GADAPTER_CLUSTER_PASSING_DISABLED_DESC = "在类型 '%1' 中禁用了集群传递。"
TE_DOTNETADP_STRUCT_PASSING_DISABLED_DESC = ".NET 结构传递在类型 '%1' 中被禁用。"
TE_UNEXPECTED_TYPE_DESC = "预计 %1，找到 %2。"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0001 = "\n\n注意：数字表示必须完全匹配。\n\n使用以下内容在表达式中指定数字常量：\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0002 = "64 位浮点数：1234\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0003 = "带符号的 64 位整数：1234i64\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0004 = "无符号 64 位整数：1234ui64\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0005 = "\n使用以下表达式函数在表示之间进行转换：\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0006 = "转换为 64 位浮点数：Float64()\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0007 = "转换为带符号的 64 位整数：Int64()\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0008 = "转换为无符号 64 位整数：UInt64()\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0009 = "\n使用以下 API 函数获取或设置各种表示的值：\n（注意：您可以使用 PropOption_CoerceFromNumber 和 PropOption_CoerceToNumber 在表示之间进行强制转换。）\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0010 = "64 位浮点数：Get\\SetValNumber 或 Get\\SetValNumberByOffset\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0011 = "带符号的 64 位整数：Get\\SetValInteger64 或 Get\\SetValInteger64ByOffset\n"
TE_WRONG_NUMERIC_REPRESENTATION_ELAB Line0012 = "无符号 64 位整数：Get\\SetValUnsignedInteger64 或 Get\\SetValUnsignedInteger64ByOffset"
ERR_NAMED_IS_WRONG_TYPE = "\"%1\" 不是 %2。"
TE_VARIANT_OUT_UNEXPECTED_TYPE_DESC = "VARIANT 输出参数包含意外类型。应为 %1。"
TE_NAME_ALREADY_IN_USE = "项目名称 '%1' 无效，因为它已被使用。"
TYPE_NAME_EXISTS = "类型名称 '%1' 已经存在。"
TE_INDEX_OUT_OF_RANGE = "索引 %1 超出范围。"
TE_INDEX_OUT_OF_RANGE__RANGE_IS = "索引 %1 超出范围；范围是 %2..%3。"
ARRAY_OFFSET_OUT_OF_RANGE = "数组偏移 %1 超出范围；范围是 0..%2。"
ARRAY_OFFSET_EMPTY_ARRAY = "数组偏移 %1 超出范围；数组为空。"
TE_ITEM_ERROR = "访问项目 '%1' 时出错。"
TE_MISSING_TYPE_DESC = "找不到类型 '%1'。"
TE_TYPE_CONFLICT = "类型 '%1' 无效，因为它与该名称的现有类型冲突。为避免此错误消息，您应该在序列编辑器中打开类型冲突的文件，解决冲突并重新保存更新的文件。"
TE_TYPE_CONFLICT_ON_PASTE = "TestStand 无法将剪贴板中的对象粘贴到所选视图中，因为剪贴板包含与当前加载的类型冲突的类型。在尝试再次粘贴之前，您必须再次复制原始对象。"
TE_TYPE_MINIMUM_PRODUCT_VERSION_INVALID = "类型 '%1' 无效，因为它只能在 TestStand 版本 %2 或更高版本中加载。为避免出现此错误消息，您应该打开一个包含该类型早期版本的文件。"
TE_ENGINE_TYPE_CONFLICT = "加载 %1 时出错：类型 '%2' 与 %4 中当前加载的类型 '%3' 不同。为避免此错误消息，您应该在序列编辑器中打开文件并重新保存。"
TE_TYPE_CONFLICT_EXECUTIONS_RUNNING = "类型 '%1' 无效且无法转换，因为执行正在运行。为避免此错误消息，您应该等到所有执行都完成后再尝试打开文件。"
TE_OBJECT_CANNOT_BE_ADDED = "属性对象 '%1' 不能是类型 '%2' 的子属性，因为它包含该类型的实例。"
TE_NO_SUBPROPERTIES_IN_NONCONTAINERS = "你不能在不是容器的项目中创建子属性。"
TE_READ_OBJECT_NOT_FOUND_DESC = "无法读取对象：在部分 '%2' 中找不到项目名称 '%1'。"
TE_LABVIEW_TYPE_NOT_SUPPORTED_IN_CVI_DESC = "CVI 不支持 '%1' 的 LabVIEW 类型"
TE_STEP_CONVERSION_ERROR = "序列 '%3' 中类型 '%2' 的步骤 '%1' 无法从早期版本转换。"

TE_CANT_READ_TS_FILE_ELAB = "无法加载 %1 '%2'。"

STD_TYPE_DEFINITION_ALREADY_USED = "标准类型定义'%1'已经存在。"
CANT_CREATE_NEW_STD_TYPE_DEFINITION = "无法创建新的标准类型定义 '%1'。"
TE_ERROR_PROCESSING_PARAMETER_WITH_CALL = "参数 '%1' 和参数表达式 '%2' 调用成员 '%3' 时发生以下错误："
TE_NULL_INSTANCE_FOR_MEMBER_FUNC_CALL = "正在尝试调用对象引用设置为 Nothing 的实例成员 '%1'。"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER_WITH_CALL_NO_TYPES = "参数表达式 '%1' 的类型与调用成员 '%3' 时的参数 '%2' 不兼容。"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER_WITH_CALL = "参数表达式 '%1' 的类型与调用成员 '%3' 时的参数 '%2' 不兼容。需要 %4，找到 %5"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER_NO_NAME_NO_TYPES = "参数表达式 '%1' 的类型与参数不兼容。"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER_NO_NAME = "参数表达式 '%1' 的类型与参数不兼容。需要 %2，找到 %3。"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER_NO_TYPES = "参数表达式 '%1' 的类型与参数 '%2' 不兼容。%3"
TE_EXPR_TYPE_INCOMPATIBLE_WITH_PARAMETER = "参数表达式 '%1' 的类型与参数 '%2' 不兼容。需要 %3，找到 %4"
TE_OBJECT_TYPE_INCOMPATIBLE_WITH_PARAMETER_SHORT_DESC = "参数类型与参数 '%1' 不兼容。%2"
LOCAL_VARIABLE_PROPAGATION_TYPE_MISMATCH_ERROR_DESC = "局部变量 %1 无法从调用序列传播，因为它的类型与它将替换的局部变量的类型不匹配。"
OBJ_CONVERTED_TO_ACTIVEX_REF_FOR_REMOTE_CALL Line0001 = "注意：属性容器在作为参数传递给远程序列时会转换为 Active X 引用。"
TE_WRONG_NUMBER_OF_PARAMETERS_DESC = "需要 %1 个参数，找到 %2。"
TE_TYPE_MISMATCH_ERROR_DESC = "应为 %1，已找到 %2。"
TE_TYPE_MISMATCH_ERROR_DESC2 = "应为 %1，发现类型为 %3 的 %2。"
TE_SINGLE_DIM_NUMERIC_ARRAY_EXPECTED_DESC = "预期的一维数值数组，找到 %1。"
TE_TWO_DIM_NUMERIC_ARRAY_EXPECTED_DESC = "预期的二维数字数组，找到 %1。"
TE_LVALUE_EXPECTED_DESC = "期望单个值或属性，找到 %1"
TE_BAD_EXPRESSION_ELAB = "表达式 '%1' 出错。"
TE_BAD_FILE_FORMAT_ELAB = "文件格式错误。文件 '%1' 不是 %2。"
TE_OUT_OF_DATE_FILE_FORMAT_ELAB = "不再支持 '%1' 中的文件格式。"
TE_NEWER_FILE_FORMAT_ELAB = "文件 '%1' 保存在 TestStand %2 中，无法加载。"
TE_INCOMPATIBLE_NEWER_FILE_VERSION_ELAB = "文件 '%1' 保存在 TestStand %2 中，与 TestStand %3 不兼容。"
TE_UNABLE_TO_CHANGE_SEQ_FILE_PATH_ALREADY_LOADED = "无法将序列文件路径设置为 '%1'，因为具有该路径的序列文件已经加载。"
TE_UNABLE_TO_SAVE_SEQ_FILE_WITH_PATH_ALREADY_LOADED = "无法将序列文件保存为 '%1'，因为具有该路径的序列文件已经加载。"
TE_UNABLE_TO_DISCARD_SEQ_FILE_IN_USE = "无法丢弃序列文件 '%1'，因为它正在使用中，可能是因为它正在执行。"
TE_UNABLE_TO_UNLOAD_SEQ_FILE_IN_USE = "无法卸载序列文件 '%1'，因为它正在使用中，可能是因为它正在执行。"
TE_UNABLE_TO_SAVE_SEQ_FILE = "无法保存序列文件。"
TE_SEQ_FILE_PATH_NOT_ABSOLUTE = "无法保存序列文件 '%1'，因为路径不是绝对路径。"
TE_UNABLE_TO_LOAD_SEQ_FILE_RUNNING_UNLOAD_CALLBACK = "无法加载序列文件 '%1'。\n当前正在执行序列文件的卸载回调。"
TE_UNABLE_TO_SET_SEQ_FILE_PATH_TO_EMPTY = "无法将序列文件 '%1' 的路径更改为空路径。"
TE_STEP_LOAD_FAILED_DESC = "在文件 '%3' 中加载序列 '%2' 的步骤 '%1' 时出错。\n"
PRELOAD_MODULE_ERROR_IN_OTHER_SEQUENCE Line0001 = "注意：虽然这一步不在主序列中，但它在同一个文件中，它的\n"
PRELOAD_MODULE_ERROR_IN_OTHER_SEQUENCE Line0002 = "模块加载选项设置为'执行开始时预加载'。为了避免这个错误\n"
PRELOAD_MODULE_ERROR_IN_OTHER_SEQUENCE Line0003 = "未来，将步骤或序列文件模块加载选项更改为'动态加载'。"

PRECONDITION_ERROR_DESC = "无法评估步骤 '%1' 的先决条件。\n"
STATUS_EXPR_ERROR_DESC = "无法评估步骤 '%1' 的状态表达式。\n"
PRE_EXPR_ERROR_DESC = "无法评估步骤 '%1' 的前置表达式。\n"
POST_EXPR_ERROR_DESC = "无法计算步骤 '%1' 的后置表达式。\n"
DESC_EXPR_ERROR_DESC = "无法评估步骤 '%1' 的步骤类型描述表达式。\n"
LOOP_WHILE_ERROR_DESC = "无法计算步骤 '%1' 的循环 while 表达式。\n"
LOOP_STATUS_ERROR_DESC = "无法评估步骤 '%1' 的循环完成状态表达式。\n"
LOOP_INCREMENT_ERROR_DESC = "无法评估步骤 '%1' 的循环增量表达式。\n"
LOOP_INITIALIZE_ERROR_DESC = "无法计算步骤 '%1' 的循环初始化表达式。\n"
CUSTOM_POSTACTION_EXPRESSION_ERROR_DESC = "无法评估步骤 '%1' 的自定义后操作表达式。\n"
POSTACTION_TARGET_EXPRESSION_ERROR_DESC = "无法评估步骤 '%1' 的后操作目标表达式。\n"
ENTRY_NAME_EXPRESSION_ERROR_DESC = "无法计算序列 '%1' 的条目名称表达式。\n"
ENTRY_ENABLED_EXPRESSION_ERROR_DESC = "无法计算序列 '%1' 的条目启用表达式。\n"
TE_DISP_UNKNOWN_MEMBER_DISPID_DESC = "未知成员 ID [%1]。"
TE_DISP_OBSOLETE_MEMBER_DESC = "已过时的成员 '%1'。"
TE_DISP_MISSING_PARAM_NAME_DESC = "未传递预期的命名参数 '%1'。"
TE_DISP_WRONG_NUM_POSITIONAL_PARAMS_DESC = "需要 %1 个位置（未命名）参数；找到 %2。"
SWITCH_EXEC_NOT_INSTALLED = "您必须安装 %1 位 National Instruments Switch Executive 软件才能启用此选项卡。如果安装了 Switch Executive，请验证位数是否正确。"
SWITCH_EXEC_NOT_INSTALLED_RUN_ERROR = "您必须安装 %1 位 National Instruments Switch Executive 才能执行此开关操作。如果安装了 Switch Executive，请验证位数是否正确。"
NIMAX_NOT_INSTALLED = "此计算机上未安装 National Instruments 测量和自动化软件。"
STEP_SWITCH_ERROR = "在步骤上执行开关操作时发生错误。"
SWITCH_EXEC_UNEXPECTED_EXEPTION = "为以下设备 '%2' 执行切换操作 '%1' 时发生错误。"
SWITCH_EXEC_SEMANAGER_ERROR = "打开设备会话的调用失败。"
SWITCH_EXEC_SESSIONMANAGER_ERROR = "尝试创建会话管理器实例时发生错误。"
SWITCH_EXEC_OPERATION_ERROR = "无法执行切换操作："
SWITCH_EXEC_OPERATION_DISCONNECT = "步骤执行后断开连接时出现意外异常。"
SWITCH_EXEC_LIFETIME_MANUAL_REQUIRED = "使用 SwitchConnect 表达式函数时，如果调用 Evaluate 的 PropertyObject 不是 SequenceContext 对象，则必须指定手动生命周期设置。"
VIRTUAL_DEVICE_EXPRESSION_ERROR_DESC = "无法评估步骤 '%1' 的虚拟设备表达式。\n"
CONNECT_ROUTE_GROUP_EXPRESSION_ERROR_DESC = "无法评估步骤 '%1' 的连接路由组表达式。\n"
DISCONNECT_ROUTE_GROUP_EXPRESSION_ERROR_DESC = "无法评估步骤 '%1' 的断开路由组表达式。\n"
SWITCH_EXEC_FINDROUTE_FAILED = "通道 '%1' 和通道 '%2' 之间的路由不可用。"

BAD_POST_ACTION_ELAB = "值 '%1' 不是可识别的后操作选项。"
SUBSTEP_RTE_ELAB = "执行子步骤 '%1' 时出错。"
POSTACTION_RTE_ELAB = "执行步骤后操作时出错。"
CANT_REPORT_RTE_MSG = "发生错误，阻止报告序列的错误状态。"

CANT_OPEN_RESERVED_SEQFILE_CALLBACK_TEMPLATE_FILE Line0001 = "无法打开保留的序列文件回调模板文件'%1'。\n"
CANT_OPEN_RESERVED_SEQFILE_CALLBACK_TEMPLATE_FILE Line0002 = "如果模板文件包含类型冲突，请在序列编辑器中打开它以协调冲突。"
CALLBACK_CANNOT_BE_DELETED = "这个回调序列设置了 NotDeletable 标志。它不能被删除。"

CANT_OPEN_SEQFILE_MODEL_FILE Line0001 = "无法打开序列文件的模型文件 '%1'。\n"
CANT_OPEN_SEQFILE_MODEL_FILE Line0002 = "如果模型文件包含类型冲突，请在序列编辑器中打开它以协调冲突。"

CANT_LOAD_ENTRY_POINTS = "无法加载序列文件的模型入口点。\n"

CANT_EXECUTE_MODEL_ENTRY_POINT_NO_MODEL_FILE = "无法在序列文件 '%2' 上执行入口点 '%1'。没有适用的模型文件。"
CANT_EXECUTE_MODEL_ENTRY_POINT_DOES_NOT_EXIST = "无法在序列文件 '%2' 上执行入口点 '%1'。模型文件中没有这样的入口点。"


EXEC_SEQUENCE_FAILED_MSG = "无法执行文件 '%2' 中的序列 '%1'。\n\n"
EXEC_INTERACTIVE_FAILED_MSG = "无法开始交互式执行。\n\n"
EXEC_ENTRY_POINT_FAILED_MSG = "无法执行模型入口点 '%1'。\n\n"

UNABLE_TO_RUN_FRONT_END_CALLBACK = "无法运行前端回调 '%1'\n"
FRONT_END_CALLBACK_FAILED = "运行前端回调 '%1' 时发生错误\n"

UNABLE_TO_RUN_LOAD_CALLBACK = "无法运行加载回调 '%1'\n"

ARRAY_TOO_BIG = "超出最大数组大小。数组不能包含超过 %1 个元素。最好将元素的实际数量保持得低得多，以避免耗尽虚拟内存。"


MISSING_REQUIRED_INI_ITEM = "无法继续阅读 - 部分 '%2' 中缺少项目 '%1'。"

MISMATCHED_ARRAY_BOUNDS = "不匹配的数组边界：下限 %1；上限 %2。"

FAILED_TO_LAUNCH_EXTERNAL_FILE_VIEWER = "无法启动文件 '%1' 的外部查看器。"
FAILED_RUNNING_SEQFILE_LOAD_CALLBACK = "序列文件的运行加载回调失败：'%1'\n"
FAILED_RUNNING_SEQFILE_UNLOAD_CALLBACK = "无法运行序列文件的卸载回调：'%1'\n"

TE_INVALID_USER_OBJECT = "用户列表中名为 '%1' 的属性对象不是用户对象。"
TE_INVALID_USER_TEMPLATE_OBJECT = "用户组列表中名为 '%1' 的属性对象不是用户对象。"

UNABLE_TO_SET_DEFAULT_ADAPTER = "无法将默认适配器设置为 '%1'。"
STEP_TYPE_NOT_FOUND = "在类型列表中找不到步骤类型 '%1'。"
INVALID_ADAPTER_NAME = "无效的适配器名称：'%1'。"
UNABLE_TO_GET_ADAPTER_NAME = "无法获取适配器编号的名称：'%1'。"
UNABLE_TO_GET_ADAPTER = "无法获取适配器编号的适配器：'%1'。"

UNABLE_TO_GET_SEQUENCE_INDEX = "无法从序列文件中获取序列 '%1'：'%2'"
UNABLE_TO_REMOVE_SEQUENCE_INDEX = "无法从序列文件中删除序列 '%1'：'%2'"
UNABLE_TO_DELETE_SEQUENCE_INDEX = "无法从序列文件中删除序列 '%1'：'%2'"
UNABLE_TO_RENAME_SEQUENCE_INDEX = "无法从序列文件重命名序列 '%1'：'%2'"
INVALID_WHICH_STEPS = "无效的执行阶段：'%1'"
INVALID_STEP_INDEX = "序列 '%3' 中 '%2' 阶段的步骤索引 '%1' 无效。"
STEP_NAME_DOES_NOT_EXIST = "步骤 '%1' 不存在于序列 '%3' 的 '%2' 阶段。"
INVALID_LOAD_OPTION = "无效的模块加载选项：'%1'"
INVALID_UNLOAD_OPTION = "无效的模块卸载选项：'%1'"
INVALID_MODEL_OPTION = "无效的模型选项：'%1'"
INVALID_SEQFILE_TYPE = "无效的序列文件类型：'%1'"
INVALID_STEP_TYPE_CATEGORY = "无效的步骤类型类别：'%1'"
STEP_TYPE_CATEGORY_DOES_NOT_EXIST = "类别属性在步骤类型中不存在。"
STEP_NAME_EMPTY = "步骤名称无效，因为它是空的。"
STEP_NAME_RESERVED = "步骤名称 '%1' 已保留。"
STEP_NAME_CONTAIN_SPECIAL_CHAR = "步骤名称 '%1' 包含一个或多个无效字符。步骤名称不能包含控制字符。"
SEQUENCE_NAME_EMPTY = "序列名称无效，因为它是空的。"
SEQUENCE_NAME_RESERVED = "序列名称 '%1' 已保留。"
SEQUENCE_NAME_EXISTS = "序列名称 '%1' 已存在于文件 '%2' 中。"
SEQUENCE_NAME_CONTAIN_SPECIAL_CHAR = "序列名称 '%1' 包含一个或多个无效字符。序列名称不能包含控制字符。"
SUBSTEP_NAME_DOES_NOT_EXIST = "子步骤 '%1' 不存在。"
SUBSTEP_INDEX_DOES_NOT_EXIST = "索引 %1 处没有子步骤。"
SEQUENCE_NOT_IN_FILE = "对不属于序列文件的序列的操作无效。"
NULL_DISP_PTR = "意外的 NULL 调度指针。"
INVALID_THREAD_INDEX = "指定的线程索引 '%1' 无效。"
INVALID_REPORT_INDEX = "指定的报告索引：'%1' 无效。索引必须介于 0 和 %2 之间。"
INVALID_REPORTSECTIONS_INDEX = "指定的报告部分索引：'%1' 无效。索引必须在 %2 和 %3 之间。"
CANNOT_INSERT_UNNAMED_TYPE = "类型名称不能为空。"
INVALID_TYPELIST_INDEX = "指定的类型使用列表索引 '%1' 无效。索引必须介于 0 和 %2 之间"
INVALID_PROPERTY_INDEX = "指定的属性索引 '%1' 无效。索引必须介于 0 和 %2 之间"
SUBSCRIPT_EXPR_ERR = "评估下标表达式时出错。"
SUBSCRIPTING_NON_ARRAY_ERR = "下标对于不是数组的对象无效。无法应用下标 '%1'。"
INVALID_SUBSTEP_TYPE = "无效的子步骤类型：'%1'"
INVALID_SUBSTEP = "索引 '%1' 处的子步骤不是有效的子步骤。"
UNABLE_TO_SWAP_SUBSTEPS = "交换子步骤失败。不兼容的类型：index1 ('%1'), index2: ('%2')"
UNEXPECTED_TYPE_ERR = "找到 '%1'，应为 '%2'。"
DEFAULT_MODULE_IS_SHARED Line0001 = "步骤类型 %1 在默认模块属性 'TS.SData' 上设置了 PropFlags_Shared 标志。TestStand 无法加载与其步骤类型共享默认模块的步骤。"
DEFAULT_MODULE_IS_SHARED Line0002 = "NI 建议使用后子步骤而不是尝试共享步骤类型的默认模块。"
INVALID_ARRAY_DIMENSIONS = "数组的维数无效。维数必须大于零。"

UNABLE_TO_CREATE_cALLBACK = "无法创建默认回调。无效的回调名称：'%1'。该名称不对应于有效的回调"

MUST_ENABLE_ALLOW_OTHER_MODELS_OR_TESTSTAND_MODEL Line0001 = "要加载序列文件，您必须：\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_TESTSTAND_MODEL Line0002 = "- 在 Station Options 对话框中启用 Allow Other Models 选项，或者\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_TESTSTAND_MODEL Line0003 = "- 在站点选项对话框中启用使用站点模型选项。"

MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL Line0001 = "当前站模型是'%1'\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL Line0002 = "文件 '%2' 需要模型 '%3'\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL Line0003 = "要加载序列文件，您必须：\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL Line0004 = "- 在 Station Options 对话框中启用 Allow Other Models 选项，或者\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL Line0005 = "- 在站点选项对话框中将站点模型更改为'%4'。"

MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL_AND_USE_TESTSTAND_MODEL Line0001 = "当前站模型是'%1'\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL_AND_USE_TESTSTAND_MODEL Line0002 = "文件 '%2' 需要模型 '%3'\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL_AND_USE_TESTSTAND_MODEL Line0003 = "要加载序列文件，您必须：\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL_AND_USE_TESTSTAND_MODEL Line0004 = "- 在 Station Options 对话框中启用 Allow Other Models 选项，或者\n"
MUST_ENABLE_ALLOW_OTHER_MODELS_OR_CHANGE_TESTSTAND_MODEL_AND_USE_TESTSTAND_MODEL Line0005 = "- 将站点模型更改为'%4'并在站点选项对话框中启用使用站点模型选项。"

CANT_COPY_OBJECT_DESCR = "'%1' 类型的属性对象不能作为非引用参数复制或传递"

COULD_NOT_ADD_TYPE_TO_MYTYPES = "TestStand 无法将类型 '%1' 添加到 MyTypes.ini，因为 MyTypes.ini 未加载。"

UNSAVED_SEQFILE_NOT_IN_CACHE = "无法加载未保存的序列文件 %1。"
UNSAVED_SEQFILE_NAME_NOT_IN_CACHE = "无法加载未保存的序列文件 '%1'。"

SEQFILE_OPERATION_FAILED_NO_ENGINE = "对序列文件 '%1' 的操作失败。\nTestStand 引擎不再可用。"
SEQFILE_OPERATION_FAILED_NOT_IN_CACHE = "序列文件 '%1' 的操作失败。\n文件已从 TestStand 引擎卸载。"

OPERATION_FAILED_ENGINE_SHUTDOWN = "操作失败，因为 TestStand 引擎已关闭。"

TE_REMOTE_SEQUENCE_BITNESS_PREFIX_NOT_SUPPORTED = "您在主机名中指定了位数前缀。删除前缀以连接到主机上远程引擎的默认位数。"
TE_REMOTE_SEQUENCE_ERROR_WONG_BITNESS = "您在主机名中使用了位数前缀 '%1'，但远程机器上不存在该位数版本的 TestStand。"
TE_REMOTE_PERMISSION_DENIED_DESC = "出现权限错误。您必须在此机器上安装 TestStand 并通过站点选项配置它以允许访问。"
TE_REMOTE_SEQUENCE_ERROR_UNABLE_TO_CONNECT_DESC Line0001 = "在主机 '%1' 上访问远程 TestStand 引擎时发生错误。\n"
TE_REMOTE_SEQUENCE_ERROR_UNABLE_TO_CONNECT_DESC Line0002 = "* 验证远程主机的名称和位数前缀（如果存在）是否正确。\n"
TE_REMOTE_SEQUENCE_ERROR_UNABLE_TO_CONNECT_DESC Line0003 = "* 您必须在远程主机上安装 TestStand 并通过 dcomcnfg 配置 REngine.exe 程序以允许访问。\n"
TE_REMOTE_SEQUENCE_ERROR_UNABLE_TO_CONNECT_DESC Line0004 = "* CoCreateInstance 返回 '%2': %3"
TE_REMOTE_SEQUENCE_REMOTE_EXECUTION_DENIED_DESC = "在主机 '%1' 上远程执行期间发生权限错误。您必须在远程主机上安装 TestStand 并通过站点选项配置它以允许访问。"
REMOTE_CANT_FIND_FILE = "在主机 '%2' 上找不到文件 '%1'。"
TE_REMOTE_HOST_NOT_SPECIFIED = "试图加载远程主机名为空的步骤的模块。"
RENGINE_SET_LAUNCH_PERM_ERROR = "无法设置 REngine 启动权限：%1"
RENGINE_GET_LAUNCH_PERM_ERROR = "无法获得 REngine 启动权限：%1"
RENGINE_CONFIG_LAUNCH_FAILED Line0001 = "无法启动 ConfigREngine 进程来设置远程引擎 DCOM 设置。\n"
RENGINE_CONFIG_LAUNCH_FAILED Line0002 = "尝试以管理员身份运行 TestStand 应用程序。"
RENGINE_CONFIG_FAILED Line0001 = "ConfigREngine 进程设置远程引擎 DCOM 设置失败。\n"
RENGINE_CONFIG_FAILED Line0002 = "尝试以管理员身份运行 TestStand 应用程序。"
DCOM_AUTH_FAILURE Line0001 = "DCOM 授权失败。确保客户端和服务器机器都配置为 "
DCOM_AUTH_FAILURE Line0002 = "允许使用位于 Windows 系统目录（NT 上的 system32）中的 dcomcnfg.exe 相互访问。"
ACCESS_DENIED_RTE_IN_REMOTE_SEQ Line0001 = "\n如果远程序列试图从这台机器访问一个对象，就会发生这个错误。"
ACCESS_DENIED_RTE_IN_REMOTE_SEQ Line0002 = "确保客户端和服务器机器都配置为允许使用位于 Windows 系统目录（NT 上的 system32）中的 dcomcnfg.exe 相互访问。"
ACCESS_DENIED_RTE_IN_REMOTE_SEQ_IN_OI Line0001 = "\n对于操作员界面，您可以通过添加来授予访问权限"
ACCESS_DENIED_RTE_IN_REMOTE_SEQ_IN_OI Line0002 = "注册表项。请参阅 NI TestStand 帮助"
" ACCESS_DENIED_RTE_IN_REMOTE_SEQ_IN_OI Line0003 = "有关将 TestStand 设置为远程服务器的更多信息。
ACCESS_DENIED_RTE_IN_REMOTE_SEQ_IN_OI Line0004 = "了解更多信息。"
RTE_IN_REMOTE_SEQ = "以下运行时错误发生在远程序列调用中：\n\n"
TE_REMOTE_FAILED_TO_DISPLAY_MESSAGE_DESC Line0001 = "试图在客户端主机上显示消息，但失败了。\n确保客户端"
TE_REMOTE_FAILED_TO_DISPLAY_MESSAGE_DESC Line0002 = " 并且服务器机器被配置为允许使用 dcomcnfg.exe 访问彼此"
TE_REMOTE_FAILED_TO_DISPLAY_MESSAGE_DESC Line0003 = " Windows 系统目录（NT 上的 system32）。\n\n失败的消息如下：\n%1"
EXTRA_ARG_NAME_CONFLICTS_WITH_PARAMETER = "序列的参数数量 (%1) 大于参数数量 (%2)。无法传递额外的参数 '%3'，因为存在同名参数。"

MISSING_REQUIRED_PARAMETER = "需要参数 '%1'，它的值不能为空。"

INVALID_VERSION_STRING = "字符串 '%1' 不代表有效版本。"
CANNOT_CHANGE_VERSION_OF_NI_TYPE = "非法尝试更改 NI 安装类型的版本。"

ASSIGNING_TYPE_DEFINITION_TO_SELF = "非法尝试将类型定义 '%1' 分配给自身。"
WORKSPACE_NAME_EMPTY = "名称不能为空"

INVALID_SCC_OPERATION_ERROR = "无效的源代码控制操作：%1。"
SCC_PLUG_IN_EXCEPTION = "您的源代码控制插件导致异常或报告致命错误。\n检查安装"
INSERTING_NON_PROJECT_FILE_INTO_WORKSPACE_FILE = "正在尝试将非项目文件插入工作区。\n只能将项目添加到工作区文件。"
INSERTING_INTO_NON_CONTAINER = "试图将文件插入非容器。\n文件只能插入容器。"
INSERTING_WORKSPACE_FILE_INTO_CONTAINER = "正在尝试将工作区文件插入容器。\n工作区文件必须始终是根文件。"
INSERTING_PROJECT_INTO_NON_WORKSPACE_FILE = "正在尝试将项目文件插入到非工作区文件中。\n项目文件只能插入到工作区文件中。"
SEQ_FILE_EXECUTING = "正在执行序列文件"

CANT_LOAD_NI_STATION_CALLBACKS = "无法加载 NI 站回调文件 '%1'。"
CANT_LOAD_USER_STATION_CALLBACKS = "无法加载用户工作站回调文件 '%1'。"

PROTECTED_OBJECT_IS_LOCKED = "文件或对象被锁定时无法更新设置。"
INCORRECT_UNLOCK_PASSWORD = "指定用于解锁对象或文件的密码不正确。"
MAX_UNLOCK_ATTEMPTS = "您已达到解锁此对象或文件所允许的最大失败次数。"
OBJECT_CANNOT_BE_PROTECTED = "无法保护、锁定或解锁文件或对象。"
OBJECT_ALREADY_UNLOCKED = "文件或对象已经解锁，密码不正确。"
OBJECT_ALREADY_LOCKED = "文件或对象已被锁定且密码不正确。"
PROTECTION_NOT_ENABLED = "禁用保护时无法锁定文件或对象。"
OBJECT_LOCKED_FOR_LOOKUP_STRING = "查找字符串 %1 引用了一个被锁定的受保护对象。"
UNLOCK_PASSWORD_REQUIRED = "显示解锁对话框需要密码参数。"
LOCK_UNLOCK_NO_OPERATION = "你必须指定是执行锁定还是解锁操作。"
LOCK_UNLOCK_NO_LOCK_SUPPORT = "你必须传递一个可以被保护的对象类型。"
LOCK_UNLOCK_NON_PROTECTED_FILE = "如果对象的保护设置已启用，您只能锁定或解锁对象。"

WRITE_FILE_BAD_FORMAT = "传递给 WriteFile 的格式版本错误；值为：%1。"
WRITE_FILE_UNSUPPORTED_VERSION = "注意：不支持保存为早于 TestStand 4.0 的版本。"
CANT_GET_TYPE_PALETTE_FILES_NOT_LOADED = "无法获取类型选项板文件列表；必须先加载它们。"
CONVERT_TYPE_PALETTE_FILES_NOT_FOUND = "找不到所选版本的兼容类型调色板文件。"
INVALID_WRITE_FILE_FORMAT = "无效的 WriteFile_Format 值 %1。"

SCC_UPDATE_STATUS_ERROR = "\n\n无法更新一个或多个文件的源代码控制状态。\n"
SCC_CHECKOUT_ERROR = "\n\n无法检出一个或多个文件。\n"
SCC_UNDO_CHECKOUT_ERROR = "\n\n无法取消签出一个或多个文件。\n"
SCC_CHECKIN_ERROR = "\n\n无法签入一个或多个文件。\n"
SCC_ADD_TO_SCC_ERROR = "\n\n无法将一个或多个文件添加到源代码管理提供程序。\n如果问题仍然存在，请重新打开工作区。\n"
SCC_REMOVE_FROM_SCC_ERROR = "\n\n无法从源代码控制提供程序中删除一个或多个文件。\n"
SCC_GET_LATEST_ERROR = "\n\n无法获取一个或多个文件的最新版本。\n"
SCC_HISTORY_ERROR = "\n\n无法获取文件 '%1' 的历史记录。\n"
SCC_DIFFERENCES_ERROR = "\n\n无法显示文件 '%1' 的差异。\n"
SCC_PROPERTIES_ERROR = "\n\n无法从源代码控制提供程序获取文件 '%1' 的属性。\n"
SCC_SEE_MESSAGES_WINDOW = "查看您的消息以了解源代码控制提供程序返回的任何错误。\n"
SCC_FILES_UNDER_FILE_NOT_FOUND = "未找到文件 '%1' 下的以下文件：\n\n"
SCC_FILES_UNDER_PROJECT_NOT_FOUND = "未找到项目 '%1' 下的以下文件：\n\n"
SCC_PROJECTS_UNDER_WORKSPACE_NOT_FOUND = "未找到以下项目：\n\n"
SCC_SEQ_FILES_EXECUTING = "以下序列文件正在执行\n并且不允许对它们进行源代码控制操作：\n\n"

AUTOMATION_CALL_UNABLE_TO_CREATE_DISPATCH = "在自动化调用中\"创建新对象\"失败。"
AUTOMATION_CALL_UNABLE_TO_GET_DISPATCH_FROM_FILE = "\"从文件创建对象\" 自动化调用失败。"
AUTOMATION_CALL_UNABLE_TO_GET_EXISTING_DISPATCH = "自动化调用中的\"附加到活动对象\"失败。"

OPTION_NOT_SUPPORTED_BY_METHOD = "'%2' 方法不支持 '%1' 选项。"

TE_PROPERTY_HAS_PARENT = "无法将名为 '%1' 的项目添加到对象 '%2'，因为它已有一个父对象。您必须首先克隆该项目或将其从其父对象中删除。"

HELP_NOT_FOUND_TITLE = "帮助不可用"
HELP_NOT_FOUND_DESC = "未找到有关此主题的帮助。请安装 TestStand 帮助以显示此帮助主题。"
HELP_NOT_FOUND_DBG_DESC = "未找到有关此主题 (%1) 的帮助。请安装 TestStand 帮助以显示此帮助主题。如果安装了帮助，请报告该主题未显示。"


NO_WATCHEXPRESSION_VALUE = "监视表达式没有值。表达式尚未被评估或无效。"
WATCHPOINT_NOT_FOUND_IN_LIST = "在 TestStand 引擎的观察点列表中找不到作为参数传递的观察点。"

INVALID_NEXT_STEP_INDEX_FOR INTERACTIVE_EXECUTION = "RunState.NextStepIndex 属性在交互式执行中指定了一个未选择的步骤。"

SEARCH_DIRECTORY_INVALID_TYPE = "无效的搜索目录类型：'%1'"
SEARCH_DIRECTORY_INVALID_INDEX = "无效索引，指定索引处没有搜索目录：'%1'"
SEARCH_DIRECTORY_INVALID_PATH = "无效的搜索目录路径：'%1'"
SEARCH_DIRECTORY_NOT_EXPLICIT_DIR = "无法修改预定义搜索目录的路径。"
SEARCH_DIRECTORY_INVALID_FILEEXTREST = "无效的文件扩展名限制：'%1'"

OUTPUT_MESSAGE_INVALID_INDEX = "无效索引，无法根据提供的索引获取输出消息：'%1'"


UNABLE_TO_DELETE_PREDEFINED_SEARCH_DIR Line0001= "无法删除预定义的搜索目录。\n"
UNABLE_TO_DELETE_PREDEFINED_SEARCH_DIR Line0002= "传递给函数的索引必须对应于用户定义的搜索目录。"

TIME_LIMIT_INVALID_ACTION_VALUE = "无效的时间限制操作：'%1'"
TIME_LIMIT_INVALID_TYPE_VALUE = "无效的时间限制类型：'%1'"
TIME_LIMIT_INVALID_OPERATION_VALUE = "无效的时间限制操作：'%1'"
TIME_LIMIT_INVALID_ACTION _NAME = "无效的时间限制操作：'%1'"

TIME_LIMIT_INVALID_ACTION_EXIT Line0001 ="如果时间限制本身是无法将'终止执行'设置为时间限制操作\n"
TIME_LIMIT_INVALID_ACTION_EXIT Line0002 = "与终止执行或退出进程有关。\n"

TIME_LIMIT_INVALID_ACTION_ABORT_TERMINATE Line0001 = "如果时间限制本身是，则无法将'终止执行'设置为时间限制操作\n"
TIME_LIMIT_INVALID_ACTION_ABORT_TERMINATE Line0002 = "与中止执行或退出进程有关。"

TIME_LIMIT_INVALID_ACTION_ABORT_ABORT Line0001 = "如果时间限制本身是，则无法将'中止执行'设置为时间限制操作\n"
TIME_LIMIT_INVALID_ACTION_ABORT_ABORT Line0002 = "与中止执行或退出进程有关。"


USER_FILE_INVALID_PATH = "无效的用户文件路径：'%1'"

SURROUNDED_BY_QUOTES_EXPECTED = "如果使用 'SurroundedByQuotes' 转义选项，要转义的字符串必须用引号括起来。"

INVALID_ADAPTER_SEQUENCE_EXPECTED = "适配器不是序列适配器，无法访问此属性"
INVALID_ADAPTER_AUTOMATION_EXPECTED = "适配器不是 ActiveX/COM 适配器，无法访问此属性"
INVALID_ADAPTER_DLL_EXPECTED = "适配器不是 DLL 适配器，无法访问此属性"
INVALID_ADAPTER_HTBASIC_EXPECTED = "该适配器不是 HTBasic 适配器，无法访问此属性"
INAVALID_ADAPTER_CDERIVED_EXPECTED = "适配器类型错误，无法访问此属性"
INVALID_PACKING_VALUE = "无效的包装选项：'%1'"
INVALID_HTBASIC_WORKING_DIR = "无效的工作目录类型：'%1'"
INVALID_ADAPTER_PATH = "无效路径：'%1'"
INVALID_ADAPTER_LABVIEW_EXPECTED = "该适配器不是 LabVIEW 适配器，无法访问此属性"
INVALID_ADAPTER_CVI_EXPECTED = "该适配器不是 CVI 适配器，无法访问此属性"
FLEX_G_SERVER_INVALID_INDEX = "无效索引，指定索引处没有有效的 LabVIEW 服务器：'%1'"

EXT_VIEWER_INVALID_PATH = "无效的外部报告查看器路径：'%1'"
EXT_VIEWER_INVALID_INDEX = "无效索引，指定索引处没有有效的外部报表查看器：'%1'"

INVALID_LABVIEW_SERVER_TYPE = "无效的 LabVIEW 服务器类型：'%1'"
INVALID_LABVIEW_SERVER_PATH = "无效的 LabVIEW 服务器路径：'%1'"
INVALID_LABVIEW_SERVER_VALUE Line0001 = "无效的 LabVIEW 服务器：'%1'\n"
INVALID_LABVIEW_SERVER_VALUE Line0002 = "‘major.minor’格式的预期版本（例如 LabVIEW 2009 的‘9.0’或 LabVIEW 8.6.1 的‘8.6’）或 LabVIEW 运行时引擎的绝对路径"
INVALID_MODULE = "错误，为步骤 '%1' 指定的模块无效。"

;IPXI 运行时错误消息
UNABLE_TO_APPLY_SWEEP_ATTRIBUTE = "无法应用属性"
NO_PLUGIN_FOUND = "没有找到插件"
PLUGIN_NOT_FOUND = "找不到插件"
NO_CONFIGURATION_FOUND = "没有找到配置"
NO_SESSIONS_IN_CONFIGURATION = "在配置中找不到会话"
INVALID_SESSION = "正在使用的会话无效"
UNABLE_TO_CLOSE_SESSION = "无法关闭会话"
UNABLE_TO_OPEN_SESSION = "无法打开仪器会话"
NOT_SUPPORTED_IN_32BIT = "32 位 TestStand 不支持此功能。"
ADAPTER_EMPTY = "IO 会话变量 '%1' 没有适配器集。请使用 'NI_CreateIOSessionAndApplyIOConfig' 步骤类型创建有效会话。"
UNABLE_TO_APPLY_SWEEP_ATTRIBUTE_EXT = "无法为逻辑名称 '%1' 应用属性。\n\n详细信息：\n %2"
UNABLE_TO_OPEN_SESSION_EXT = "无法打开逻辑名称 '%1' 的仪器会话。\n\n详细信息：\n %2"
UNABLE_TO_CLOSE_SESSION_EXT = "无法关闭逻辑名称 '%1' 的会话。\n\n详细信息：\n %2 "
CUSTOM_PANEL_SESSION = "会话 '%1' 是一个自定义面板会话，不支持该步骤类型。"
CREATE_SESSION_STEP_NOT_FOUND = "未找到 ID 为 '%1' 的创建会话和应用配置步骤。"
DRIVER_NOT_INSTALLED = "会话 '%1' 的驱动程序未安装。"
DRIVER_TOO_OLD = "不支持会话 '%1' 的当前驱动程序版本。请安装最新的驱动程序。"
INSTRUMENT_MISMATCH = "配置中定义的会话 '%1' 的仪器类型与会话变量 '%2' 中定义的仪器类型不匹配。"
INSTRUMENT_NOT_SUPPORTED = "插件 '%2' 不支持仪器类型 '%1'。请联系 National Instruments 寻求支持。"
BAD_RUNTIME_PLUGIN = "支持的仪器与插件 '%1' 不匹配。请联系 National Instruments 以获得支持。"
LV_VERSION_NOT_SUPPORTED = "插件 '%1' 不支持使用 LabVIEW '%2' 运行时创建会话。更改 LabVIEW 适配器设置以使用不同版本的 LabVIEW 运行时。 "
 

;;内存检查
MEMORY_CHECKING_STACK_CORRUPTION = "调用代码模块时发生堆栈损坏：\n%1\n\n应用程序现在可能不稳定。\n\n堆栈顶部 = 0x%2。堆栈差异："
MEMORY_CHECKING_OFFSET = "\n 到一阶差分的偏移量 = %1 (0x%2)"
MEMORY_CHECKING_OFFSET_BUFFER = "\n 从缓冲区开始到第一个损坏字节的偏移量 = %1 (0x%2)"
MEMORY_CHECKING_DIFF_EXPECTED = "\n 地址 0x%1：找到 0x%2，应为 0x%3"
MEMORY_CHECKING_DIFF = "\n 地址 0x%1：找到 0x%2"
MEMORY_CHECKING_MORE_DIFFS = "\n\n存在更多条目但未显示。"
MEMORY_CHECKING_BUFFER_UNDERFLOW = "数组、缓冲区或结构成员之前的内存被错误更改%1:%2\n\n内存可能已损坏。重新启动应用程序以确保系统稳定性"
MEMORY_CHECKING_BUFFER_OVERFLOW = "数组、缓冲区或结构成员被错误更改后的内存%1:%2\n\n内存可能已损坏。重新启动应用程序以确保系统稳定性"
MEMORY_CHECKING_CONST_STRUCT = "'const' 字符串结构成员的内存被错误更改%1:%2\n\n如果代码模块必须更新字符串参数，请将参数作为字符串缓冲区传递"
MEMORY_CHECKING_CONST = "'const' 字符串参数的内存被错误更改。如果代码模块必须更新字符串参数，请将参数作为字符串缓冲区传递"

DESTRUCTOR_DID_NOT_COMPLETE_MESSAGE = "TestStand 引擎未完成其清理过程。\n\n如果您保留对引擎的引用以便引擎在 .NET 运行时关闭之前不会被销毁，就会发生这种情况。\n\n您可以禁用此警告通过取消选中 Station Options >> Preferences >> Debug Options >> Report Object Leaks。"
DESTRUCTOR_DID_NOT_COMPLETE_CAPTION = "警告"

;; Ivi 步骤类型错误
UNEXPECTED_STRUCT_MEMBER_TYPE = "CommonCAdapter API 方法 %1 失败，因为类型定义 '%3' 的属性 '%2' 与函数预期的类型不匹配。"
STRUCT_MEMBER_CANNOT_BE_INCLUDED = "CommonCAdapter API 方法 %1 失败，因为类型定义 '%3' 的属性 '%2' 不能以其当前形式包含在结构中。"

COLLECTION_UNABLE_TO_CREATE = "无法创建 '%1' 对象"

LABVIEW_MODULE_UNABLE_TO_GET_REMOTE_HOST_INFO = "无法获取远程主机信息，确保指定了远程主机。"

VI_UNABLE_TO_FIND_ABSOLUTE_PATH = "无法找到模块绝对路径：'%1'。"

LV_PARAMETER_INVALID_PROPERTY = "当前参数类型不包含属性或方法：'%1'"
LV_MEMBER_NOT_FOUND_IN_CLUSTER = "成员 '%1' 不包含在集群中"
INVALID_PARAMETER_TYPE = "无效的参数类型：'%1'"
INVALID_NUMERIC_PASSING = "无效的数字传递值：'%1'"

LV_INVALID_REMOTE_VI_PATH = "无效的远程 vi 路径：'%1'"
LV_INVALID_REMOTE_PROJECT_PATH = "无效的远程项目路径：'%1'"

LV_INVALID_PARAMETER_INDEX = "无效参数索引：'%1'"
LV_INVALID_PARAMETER_ELEMENT_INDEX = "无效参数元素索引：'%1'"
LV_IS_WIRE_REQUIRED = "参数必须赋值，不能设置为使用默认值"
INVALID_CODETEMPLATE_POLICY = "无效的代码模板策略常量：'%1'"
CANT_EVAL_REMOTE_HOST_DESC = "远程主机由仅在运行时评估的表达式指定。"

INDEX_EMPTY_ARRAY_ERROR = "无法索引空数组。"
ARRAY_INDICES_ERROR = "需要 %1 个数组索引，找到 %2。"

LV_INVALID_NODE_PROPERTY_INDEX = "无效节点属性索引：'%1'"

LV_NXG_IS_WIRE_REQUIRED = "必须给参数赋值，不能设置为使用默认值"
LV_NXG_PARAMETER_INVALID_PROPERTY = "当前参数类型不包含属性或方法：'%1'"
LV_NXG_INVALID_PARAMETER_INDEX = "无效参数索引：'%1'"



;;表达式错误
EVAL_ERROR_PREFIX = "评估错误：%1"
EVAL_WARNING_PREFIX = "评估警告：%1"
SYNTAX_ERROR_PREFIX = "语法错误：%1"
EVAL_ERROR_WRONG_TYPE = "应为 %1，已找到 %2。"
EXPR_INVALID_CONSTANT_TYPE = "无效常量类型：%1"

SYNTAX_ERROR_TITLE = "语法错误"
EVAL_ERROR_TITLE = "评估错误"
EVAL_WARNING_TITLE = "评估警告"
ERROR_IN_EXPR_TEXT = "%1\n\n该值将导致运行时错误。"
WARNING_IN_EXPR_TEXT = "%1\n\n如果您确定表达式将在运行时正确计算，您可以忽略错误或使用 #NoValidation 指令来抑制错误。"

NEGATIVE_PARAMETER = "评估为 %1 的参数不能为负数。"

NO_VALIDATION_ZERO_PARAMS = "您必须使用不带括号的#NoValidation 来抑制对表达式其余部分的错误检查，或者将表达式作为参数传递给#NoValidation。"

RANGE_OUTSIDE_SUBSCRIPT = "范围仅在数组下标内有效。"
TEMPORARY_ARRAY_VALUE_ASSIGNMENT = "数组值 '%1' 的赋值是到一个临时位置。"

;;API 表达式错误
API_MEMBER_ERROR = "调用 TestStand API 成员 '%3' 时出错。"
API_MEMBER_ERROR_AT_PARAMETER = "调用 TestStand API 成员 '%3' 时参数 %1、%2 出错。"
WRITE_TO_READONLY_PROPERTY = "无法写入只读属性。"
MEMBER_NOT_EXIST = "%1 '%2' 在接口 '%3' 中不存在。"
METHOD = "方法"
PROPERTY ="财产"
CALL_METHOD_AS_PROPERTY = "您正在尝试将 TestStand API 方法'%1'用作属性。您必须使用括号来调用方法。"
INTERFACE_NOT_EXIST = "接口或子属性 '%1' 不存在或使用不正确的语法指定。要指定接口，您必须在 TestStand 接口名称前加上单词 'As' 并且不使用尾随括号，例如 Locals.Ref.AsPropertyObject "
INVOKE_ON_NULL_OBJECT = "无法在 NULL 对象引用 '%2' 上调用 API 成员 '%1'。"
INVOKE_ON_NON_TS_OBJECT = "无法调用成员 '%1'，因为对象引用 '%2' 不包含 TestStand 对象。"

;;源代码管理提供程序错误
INVALID_SCC_PROVIDER = "无效的源代码控制提供程序：'%1'。\n请确认该提供程序已安装在此计算机上并且名称正确。"

;;序列文件模块
INVALID_SEQUENCE_FILE_PATH = "无效的序列文件路径：'%1'"
UNABLE_TO_RELOAD_PROTOTYPE = "使用选定序列的原型。无法调用此方法。"

;;常用C参数
C_PARAM_INVALID_DATA_TYPE = "类型无效，验证类型对应于所选类别。"
C_PARAM_STRUCT_PARAMETER_GET = "结构参数，无法通过该属性获取对应类型。"
C_PARAM_STRUCT_PARAMETER_SET = "结构参数，无法通过该属性设置对应的类型。"
C_PARAM_INVALID_NUM_DIMENSIONS = "维数必须大于零且小于或等于'%1'。"
C_PARAM_INVALID_DIMENSION_INDEX = "无效的维度索引，索引必须大于或等于零且小于 '%1'。"
C_PARAM_ARRAY_DIM_SIZE_NOT_CONSTANT = "无法获取非常量数组维度大小表达式的数值：'%1'。"

C_INVALID_PATH = "无效路径：'%1'"
C_INVALID_CALLING_CONVENTION = "无效的调用约定类型：'%1'。"
C_READ_ONLY_PROTOTYPE = "无法编辑模块的原型，请确保您拥有所需的权限。"
C_INVALID_FUNCTION = "函数：'%1'，在所选模块中不存在。"
C_INVALID_PARAMETER_PASS_VALUE = "无效参数数字传递值：'%1'"
C_INVALID_PARAMETER_ELEM_PASS_VALUE = "无效的数组元素传递值：'%1'"
C_INVALID_RESULT_ACTION = "无效的结果操作值：'%1'"
C_INVALID_UNKNOWN_INFO_CONSTANT = "无效的 UnknownInfo 常量：'%1'"

;;Cpp 参数

CPP_INVALID_PARAMETER_INDEX = "无效参数索引：'%1'"

;; LabVIEW参数

LV_PARAM_INVALID_DIMENSION_INDEX = "无效的维度索引，索引必须大于或等于零且小于 '%1'。"
LV_PARAM_NOT_AN_ARRAY = "参数 '%1' 不是数组。方法仅对数组类型有效。"
LV_PARAM_NOT_A_CLUSTER = "参数 '%1' 不是簇。方法仅对簇类型有效。"
LV_PARAM_NOT_COMPLEX_NUMBER = "参数 '%1' 不是复数。方法仅对复数或复数数组有效。"

;; LabVIEW NXG 参数

LVNXG_PARAM_INVALID_DIMENSION_INDEX = "无效的维度索引，索引必须大于或等于零且小于 '%1'。"
LVNXG_PARAM_NOT_AN_ARRAY = "参数 '%1' 不是数组。方法仅对数组类型有效。"
LVNXG_PARAM_NOT_A_CLUSTER = "参数 '%1' 不是簇。方法仅对簇类型有效。"
LVNXG_PARAM_NOT_COMPLEX_NUMBER = "参数 '%1' 不是复数。方法仅对复数或复数数组有效。"

;;错误代码：54
LV_BAD_HOST_OR_IP = "确认主机名存在或 IP 地址格式正确 (0.0.0.0)。"
;;错误代码：56
LV_IP_ADDRESS_NOT_FOUND = "通过使用给定的 IP 地址运行命令 nslookup 来验证 IP 地址是否存在。"
;;错误代码：1032
LV_EXPORTED_VIS = "通过检查导出的 VI 列表，验证远程主机是否允许通过 LabVIEW VI 服务器调用 VI。"
;;错误代码：66
LV_TCPIP_ACCESS_LIST = "通过检查 TCP/IP 访问列表验证远程主机是否允许您的本地主机访问 LabVIEW VI 服务器。"
;;错误代码：63
LV_TCPIP_IS_OFF = "网络连接被服务器拒绝。\n\n确认 LabVIEW 正在远程主机上运行并且 LabVIEW 允许 TCP/IP 连接。另外，确保远程主机允许连接到指定的端口。"

LV_REMOTE_VI_MORE_INFO = "有关详细信息，请参阅'将 LabVIEW 与 TestStand 结合使用'文档中的'附录 A：在远程系统上调用 LabVIEW VI'。"


;;CVI_参数

CVI_INVALID_PROJECT_PATH = "无效的项目路径：'%1'"
CVI_INVALID_FUNCTION_NAME = "无效函数名称：'%1'"
CVI_INVALID_SOURCE_FILE_PATH = "无效的源文件路径：'%1'"
CVI_FUNCTION_NOT_FOUND_ON_SOURCE = "在源文件中找不到 '%1' 的函数定义。"
CVI_UNABLE_TO_GET_MODULE_INFORMATION = "无法获取模块信息，源文件中的原型可能无效。"
CVI_INVALID_MODULE_TYPE = "无效的模块类型：'%1'"
CVI_INVALID_PARAMETER_CATEGORY = "无效参数类别：'%1'"
CVI_INVALID_PARAMETER_PASS_VALUE = "无效参数数字传递值：'%1'"
CVI_UNABLE_TO_REPLACE_RETURN_PARAM = "索引零对应于函数返回值。您不能替换、移动或删除返回值。"
CVI_INVALID_PARAMETER_CATEGORY_VOID = "无效参数类别。只有返回参数可以为空。"

;;Python适配器

PYTHON_UNABLE_TO_REPLACE_RETURN_PARAM = "索引零对应于返回值。您不能替换、移动或删除返回值。"
PYTHON_INVALID_PARAMETER_INDEX = "无效参数索引：'%1'"
PYTHON_INVALID_PARAMETER_CATEGORY_NONE = "无效的参数类别。只有返回参数可以是 None。"
PYTHON_ADAPTER_INTERPRETER_SESSION_DEFAULT = "无效的解释器会话。您只能在该步骤中使用'默认'值。"
PYTHON_ADAPTER_INTERPRETER_SESSION_OBJECT_REFERENCE = "无效的解释器会话。您只能在该步骤中使用'ObjectReference'值。"
PYTHON_ADAPTER_UNABLE_TO_USE_NIPYTHONINTERFACE = "无法使用 NIPythonInterface 组件。确保 NIPythonInterface 已正确安装并重试。"
PYTHON_ADAPTER_INVALID_PYTHON_VERSION = "无法使用配置的设置创建解释器会话。确保配置的虚拟环境路径有效并且 python 版本已安装并添加到 PATH 环境变量。"
PYTHON_ADAPTER_INTERPRETER_SESSION_NOT_PRESENT_IN_REFERENCE = "解释器在配置的解释器引用中不存在。启用选项'如果解释器不存在则创建'并重试。"
PYTHON_ADAPTER_INTERPRETER_SESSION_NOT_VALID = "配置的解释器参考中的解释器是使用与配置设置不同的设置创建的。确保参考中的解释器是使用相同的设置创建的，然后重试。"
PYTHON_ADAPTER_INTERPRETER_SESSION_EMPTY_REFERENCE_WITHOUT_CREATE = "解释器引用位置为空。如果你想创建一个新的 python 解释器会话仅用于执行步骤，启用'如果不存在则创建解释器'选项。"
PYTHON_ADAPTER_FILE_NOT_FOUND = "未找到文件 '%1'。确保该文件存在。"
PYTHON_ADAPTER_FILE_NOT_FOUND_ABSOLUTE_PATH = "文件 '%1' 未找到。确保您指定了绝对路径并且文件存在。"
PYTHON_ADAPTER_UNKNOWN_PYTHON_VERSION = "未知的 python 版本。TestStand 支持 python 2.7+ 和 3.6+。指定具有主要和次要版本号的版本，如'2.7'或'3.6'。确保 python 路径存在于 PATH 环境变量中。"
PYTHON_ADAPTER_PYTHON_LOAD_FAIL = "无法加载指定版本的 python。确保安装了正确位数的 python 并将其添加到 PATH 环境变量中。"
PYTHON_ADAPTER_INVALID_PYTHON_VIRTUAL_ENV_PATH = "无效的虚拟环境路径。TestStand 支持使用 'virtualenv' 工具创建的虚拟环境。确保可以使用 TestStand 搜索目录找到虚拟环境目录。"
PYTHON_ADAPTER_EXTERNAL_INTERPRETER_SESSION_CRASHED = "Python 解释器会话崩溃。如果显示控制台，关闭控制台将使解释器崩溃。完成所有执行，卸载所有模块并重试执行序列文件。"
PYTHON_ADAPTER_PYTHON_VERSION_FAILURE = "使用指定的 python 版本时出错。TestStand 支持 python 2.7+ 和 3.6+。指定具有主要和次要版本号的版本，如'2.7'或'3.6'。确保 python 路径存在于 PATH 环境变量中。"
PYTHON_ADAPTER_MODULE_IMPORT_FAIL_HEADER = "无法导入模块，原因如下：\n\n"

;;Python模块

NO_PYTHONMODULE = "当前操作要求 PythonCall 是 PythonModule 的一部分，但它不是 PythonModule 的一部分。"
PYTHON_MODULE_INVALID_EXTENSION = "不支持的文件扩展名。只支持带有 .py 文件扩展名的 python 模块。"
PYTHON_MODULE_INVALID_DIRECTORY = "为模块路径指定的目录无效。只有包含 __init__.py 文件的目录才能用作 python 模块路径。"
PYTHON_MODULE_EMPTY_FUNC_ATTRIB_NAME = "函数/属性名称为空。"
PYTHON_MODULE_EMPTY_CLASS_NAME = "类名是空的。"
PYTHON_MODULE_EMPTY_CLASS_INSTANCE_LOCATION = "类实例位置为空。"
PYTHON_MODULE_ERROR_CLASS_INSTANCE = "访问 python 类实例时出错。"
PYTHON_MODULE_ERROR_INTERPRETER_REFERENCE = "访问 python 解释器引用时出错。"
PYTHON_MODULE_INVALID_VALUE_FOR_ARRAY_PARAM_CATEGORY = "数组参数类别的值无效。有效值是列表或 NumPy 数组。"

;;Python参数
PYTHON_PARAMETER_ERROR_EMPTY_CONTAINER = "参数不支持空容器。确保容器包含其他变量。"
PYTHON_PARAMETER_ERROR_UNSTRUCTURED_CONTAINER = "参数不支持非结构化容器数组。"
PYTHON_PARAMETER_FIX_UNSTRUCTURED_CONTAINER_IN_PARAM = "更新参数以使用指定类型的数组。"
PYTHON_PARAMETER_FIX_UNSTRUCTURED_CONTAINER_IN_SUBPROP = "更新参数的 '%1' 子属性以使用指定类型的数组。"
PYTHON_PARAMETER_ERROR_UNSTRUCTURED_FLAG = "参数不支持命名类型数组中存在的非结构化容器。"
PYTHON_PARAMETER_FIX_UNSTRUCTURED_FLAG_IN_PARAM = "参数数组的非结构化标志设置为数组元素类型中的 '%1' 属性。"
PYTHON_PARAMETER_FIX_UNSTRUCTURED_FLAG_IN_SUBPROP = "数组 '%1' 的元素在数组元素类型中将非结构化标志设置为 '%2' 属性。"
PYTHON_PARAMETER_ERROR_ARRAY_STRUCTURE = "所有数组元素应具有相同的结构。"
PYTHON_PARAMETER_FIX_ARRAY_STRUCTURE = "'%1' 和'%2' 数组的数组维数和大小不相等。"
PYTHON_PARAMETER_INVALID_PYOBJ_REFERENCE_IN_PARAM = "参数值不包含对 PyObject 的引用。"
PYTHON_PARAMETER_INVALID_PYOBJ_REFERENCE_USING_DYNAMIC_IN_PARAM = "无效参数值。参数值应包含对 PyObject 的引用或对实现 IDispatch 的 COM 对象的引用。"
PYTHON_PARAMETER_INVALID_PYOBJ_REFERENCE_IN_SUBPROP = "参数的子属性 '%1' 的值无效。参数值应包含对 PyObject 的引用或对实现 IDispatch 的 COM 对象的引用。"
PYTHON_PARAMETER_ERROR_PYOBJ_BETWEEN_SESSIONS_IN_PARAM = "无法使用在另一个 Python 解释器会话中创建的 PyObject。您可以使用在同一 Python 解释器会话中创建的 PyObject。"
PYTHON_PARAMETER_ERROR_PYOBJ_BETWEEN_SESSIONS_IN_SUBPROP = "参数的子属性 '%1' 的值包含在另一个 python 解释器会话中创建的 PyObject。您可以使用在同一个 python 解释器会话中创建的 PyObject。"
PYTHON_PARAMETER_INVALID_PYOBJ_REFERENCE_IN_ARRAY_PARAM = "参数的 '%1' 元素值无效。参数值应包含对 PyObject 的引用或对实现 IDispatch 的 COM 对象的引用。"
PYTHON_PARAMETER_INVALID_PYOBJ_REFERENCE_IN_ARRAY_SUBPROP = "参数的 '%2' 子属性的 '%1' 元素值无效。参数值应包含对 PyObject 的引用或对实现 IDispatch 的 COM 对象的引用。"
PYTHON_PARAMETER_ERROR_PYOBJ_BETWEEN_SESSIONS_IN_ARRAY_PARAM = "无法在 '%1' 元素中使用 PyObject，因为它是在另一个 Python 解释器会话中创建的。您可以使用在同一个 Python 解释器会话中创建的 PyObject。"
PYTHON_PARAMETER_ERROR_PYOBJ_BETWEEN_SESSIONS_IN_ARRAY_SUBPROP = "无法在参数的 '%2' 子属性的 '%1' 元素中使用 PyObject，因为它是在另一个 python 解释器会话中创建的。您可以使用在同一个 python 解释器会话中创建的 PyObject。"
PYTHON_PARAMETER_ERROR_ERROR_USING_PARAMETER_IN_PARAM = "'%1' 出错。"
PYTHON_PARAMETER_ERROR_ERROR_USING_PARAMETER_IN_SUBPROP = "'%1' 的 '%2' 子属性出错。"
PYTHON_PARAMETER_INSERT_PARAM_FOR_SETATTRIB = "无法插入参数。执行设置属性操作时应该只有一个参数。"
PYTHON_PARAMETER_DELETE_PARAM_FOR_SETATTRIB = "无法删除参数。执行设置属性操作时应该只有一个参数。"
PYTHON_PARAMETER_INSERT_PARAM_FOR_GETATRIB = "无法插入参数。执行获取属性操作时不应有参数。"
PYTHON_PARAMETER_CREATE_CLASS_RETURN_IS_NOT_OBJECT = "Python 类实例只能存储在对象引用类型的变量中。因此，当操作设置为创建类实例时，返回类型只能设置为'Object'。"
PYTHON_PARAMETER_SET_ATTRIB_RETURN_IS_NOT_NONE = "设置属性操作不能有任何返回值。因此，当操作设置为设置属性时，返回类型只能设置为'无'。"
PYTHON_PARAMETER_ERROR_PYWIN32_NOT_INSTALLED = "无法将参数 '%1' 作为 COM 对象传递。确保你已经安装了 pywin32 Python 模块。"
PYTHON_PARAMETER_ERROR_PYWIN32_NOT_INSTALLED_IN_SUBPROPERTY = "无法将参数 '%2' 的子属性 '%1' 作为 COM 对象传递。确保您已经安装了 pywin32 Python 模块。"
PYTHON_PARAMETER_ERROR_INVALID_DISPATCH_PARAMETER = "'Dispatch' 类型的值无效。值可以是 TestStand 接口或对象引用变量，其中包含对实现 IDispatch 的 COM 对象的引用。"
PYTHON_PARAMETER_ERROR_INVALID_DISPATCH_RETURN_VALUE = "'Dispatch' 类型的值无效。值可以是对象引用变量。"
PYTHON_PARAMETER_DISPATCH_CREATE_TS_AUTO_MGR_FAILED = "无法创建 TSAUTOMGRLib::InterfaceServer 实例"
PYTHON_PARAMETER_ERROR_ARR_ELEM_PYWIN32_NOT_INSTALLED = "无法将参数 '%1%2' 作为 COM 对象传递。确保你已经安装了 pywin32 Python 模块。"
PYTHON_PARAMETER_ERROR_ARR_ELEM_PYWIN32_NOT_INSTALLED_IN_SUBPROPERTY = "无法将参数 '%3' 的子属性 '%1%2' 作为 COM 对象传递。确保你已经安装了 pywin32 Python 模块。"
PYTHON_PARAMETER_ERROR_INVALID_DISPATCH_OBJ = "无效数据。Python 实例无法转换为 COM 对象。"
PYTHON_PARAMETER_ERROR_INVALID_ENUM_MAPPING = "The specified TestStand Enum argument: '%1', which uses the TestStand type definition, '%2', does not contain a valid type mapping. You can view the TestStand help page on 'Mapping TestStand data types to python data types' 以查看哪些 python 枚举类型映射到它们相应的 TestStand 枚举类型。"
PYTHON_PARAMETER_ERROR_UNSUPPORTED_ENUM_MAPPING = "指定的 TestStand 枚举参数：'%1'，它使用 TestStand 类型定义，'%2'，既不是严格枚举，也不是标志枚举。不支持将此 TestStand 枚举配置映射到任何 python枚举类型。要查看哪些 python 枚举类型映射到它们相应的 TestStand 枚举类型，您可以查看 TestStand 帮助页面上的"将 TestStand 数据类型映射到 python 数据类型"。
PYTHON_PARAMETER_ERROR_INVALID_ENUM_MODULE_PATH = "为 TestStand 枚举类型的 python 枚举信息指定的 python 模块路径无效。确保磁盘上存在指定路径。"
PYTHON_PARAMETER_ERROR_EMPTY_ENUM_NAME = "在 TestStand 枚举类型的 Python 枚举信息中指定的枚举名称为空。枚举名称应指定 Python 枚举类以将 TestStand 枚举映射到。"
PYTHON_PARAMETER_ERROR_ENUM_IN_PYTHON27 = "指定的参数参数是一个 TestStand 枚举，类型映射到 python 枚举。Python 从 Python 3.4 开始支持枚举。"

;;ActiveX 模块

COCLASS_NOT_INCLUDED_IN_TYPE_LIBRARY = "'%1' Coclass 信息不可用。"
INTERFACE_NOT_INCLUDED_IN_COCLASS = "'%1' 接口信息不可用，请确保该接口存在。"
ACTIVEX_INVALID_FILE_PATH = "无效文件路径：'%1'"
MEMBER_NOT_PART_OF_INTERFACE = "成员：'%1' 未包含在所选接口中。"
ACTIVEX_INVALID_CREATE_OPTION = "无效的创建选项：'%1'。"
ACTIVEX_INVALID_MEMBER_TYPE = "无效的成员类型：'%1'。"
ACTIVEX_INVALID_PARAMETER_INDEX = "无效参数索引：'%1'"

;;HT基础

HTBASIC_INVALID_WORKING_DIR = "无效的 HTBasic 工作目录常量：'%1'"

INVALID_STEP_GROUP = "无效的步骤组类型：'%1'"

;;序列调用

SEQ_CALL_INVALID_SEQ_FILE_PATH = "无效的序列文件路径：'%1'"
SEQ_CALL_INVALID_TECE_CONSTANT = "无效的跟踪设置常量：'%1'"
SEQ_CALL_INVALID_REMOTE_EXEC_CONSTANT = "无效的多线程和远程执行常量：'%1'"
SEQ_CALL_INVALID_NEW_THREAD_OPTION = "无效的新线程选项：'%1'"	
SEQ_CALL_INVALID_NEW_EXEC_MODEL_OPTION = "无效的新执行模型选项：'%1'"
SEQ_CALL_INVALID_MODEL_PATH = "无效模型路径：'%1'"
SEQ_CALL_INVALID_WAIT_FOR_EXEC_OPTION = "无效的新执行等待完成选项：'%1'"
SEQ_CALL_COULD_NOT_LOAD_STEP_TYPE = "无法加载可以创建序列调用步骤的步骤类型"

;;点网

NO_DOTNETMODULE = "当前操作要求 DotNetCall 是 DotNetModule 的一部分，但它不是 DotNetModule 的一部分。"
DOT_NET_INVALID_MEMBER_TYPE = "无效的成员类型：'%1'"

OBJ_FILE_REQUIREMENTS_NOT_SUPPORTED = "此属性可用于序列文件、项目文件和工作区文件。"
OBJ_FILE_INVALID_VERSION_INC_OPT = "无效的版本增量选项：'%1'"
INVALID_RTE_OPTION = "无效的运行时错误选项：'%1'"
INVALID_INTERNAL_OPT = "无效的内部选项常量：'%1'"
INVALID_SOURCE_CONTROL_COMMAND = "无效的源代码控制命令：'%1'"
INVALID_STEPS_GROUP_CONSTANT = "无效的步骤组常量：'%1'"
INVALID_MODULE_LOAD_OPTION = "无效的模块加载选项：'%1'"
INVALID_MODULE_UNLOAD_OPTION = "无效的模块卸载选项：'%1'"
INVALID_EVAL_PRECONDITION_OPT = "无效的评估前提条件选项：'%1'"
INVALID_WND_ACTIVATION_OPT = "无效的窗口激活选项：'%1'"
INVALID_BATCH_SYNC_OPT = "无效的批量同步选项：'%1'"	
INVALID_REPORT_CONVERSION_OPTION = "无效的报告转换选项：'%1'"
INVALID_WATCHPOINT_BREAK_TYPE = "无效的中断类型常量：'%1'"
INVALID_INTERACTIVE_BRANCH_MODE = "无效的交互分支模式：'%1'"
INVALID_TIME_LIMIT_TYPE = "无效的时间限制类型：'%1'"
INVALID_TIME_LIMIT_OPERATION = "无效的时间限制操作：'%1'"
INVALID_TIME_LIMIT_ACTION = "无效的时间限制操作：'%1'"
INVALID_TYPE_VER_INC_OPT = "无效的类型版本自动增量选项：'%1'"
INVALID_SPEC_STEP_BY_UI = "通过唯一 ID 选项指定的步骤无效：'%1'"
INVALID_PROTECTION_OPT = "无效的文件保护选项：'%1'"
INVALID_NUM_CALLS = "无效的调用次数：'%1'"

DOTNET_INVALID_PATH = "无效路径：'%1'"
ENUM_NOT_INCLUDED_IN_ASSEMBLY = "程序集 '%2' 中不存在枚举 '%1'。"
ASSEMBLY_NOT_FOUND = "未找到程序集 '%1'。"
ERROR_LOADING_ASSEMBLY = "<加载程序集时出错>"
CLASS_NOT_INCLUDED_IN_ASSEMBLY = "程序集 '%2' 中不存在类 '%1'。"
ERROR_NOTE_ASSEMBLY_HAS_UNLOADABED_DEPENDENCIES = "注意：程序集 '%1' 具有可卸载的依赖项。"
ERROR_PREFIX = "错误[%1]："
STRUCT_NOT_INCLUDED_IN_ASSEMBLY = "结构 '%1' 在程序集 '%2' 中不存在或不是结构。"
FIRST_CALL_IS_INSTANCE_MEMBER = "成员 '%1' 作为调用中的第一个调用是无效的，因为它是一个需要对象的实例成员。"
INVALID_CALL_FOR_NON_FIRST_CALL = "成员 '%1' 仅作为调用中的第一个调用有效。"
INVALID_CALL_FOR_NON_FIRST_CALL_STATIC = "成员 '%1' 是静态的，因此仅作为调用中的第一个调用有效。注意：为了向后兼容，只要没有其他问题，该步骤仍将正确执行。"
NO_MEMBERS_FOUND = "在程序集 '%2' 中找不到类型 '%1' 的公共成员。"
MEMBER_REQUIRES_UNLOADABLE_TYPE = "程序集 '%3' 中类 '%2' 中的成员 '%1' 的原型依赖于程序集 '%4' 中的类型，但无法加载该程序集（注意：要强制刷新此程序集的信息，请选择"文件 -> 卸载所有模块"菜单项。）。
PROTOTYPE_INCOMPATIBLE_OR_MEMBER_REQUIRES_UNLOADABLE_TYPE Line0001 = "程序集 '%3' 中类 '%2' 中的成员 '%1' 的至少一个重载取决于程序集 '%4' 中的一种类型，但无法加载该程序集（注意：要强制刷新此程序集的信息，选择"
PROTOTYPE_INCOMPATIBLE_OR_MEMBER_REQUIRES_UNLOADABLE_TYPE Line0002 = "'文件->卸载所有模块'菜单项。)。此外，至少有一个重载不依赖于可卸载程序集中的任何类型，但也不匹配您指定的原型。您可以如果您愿意，请重新加载原型以指定重载。"
MEMBER_NOT_PART_OF_CLASS = "在程序集 '%3' 的类 '%2' 中找不到成员 '%1'。"
MEMBER_INDEX_OUT_OF_RANGE = "成员索引 %1 对成员 '%2' 无效。"
MEMBER_AMBIGUOUS = "程序集 '%3' 中接口 '%2' 中的成员 '%1' 不明确，因为它是从两个不同的接口继承的。"
PROPERTY_NOT_PART_OF_CLASS = "属性：'%1' 未包含在所选类中。"
CALL_NOT_FOUND = "在模块中找不到 .NET 调用 '%1'。"
PROTOTYPE_INCOMPATIBLE = "原型与在程序集 '%3' 的类 '%2' 中为成员 '%1' 找到的原型不匹配。"
CONSTRUCTOR_METADATATOKEN_INVALID = "构造函数 MetaDataToken %1 对于类 '%2' 无效。"
AMBIGUOUS_SIGNATURE = "在程序集 '%3' 的类 '%2' 中找到了 '%1' 的多个定义。请指定完整的签名。"
SINGLE_CALL_ONLY = "此 API 已过时，仅在仅包含一个 DotNetCall 和/或以下之一的 DotNetModules 上受支持：构造函数、\"创建远程\"调用或\"使用现有\"调用。"
MEMBER_DOES_NOT_RETURN_CALLABLE_TYPE = "程序集 '%3' 中类 '%2' 中的成员 '%1' 没有返回可调用类型。"
FATAL_UNHANDLED_DOTNET_EXCEPTION Line0001 = "运行 .NET 代码的非执行线程引发了未处理的异常。如果您的代码在终结器中导致异常，或者如果您创建新的 .NET 线程并且其中一个线程中发生未处理的异常，就会发生这种情况。 .NET 框架认为"
FATAL_UNHANDLED_DOTNET_EXCEPTION Line0002 = "这是一个致命错误，一旦您关闭此对话框，进程就会终止。存在进程现在处于错误状态的风险，因此保存文件可能会使它们也处于错误状态或导致其他错误。以下是抛出的未处理异常的详细信息：\n\n%1"
FATAL_UNHANDLED_DOTNET_EXCEPTION_CAPTION = "TestStand 检测到一个致命错误"

MIXED_MODE_ASSEMBLY_VERSION = "加载 DLL 时出错 - 如果这是一个以 .NET Framework 3.5 或更早版本为目标的 C++/CLI 程序集，您必须创建一个应用程序配置文件来指示应用程序加载此类程序集。请参阅 NI TestStand帮助了解有关创建应用程序配置文件以加载用 C++/CLI 编写并针对早期 .NET Framework 版本构建的程序集的更多信息。"
FILE_BLOCKED = "加载 DLL 时出错 - 它可能已被 Windows 阻止，因为它已被下载。要取消阻止，请在 Windows 资源管理器中右键单击该文件，然后单击"属性"。单击底部的"取消阻止"属性对话框。"
LOADED_ASSEMBLY_PATH_MISMATCH Line0001 = "加载了一个与该步骤指定的程序集不同的程序集。这可能是因为已经加载了具有相同标识的程序集，并且使用了该程序集而不是指定的程序集。\n"
LOADED_ASSEMBLY_PATH_MISMATCH Line0002 = "指定的程序集文件路径：%1\n"
LOADED_ASSEMBLY_PATH_MISMATCH Line0003 = "加载的程序集文件路径：%2"

;;自动化适配器

AUTOMATION_ADP_MEMBER_NOT_SPECIFIED = "未指定成员。"
AUTOMATION_ADP_INVALID_MEMBER_TYPE = "无效的成员类型。"
AUTOMATION_ADP_INVALID_MEMBER_INDEX = "无效的成员索引。"
AUTOMATION_ADP_INVALID_ADP_CONFIG = "无效的适配器配置项。"
AUTOMATION_ADP_INVALID_CREATE_TYPE = "无效的对象创建类型。"
AUTOMATION_ADP_INVALID_PARAM_TYPE = "参数的内部类型无效。"

;;工具菜单
TOOL_MENU_INVALID_INDEX = "无效索引：'%1'。索引必须大于零且小于当前项目数。"
TOOL_MENU_ITEM_INVOKE_COMMAND_FAILED = "无法执行命令：'%1'\n"
TOOL_MENU_ITEM_RUN_SEQUENCE_FAILED = "无法运行文件 '%2' 中的序列 '%1'\n"
TOOL_MENU_INVALID_MENU_NUM = "无效的工具菜单编号：'%1'。最可能的原因是工具菜单尚未构建。"
TOOL_MENU_INVALID_ITEM_NUM = "无效的工具菜单项编号：'%1'。最可能的原因是工具菜单尚未构建。"
TOOL_MENU_INVALID_ITEM_ID = "无效的工具菜单项 ID：'%1'。最可能的原因是工具菜单尚未构建。"
TOOL_MENU_SEQFILE_LOAD_FAILED = "<加载错误：%1>"
TOOL_MENU_SEQFILE_FILE_NOT_FOUND = "<未找到文件：%1>"
TOOL_MENU_UNEDITABLE_SELECTED_FILE = "选定的文件 '%1' 是只读的或已锁定。\n您不能修改该文件。"
TOOL_MENU_ERROR_ENABLED_EXP = "（启用表达式错误）"
TOOL_MENU_ERROR_HIDDEN_EXP = "（隐藏表达式错误）"
TOOL_MENU_ERROR_ARGUMENTS_EXP = "（参数表达式错误）"
TOOL_MENU_INVALID_TYPE = "无效的工具菜单类型：'%1'"
TOOL_MENU_INVALID_INIT_DIRECTORY = "无效的初始目录：'%1'"
TOOL_MENU_INVALID_OPERATION Line0001 = "此操作仅对以下类型的工具菜单项有效：'%1'。\n"
TOOL_MENU_INVALID_OPERATION Line0002 = "当前工具菜单项类型：'%2'"

;; VS_集成
VS_CODE_ELEMENT_ERROR = "无法插入代码，因为 Visual Studio 在源文件 '%1' 中遇到错误。"
VS_FUNCTION_NOT_FOUND = "在指定的源文件中找不到 '%1' 的函数定义。"
VS_CLASS_NOT_FOUND = "在指定的源文件或项目中找不到 '%1' 的类定义。"
VS_FUNCTION_EXISTS_IN_OTHER_SRC = "函数 '%1' 已经存在于不同的源文件 (%2) 中。要继续，TestStand 必须使用该源文件而不是您指定的源文件。您要继续吗？"
VS_CLASS_EXISTS_IN_OTHER_SRC = "类 '%1' 已经存在于不同的源文件 (%2) 中。要继续，TestStand 必须使用该源文件而不是您指定的源文件。您要继续吗？"
VS_FUNCTION_ALREADY_EXISTS = "函数 '%1' 已存在于指定的源文件中。"
VS_INVALID_FUNCTION_LANG = "函数 '%1' 的语言对当前操作无效。"
VS_INVALID_PROJECT_LANG = "项目 '%1' 的语言对当前操作无效。"
VS_INVALID_SOURCE_LANG = "源文件 '%1' 的语言对当前操作无效。"
VS_INVALID_TEMPLATE_SYNTAX = "代码模板 '%1' 包含一个语法无效的模板定义。"
VS_INVALID_TEMPLATE_EXTENSION = "代码模板 '%1' 的文件扩展名对当前操作无效。"
VS_DTE_IS_NULL = "Visual Studio 自动化对象尚未初始化。"
VS_TEMP_PROJECT_NOT_FOUND Line0001 = "无法找到 TestStand 文件 '%1'。您可能需要修复当前的 TestStand 安装。\n"
VS_TEMP_PROJECT_NOT_FOUND Line0002 = "如果您尝试使用的 Visual Studio 版本比官方支持的版本更新"
VS_TEMP_PROJECT_NOT_FOUND Line0003 = "此版本的 TestStand，您需要获取此 Visual Studio 版本的项目模板文件。"
VS_TEMPLATE_NOT_FOUND = "找不到代码模板 '%1'。"
VS_SOURCE_NOT_FOUND = "无法找到源文件 '%1'。"
VS_PROJECT_NOT_FOUND = "找不到 Visual Studio 项目文件 '%1'。"
VS_SOLUTION_NOT_FOUND Line0001 = "找不到 Visual Studio 解决方案文件'%1'。将为您创建一个空解决方案。\n"
VS_SOLUTION_NOT_FOUND Line0002 = "如果您的项目在另一个解决方案中打开，请在继续之前关闭它。"
VS_SOLUTION_NOT_ENTERED Line0001 = "没有输入 Visual Studio 解决方案文件。将为您创建一个空的解决方案。\n"
VS_SOLUTION_NOT_ENTERED Line0002 = "如果您的项目在另一个解决方案中打开，请在继续之前关闭它。"
VS_MSTUDIO_NOT_INSTALLED Line0001 = "此功能需要 Measurement Studio 企业版 8.0.1 或更高版本 "
VS_MSTUDIO_NOT_INSTALLED Line0002 = "Microsoft Visual Studio 将安装在您的计算机上。\n"
VS_MSTUDIO_NOT_INSTALLED Line0003 = "有关 Measurement Studio 的更多信息，请访问 http://www.ni.com/mstudio。"
VS_VSTUDIO_NOT_INSTALLED = "此功能需要在您的计算机上安装受支持的 Microsoft Visual Studio 版本。"
VS_COULD_NOT_INITIALIZE_ERROR_OBJECT = "无法初始化 Visual Studio 自动化错误对象。"
VS_UNKNOWN_ERROR = "发生未知错误。"
VS_COULD_NOT_ADD_SOURCE = "无法将源文件 '%1' 添加到项目中。请确保该项目尚未包含另一个同名文件。"
VS_COULD_NOT_OPEN_SOLUTION Line0001 = "无法打开解决方案文件'%1'。请确认它是"
VS_COULD_NOT_OPEN_SOLUTION Line0002 = "一个有效的 Visual Studio 解决方案文件，不是来自 Visual Studio"
VS_COULD_NOT_OPEN_SOLUTION Line0003 = "版本比您尝试使用的版本新。"
VS_COULD_NOT_OPEN_PROJECT Line0001 = "无法打开项目文件'%1'。请确认它是"
VS_COULD_NOT_OPEN_PROJECT Line0002 = "一个有效的 Visual Studio 项目文件，不是来自 Visual Studio"
VS_COULD_NOT_OPEN_PROJECT Line0003 = "版本比您尝试使用的版本新。"
VS_VS_MATCH_VERSION_FAILED_NO_PROJECT = "无法匹配项目的版本，因为没有指定项目文件。请指定一个有效的 Visual Studio 项目文件。"
VS_COULD_NOT_ADD_PROJECT = "无法将项目文件 '%1' 添加到解决方案中。请确保该项目是有效的 Visual Studio 项目。"
VS_PROJECT_NOT_IN_SOLUTION = "请选择包含指定项目的解决方案。"
VS_SOURCE_NOT_IN_PROJECT = "请选择一个包含指定源的项目。"
VS_COULD_NOT_ACCESS_DTE = "无法访问 Visual Studio 应用程序。"
VS_DUPLICATE_PARAM_NAMES Line0001 = "模块选项卡上指定的一个或多个参数名称冲突。请确保每个参数"
VS_DUPLICATE_PARAM_NAMES Line0002 = "名称是继续之前的唯一标识符。"
VS_COULD_NOT_EDIT_FILE = "无法修改文件 '%1'。请确保该文件不是只读的。"
VSCONTROLLER_PROCESS_NOT_FOUND = "无法步入 '%1'。未找到进程。调试器无法找到要调试的进程。"
VSCONTROLLER_EMPTY_FUNCTION_BODY = "无法进入 '%1'。指定的函数为空。无法在空函数上中断。"
VSCONTROLLER_DEBUG_SYMBOL_NOT_FOUND Line0001 = "无法步入 '%1'。无法在模块的 .pdb 文件中找到符号 '%2'。"
VSCONTROLLER_DEBUG_SYMBOL_NOT_FOUND Line0002 = "确认你的调试信息是最新的并且入口点的源代码存在。"
" VSCONTROLLER_DEBUG_SYMBOL_NOT_FOUND Line0003 = "例如，如果您试图进入源代码中未定义的默认构造函数，您将收到此错误。
VSCONTROLLER_DEBUGGER_FAILED_TO_ATTACH = "无法进入 '%1'。Visual Studio 无法附加到此进程。验证 Visual Studio 是否配置为调试本机代码。Visual Studio 返回以下错误：\n'%2'"
VSCONTROLLER_ATTACH_FAILED_WRONG_FRAMEWORK = "无法进入 '%1'。Visual Studio 无法附加到此进程并返回错误代码 0x8013134b。当您加载了不受支持的 .NET 框架时，可能会发生此错误。有关详细信息，请参阅 TestStand 发行说明。 "
VSCONTROLLER_COULD_NOT_OPEN_PDB_FILE = "无法进入 '%1'。无法打开模块 '%2' 的 .pdb 文件。验证 .pdb 文件存在于与 TestStand 正在调用的模块实例相同的目录中。验证 .pdb 文件是使用 TestStand 正在调用的模块实例构建的确切版本。"
VSCONTROLLER_SOURCE_NOT_FOUND = "无法进入 '%1'。无法找到源文件 '%2'。"
VSCONTROLLER_ANOTHER_DEBUGGER_ALREADY_ATTACHED = "无法进入 '%1'。调试器已附加到此进程。如果您手动附加 Visual Studio 调试器，请确保将其设置为调试适当类型的代码（\"Managed\" for . NET 代码，非托管 C++ 代码的 \"Native\"）。
VSCONTROLLER_COUND_NOT_ACCESS_DIA_SDK = "无法进入 '%1'。找不到此版本 Visual Studio 的 DIA CLSID。"
VS_INCORRECT_VERSION Line0001 = "TestStand 不支持与创建此文件的 Visual Studio 版本集成。"
VS_INCORRECT_VERSION Line0002 = "请将解决方案/项目转换为受支持的 Visual Studio 版本。"
VS_UNABLE_TO_CREATE_XML_PARSER = "无法创建 XML 解析器。\n无法解析项目文件。"
VS_SLN_OPEN_FAILED Line0001 = "无法打开解决方案文件。如果解决方案文件来自较新版本的解决方案文件，则会发生这种情况。"
VS_SLN_OPEN_FAILED Line0002 = "Visual Studio 比 TestStand 被配置使用，或者如果 TestStand 被设置为匹配版本"
VS_SLN_OPEN_FAILED Line0003 = "项目文件和项目文件来自比解决方案文件更旧的版本。\n"
VS_SLN_OPEN_FAILED Line0004 = "可以通过适配器配置菜单更改这些配置。"
VS_INVALID_ADAPTER = "此适配器未与 Visual Studio 集成。"
VS_MATCH_VERSION_FAILED = "您正试图匹配使用未安装在此计算机上的 Visual Studio 版本创建的项目文件的版本。"
VS_COULD_NOT_OPEN = "无法打开 Visual Studio 实例。"

;;适配器共享
ADAPTER_STEP_INTO_FAILED = "Step Into 操作失败，原因如下：\n'%1'\n\n执行将继续，就像您执行了 Step Over 操作一样。"

;;许可证管理
NO_LICENSE_FOR_OPERATION = "您的许可证类型不允许此操作。"
INSUFFICIENT_LICENSE_FOR_APP = "您没有启动此应用程序所需的正确许可类型。"
BLOCKED_GUEST_ACCOUNT = "此应用程序不支持您当前使用的操作系统帐户类型。请尝试使用非访客用户帐户登录并运行此应用程序。"
ADDON_LICENSE_REGISTRY_KEY_MISSING = "插件 '%1' 的许可证信息从注册表中丢失。应该在 %2 找到它。"
LICENSE_WIZARD_FAILED = "无法启动许可向导。"

MISMATCHED_BLOCK_STRUCTURE = "序列 '%1' 包含开始或结束未由相应步骤完成的块的步骤。"

LOOKUP_STRING_NOT_FOUND = "找不到：%1"

COMPRESS_OP_FAILED = "无法执行压缩或解压缩操作（代码：%1）。"

;;属性加载器

PROP_LOADER_DUP_STEP_NAME = "序列 '%s' 包含两个或多个使用名称 '%s' 的步骤。\n尝试导入/导出具有重复名称的步骤的属性时操作不明确。"
PROP_LOADER_BAD_FILE_FORMAT = "'%s' 部分附近的文件格式不正确。确保您正确使用了开始和结束标记。"

LOAD_PARAMETERS_FROM_SEQUENCE_NOT_ALLOWED = "SequenceCallModule.LoadParametersFromSequence 无法从序列中加载参数。请先将 SequenceCallModule.UseSequenceParameterPrototype 设置为 False。"

NO_SESSION_MGR = "无法创建会话管理器。验证会话管理器组件是否已正确安装。"

;;输出信息

OUTPUT_MSSG_INVALID_CATEGORY = "你必须分配一个有效的类别。类别名称不能为空。"
OUTPUT_MSSG_INVALID_ICON_NAME = "输出消息图标名称不能为空。"

;;数值限制步骤类型

NUM_LIMIT_INVALID_COMP_TYPE = "无效的比较类型：'%1'"
NUM_LIMIT_INVALID_COMP_TYPE_CONSTANT = "无效的比较类型"

NUM_LIMIT_INVALID_THRESHOLD_TYPE = "无效的阈值类型：'%1'"
NUM_LIMIT_INVALID_THRESHOLD_TYPE_CONSTANT = "无效的阈值类型"

NUM_LIMIT_HIGH_LIMIT_EXPR_ERROR = "上限表达式错误："
NUM_LIMIT_LOW_LIMIT_EXPR_ERROR = "下限表达式错误："
NUM_LIMIT_NOMINAL_VALUE_EXPR_ERROR = "标称值表达式错误："
NUM_LIMIT_THRESHOLD_TYPE_EXPR_ERROR = "阈值类型表达式错误："
NUM_LIMIT_THRESHOLD_TYPE_EXPR_INVALID_TYPE = "阈值类型表达式未评估为有效的阈值类型："
NUM_LIMIT_COMP_TYPE_EXPR_ERROR = "比较类型表达式错误："
NUM_LIMIT_COMP_TYPE_EXPR_INVALID_TYPE = "比较类型表达式未评估为有效的比较类型："
STRING_VAL_STR_VAL_EXPR_ERROR = "预期字符串值表达式错误："

UNABLE_TO_RELOAD_SEARCH_DIRS = "无法重新加载搜索目录。TestStand 正在更新其配置文件。"

STEP_WITH_MISMATCH_ERROR = "第一个不匹配的步骤是 %3 步骤组中索引 %2 处名为 '%1' 的步骤。"

CONNECTION_STRING_FILE_FORMAT_ERROR = "无法从 ConnectionString.ini 文件加载数据链接信息。错误的文件格式。"
NUM_LIMIT_EQT_NOMINAL_NOT_FOUND = "标称值未指定。"
NUM_LIMIT_EQT_THRESHOLD_NOT_FOUND = "未指定阈值类型。"

;;属性错误
RENAME_ATTRIBUTES = "您不能更改属性 PropertyObject 的名称。"

;;线程亲和性错误
NO_VALID_PROCESSORS = "线程关联掩码 0b%1 没有指定任何有效的 CPU。所有 CPU 的线程关联掩码都是 0b%2。"
NON_EXISTENT_PROCESSORS = "线程关联掩码 0b%1 指定了一个不存在的 CPU。所有 CPU 的线程关联掩码都是 0b%2。"

;;翻译错误
ERROR_CONVERTING_TO_SEQ_FILE_FILENAME_DISPLAYED = "尝试将文件 '%1' 转换为 TestStand 序列文件时发生错误。\n\n'%3' 中的 '%2' 回调返回了以下错误：\n"
ERROR_CONVERTING_TO_SEQ_FILE_FILENAME_NOT_DISPLAYED = "使用转换器时发生错误。\n\n'%3' 中的'%2' 回调返回了以下错误：\n"
ERROR_CONVERTING_FROM_SEQ_FILE_FILENAME_DISPLAYED = "试图反向翻译 '%1' 序列文件时发生错误。\n\n'%3' 中的 '%2' 回调返回了以下错误：\n"
ERROR_CONVERTING_FROM_SEQ_FILE_FILENAME_NOT_DISPLAYED = "使用反向转换器时发生错误。\n\n'%3' 中的'%2' 回调返回了以下错误：\n"
UNABLE_TO_REVERSE_TRANSLATE = "无法以指定格式保存序列文件。"
UNEXPECTED_ERROR_DURING_REVERSE_TRANSLATE = "反向翻译时发生意外错误。"

;;数值表示错误
UNABLE_TO_CHANGE_TYPE_INSTANCE_REPRESENTATION = "无法更改类型实例表示。\n类型实例必须与类型定义具有相同的表示。"
UNABLE_TO_CHANGE_ARRAY_ELEMENT_REPRESENTATION = "无法单独更改数组元素表示。\n数组元素继承数组表示。"

BATCH_REPORT_CALLBACK_PARAMETER_CHANGE_DESCRIPTION Line0001 = "\n\n请注意，TestStand 2012 将 ModelData 参数的类型更改为 PreBatch、PostBatch 和 BatchReport 回调，从 NI_BatchModelData 到 NIBatchModelData2。NIBatchModelData2 不再包含数据库或报告相关字段。如果您使用较早版本的 TestStand要创建这些批处理回调并且回调访问任何已删除的字段，您必须执行以下操作之一：\n\n"
BATCH_REPORT_CALLBACK_PARAMETER_CHANGE_DESCRIPTION Line0002 = "1. 将 BatchReport 回调中的 ModelData 参数类型更改为 NI_BatchModelData2 并更新对 NI_BatchModelData2 删除的 ModelData 参数字段的任何引用。请注意，已删除的字段都与数据库日志记录和报告有关，并且等效信息现在是传入 ResultProcessingConfiguration 参数。更新 Batch 回调是推荐的解决方案，前提是您的情况允许您编辑回调。\n\n"
BATCH_REPORT_CALLBACK_PARAMETER_CHANGE_DESCRIPTION Line0003 = "2. 通过使用 Station Options>>Model>> 从 <TestStand Install Directory>\\Components\\Models\\TestStandModels\\TestStand 2010 Process Models (Legacy)\\ 选择使用等效的遗留过程模型工作站模型设置或序列文件属性>>高级>>模型选项设置。\n\n"
BATCH_REPORT_CALLBACK_PARAMETER_CHANGE_DESCRIPTION Line0004 = "3. 通过运行 <TestStand Install Directory>\\Components\\Models\\TestStandModels\\TestStand 2010 Process Models (Legacy)\\LegacyModelSwitcher.exe，用 NI 遗留过程模型完全替换当前 NI 过程模型。 "

CANNOT_ACTIVATE_NON_MEMBER_REPORT = "该报告不能设置为活动报告，因为它不在报告集合中。"

ERROR_CALLING_SEQUENCE = "调用序列 %1 时出错。"

UNABLE_TO_SET_TEMP_FILE_DIRECTORY Line0001 = "无法设置 TestStand 保存 Report.GetTempFile 方法使用 Report.TempFileDirectory 属性创建的文件的目录路径，因为 Report.SetTempFileDirectoryEx 方法之前调用时将 tempFileDirectoryOption 参数设置为 SetTempFileDirectoryOption_NeverOverride(1)。"
UNABLE_TO_SET_TEMP_FILE_DIRECTORY Line0002 = "\n要覆盖 TestStand 保存 Report.GetTempFile 方法创建的文件的目录路径，请使用 Report.SetTempFileDirectoryEx 方法并将 tempFileDirectoryOption 参数设置为SetTempFileDirectoryOption_NeverOverride(1)。"

ERR_RANGE_INVALID_RANGE_STRING_1 = "解析范围元素'%1'时出错。值必须是单个正整数（例如'3'）、范围（例如'0-5'）、指定容器的有效子属性名称或有效的数组元素名称对于指定的属性对象数组。"
ERR_RANGE_OPEN_ENDED_MUST_BE_LAST_1_2 = "解析范围 '%1' 时出错。开放式元素 '%2' 不是列表中的最后一项。"

ERR_STREAM_CLOSED = "操作失败，因为流已关闭。"
ERR_STREAM_DESTROYED = "操作失败，因为流对象已被销毁。"
ERR_STREAM_ALREADY_OPEN = "流已经打开。"
ERR_STREAM_NOT_OPEN = "流未打开。"
ERR_CANNOT_SEEK_BACKWARDS = "无法向后查找。"
ERR_UNIQUIFY_RETRY_LIMIT_EXCEEDED = "试图唯一化 '%2' 时重试限制 (%1) 已超出。"
ERR_UNIQUIFY_INCONSISTENT_WITH_TRUNCATE = "唯一化选项与截断不一致。"
ERR_UNIQUIFY_INCONSISTENT_WITH_APPEND = "唯一化选项与追加不一致。"

ERR_INVALID_FORMAT_1 = "格式 '%1' 无效或不受支持。"

ERR_FIELD_MAPPING_INDEX_OUT_OF_RANGE_1_2_3 = "字段映射 '%1' 指定的索引 (%2) 超出了具有 %3 个字段的指定记录的范围。"

ERR_AUTOPROPS_MISSING_FIELD_1_2 = "‘%1’存在但缺少字段‘%2’。"
ERR_AUTOPROPS_WRONG_FIELD_TYPE_1 = "字段 '%1' 存在但类型错误。"
ERR_AUTOPROPS_WRONG_FIELD_REPRESENTATION_1 = "字段 '%1' 存在但表示错误。"
ERR_AUTOPROPS_EXTRA_FIELDS_1 = "容器 '%1' 有额外的字段。"
ERR_AUTOPROPS_TYPE_DOES_NOT_EXIST_1 = "类型 '%1' 不存在"
ERR_AUTOPROPS_TYPE_NOT_ENUM_1 = "类型 '%1' 存在但不是枚举。"
ERR_AUTOPROPS_WRONG_ENUM_REPRESENTATION_1 = "枚举类型 '%1' 存在但表示错误。"
ERR_AUTOPROPS_WRONG_FLAGS_SETTING_1 = "枚举类型 '%1' 存在但标志设置错误。"
ERR_AUTOPROPS_ENUM_CANNOT_STRICT_SETTING_1 = "枚举类型 '%1' 存在但是是严格的。.NET 枚举是松散的。"
ERR_AUTOPROPS_DOT_NET_STRUCT_PASSING_DISABLED_1 = "枚举类型 '%1' 存在但禁用了 .NET 结构传递。"
ERR_AUTOPROPS_ENUMERATORS_DO_NOT_MATCH_1 = "枚举类型 '%1' 存在但枚举数错误。"
ERR_AUTOPROPS_MISSING_ENUMERATOR_1_2 = "TestStand 枚举 '%1' 缺少枚举器 '%2'。"
ERR_AUTOPROPS_MISSING_ENUMERATOR_MISMATCH_1_2 = "TestStand 枚举 '%1' 存在，但枚举器 '%2' 的数值错误。"
ERR_AUTOPROPS_MULTI_DIMENSIONAL_ARRAYS_NOT_SUPPORTED_1 = "尝试导入 '%1' 时出错\n不支持多维数组。"
ERR_AUTOPROPS_JAGGED_ARRAYS_NOT_SUPPORTED_1 = "尝试导入 '%1' 时出错\n不支持 Jagged 数组。"
ERR_AUTOPROPS_TYPE_NOT_CONTAINER_1 = "类型 '%1' 存在，但不是容器。"
ERR_AUTOPROPS_TYPE_MISMATCH_1_2_3 = "TestStand 属性 '%1' 的类型 '%2' 与 .NET 类型 '%3' 不兼容。"
ERR_AUTOPROPS_CONTAINERS_DO_NOT_MATCH_1_2 = ".NET 结构 '%1' 中的字段数与 TestStand 容器 '%2' 不同"
ERR_AUTOPROPS_ARRAYS_MUST_BE_ZERO_BASED_1 = "数组 '%1' 必须使用从 0 开始的索引。"

[CVI_TOOLERR]
LineTooLong = "文件中的一行超过了支持的最大 %1 字节。"
CouldNotOpenFileForReading = "无法打开文件进行阅读"
ErrorReadingFile = "读取文件时出错"
CouldNotFindUnusedTempFileName = "无法找到未使用的临时文件名"
CouldNotCreateTempFile = "无法创建临时文件"
IncorrectFileFormat = "不正确的文件格式"
UnexpectedEndOfFile = "意外的文件结束"
InvalidIntNumber = "无效整数"
InvalidUIntNumber = "无效的无符号整数"
InvalidDoubleNumber = "无效的浮点数"
InvalidBooleanValue = "无效的布尔值"
MissingSection = "缺少部分"
MissingItem = "缺少物品"
UnRecognizedValue = "无法识别的值"
OperationInProgress = "无法执行请求的操作，因为当前正在进行另一个操作"
TooManyItems = "项目太多"
DuplicateItemOrValue = "重复项或值"
PanelNotAChildOfCorrectPanel = "面板不是正确面板的子面板"
OutOfMemory = "内存不足"
IOError = "输入/输出错误"
AccessDenied = "拒绝访问"
InvalidPath = "无效路径"
DiskFull = "磁盘已满"
NoDescriptionAvailable = "没有可用的描述。"

[LV_调色板_VIS]
OPERATION_REQUIRES_LV_90 = "此操作需要 LabVIEW 2009"

[崩溃恢复]
LOG_FILE_PREFIX = "以下是在 TestStand 应用程序崩溃/挂起时执行注册序列回调时的错误。"
SEQ_FILE_PREFIX = "序列文件路径："
SEQ_NAME_PREFIX = "序列名称："
ERROR_DESC_PREFIX = "错误："
DIALOG_TITLE = "错误"
DIALOG_DESCRIPTION = "执行注册序列回调时发现错误。错误保存在以下文件中：\n"
UNEXPECTED_ERROR_EXECUTING_SEQUENCE = "在序列文件 '%2' 中执行序列 '%1' 时出现意外错误。"
