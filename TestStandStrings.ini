;; TestStandStrings.ini - TestStand 字符串（通用字符串、通用字符串和工具字符串）
;;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"

[SEARCH_FILES]
LOADING_FILE = "加载文件："
SEARCHING_FILE = "搜索文件："
BUILDING_LIST_OF_FILES = "构建要搜索的文件列表"

[EXPRESSIONS]
COLUMN = "列"

[EVAL_VERSION_MSG]
EVAL_VERSION_MSG_TITLE = "请注意："
EVAL_VERSION_MSG_TEXT Line0001 = "这是 TestStand 的评估版。它将在 30 天后过期。"
EVAL_VERSION_MSG_TEXT Line0002 = "TestStand 的发布版本可用；但是，某些功能将在 1 小时后禁用 "
EVAL_VERSION_MSG_TEXT Line0003 = "使用。此外，执行时间限制为 10 分钟。"
BUY_ONLINE = "在线购买 TestStand"
OK ="确定"

[TESTOBJECT EDITOR]
DEFAULT_COLUMNHEADING = "名称、类型、值"
CONFIRM_DELETE_TITLE = "确认删除"
CONFIRM_DELETION_MSG = "你确定要删除'%1'吗？"
INVALID_DROPTARGET_MSG = "无法移动 %1：目标项目是源项目的子项目。"
UNTITLED = "无标题"
OBJECT_NAME_NOT_IDENTIFIER = "'%1' 不是有效名称。属性对象名称只能包含字母、数字和下划线，不能包含空格或以数字开头。"
OBJECT_NAME_RESERVED = "'%1' 已保留。它不能用作属性对象名称。"
OBJECT_NAME_EXISTS = "属性对象名称 '%1' 已经存在。"

[REMOTE SEQUENCE CALL]
STATUS_STARTING_EXECUTION= "开始远程序列..."
STATUS_START_EXECUTION= "远程序列已启动"
STATUS_TERMINATING_EXECUTION= "正在终止远程序列..."
STATUS_ABORTING_EXECUTION= "中止远程序列"
STATUS_EXIT_EXECUTION= "远程序列完成"
STATUS_EXECUTING= "正在执行远程序列..."
STATUS_TRACING= "远程跟踪：步骤 "

[VI_PACKAGER]
TOOLMENU_ITEM = "为运行时分发组装测试 VI..."
WINDOW_TITLE = "为运行时分发组装测试 VI"
TOOL_MSG Line0001 = "对于使用 LabVIEW 标准原型适配器的选定序列文件中的所有步骤，"
TOOL_MSG Line0002 = "此实用程序将测试 VI 保存在相对于目标目录的正确位置，并保存所有子 VI、运行时菜单和外部 "
TOOL_MSG Line0003 = "子程序到单独的 VI 库（目标目录中的 SupportVIs.llb）。您可以选择 "
TOOL_MSG Line0004 = "从所有 VI 中删除图表。"
FILE_DIALOG_PROMPT = "请选择目标目录："
DIAGRAMS_PROMPT = "你想保存没有图表的 VI 吗？"
CONTINUE_BTN = "继续"
CANCEL_BTN = "取消"
YES_BTN = "是"
OVERWRITE_MSG= "VI:%s 已经存在。覆盖它？"
YES_ALL_BTN = "全部同意"
NO_BTN = "否"
ADD_BTN = "添加"
SUCCESS_MSG = "VI 打包成功。记得将目标目录添加到分发安装中的 TestStand 搜索路径列表中。"
ERROR_MSG = "打包 VI 时出错。"
OK_BTN = "确定"
SELECT_DIR_BTN = "选择"
NO_VIS_MSG = "这些序列文件不包含使用 LabVIEW 标准原型适配器的步骤，或者指定的路径无效。"
INVALID_VIS_MSG Line0001 = "该序列文件包含一个或多个使用 LabVIEW 标准原型适配器的步骤"
INVALID_VIS_MSG Line0002 = "但路径规范无效。"
NO_VIS_TITLE = "组装测试 VI"
READING_VI_PATH_MSG = "读取 VI 路径"
OVERWRITE_SOURCE_MSG Line0001 = "您不能将 VI 汇编到与源 VI 相同的目录中。\n\n"
OVERWRITE_SOURCE_MSG Line0002 = "您正在尝试将以下源 VI 汇编到同一位置。\n\n"
OVERWRITE_SOURCE_MSG Line0003 = "按‘确定’选择另一个目录。"
DUPLICATE_PATH_ERROR = "以下 VI 的路径重复：\n"
OVERWRITE_DUP_PATH Line0001 = "VI:%s 已经存在。\n"
OVERWRITE_DUP_PATH Line0002 = "覆盖它？"
MULT_WINDOW_TITLE = "选择序列文件"
PACKAGING_MSG = "打包VI"
ASK_DYNAMIC_MSG Line0001 = "如果测试使用 VI 服务器动态调用 VI，\n"
ASK_DYNAMIC_MSG Line0002 = "您必须手动添加动态调用的 VI。\n"
USING_DYNAMIC_BTN="添加动态 VI"
NOT_USING_DYNAMIC_BTN="跳过动态VI"
DYNAMIC_MSG Line0001 = "如果您使用 VI 服务器动态调用 VI，那么您必须手动添加这些 VI，以便它们\n"
DYNAMIC_MSG Line0002 = "已打包。点击浏览按钮找到一个VI，然后修改相对路径并\n"
DYNAMIC_MSG Line0003 = "单击添加按钮将 VI 添加到包中。按继续按钮将 VI 打包\n"
VIS_IN_PACKAGE_MSG = "这个包中包含的顶级 VI 是：\n"
ABS_PATH_LABEL = "绝对路径"
REL_PATH_LABEL = "相对路径"
BROWSE_BTN = "浏览"

[DATABASE_CONTEXT_SUBMENU]
MENU_NAME = "数据库"

[DATABASE_TOOL_MENU]
DATABASE_SUBMENU = "数据库"
IMPORT_EXPORT_DESCRIPTION = "导入/导出属性..."
DATABASE_VIEW_DESCRIPTION = "数据库查看器..."

[DATABASEOPTIONS]
DATABASE_OPTIONS_MENU = "数据库选项..."
ACCESS ="访问"
ADD = "添加"
Add Missing Items  = "添加缺失项"
ALL_RESULTS = "所有结果"
ALL_RESULTS_EXPRESSION = "真"
ALLOW_EDITING_OF_SCHEMA = "允许编辑模式(&W)"
FILE_NAME_TITLE = "文件名="
OK = "&确定"
APPLY="应用"

WARNING = "警告"
GENERIC_ERROR_TITLE = "数据库选项"

ALLOW_EDITING_SCHEMA_WARNING Line0001 = "您正在尝试编辑 TestStand 安装的模式。未来版本的 TestStand 可能会覆盖 "
ALLOW_EDITING_SCHEMA_WARNING Line0002 = "您对架构所做的任何更改。而是使用上下文菜单中的复制选项来复制所选架构。"
ALLOW_EDITING_SCHEMA_WARNING Line0003 = "对模式的新副本进行更改并检查新模式以使其成为默认模式。未来 "
ALLOW_EDITING_SCHEMA_WARNING Line0004 = "TestStand 的版本不会覆盖新模式。"

ON_THE_FLY_FOREIGN_KEY_WARNING Line0001 = "您正在尝试将动态数据库日志记录与使用存储过程语句的架构一起使用，或者"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0002 = "不使用 INSERT 命令的命令语句。您不能为外键定义约束"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0003 = "引用 UUT 结果语句中的主键或步骤结果中的外键的步骤结果语句"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0004 = "引用自己主键的语句。\r\n\r\n"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0005 = "如果您为这些类型的外键定义约束，将会发生错误，因为即时数据库"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0006 = "记录器无法在执行之前执行创建包含主键的记录的语句"
ON_THE_FLY_FOREIGN_KEY_WARNING Line0007 = "创建包含外键的记录的语句。"

ORACLE_BINARY_DATA_LOGGING_WARNING Line0001 = "您正在尝试使用具有记录二进制数据的模式的 Oracle 数据库。您可能会遇到错误 "
ORACLE_BINARY_DATA_LOGGING_WARNING Line0002 = "使用当前数据库选项设置，当您启用执行之间的共享数据链接时"
ORACLE_BINARY_DATA_LOGGING_WARNING Line0003 = "在数据库选项对话框的日志记录/数据链接选项卡上选择并禁用使用事务处理选项 "
ORACLE_BINARY_DATA_LOGGING_WARNING Line0004 = "box.\r\n\r\n"
ORACLE_BINARY_DATA_LOGGING_WARNING Line0005 = "完成以下步骤之一以防止发生此错误：\r\n"
ORACLE_BINARY_DATA_LOGGING_WARNING Line0006 = "1. 在数据库选项对话框的数据链接选项卡上禁用在执行之间共享数据链接选项。\r\n"
ORACLE_BINARY_DATA_LOGGING_WARNING Line0007 = "2. 如果您没有使用动态数据库日志记录，请启用数据链接上的使用事务处理选项"
ORACLE_BINARY_DATA_LOGGING_WARNING Line0008 = "数据库选项对话框的选项卡。"

ORACLE_BINARY_DATA_LOGGING_ERRORPROVIDER Line0001 = "您正在尝试将 Oracle 数据库与记录二进制数据的模式一起使用。\r\n您可能会遇到错误 "
ORACLE_BINARY_DATA_LOGGING_ERRORPROVIDER Line0002 = "当您启用\r\n执行之间的共享数据链接时使用当前数据库选项设置 "
ORACLE_BINARY_DATA_LOGGING_ERRORPROVIDER Line0003 = "选项并禁用使用事务处理选项。"

on_fly_readonly_locktype_warning_on_ok line0001 ="锁定类型是在选定架构中的一个或多个语句中设置为仅读取的"
ON_FLY_READONLY_LOCKTYPE_WARNING_ON_OK Line0002 = "外键依赖于语句 {0} 并为数据库日志记录启用了即时使用。\r\n"
ON_FLY_READONLY_LOCKTYPE_WARNING_ON_OK Line0003 = "动态数据库记录器可能无法更新记录集，因为语句 {0} 的锁定类型设置为只读。"

ON_FLY_READONLY_LOCKTYPE_WARNING_ERRORPROVIDER Line0001 = "当所选架构中的一个或多个语句具有外键时，锁定类型设置为只读\r\n"
ON_FLY_READONLY_LOCKTYPE_WARNING_ERRORPROVIDER Line0002 = "对语句 {0} 的依赖，并为数据库日志记录启用了即时使用。\r\n"
ON_FLY_READONLY_LOCKTYPE_WARNING_ERRORPROVIDER Line0003 = "即时数据库记录器可能无法更新记录集。"

MULTIPLE_PRIMARY_KEY_WARNING Line0001 = "单个语句不支持多个主键。在所选语句中，主键设置在列 '{0}' 中。\r\n"
MULTIPLE_PRIMARY_KEY_WARNING Line0002 = "因此无法在列 '{1}' 中设置主键。"

UNIQUE_NAME_WARNING = "具有指定名称 {1} 的 {0} 已经存在。指定的 {0} 名称被唯一化为 {2}。"

EMPTY_NAME_ERROR = "{0} 名称不能为空。"
EMPTY_FOREIGN_KEY_NAME = "外键语句名称不能为空。"
COLUMN_SIZE_ZERO_WARNING = "对于指定的列类型，列大小不能为 0。列大小设置为默认值。"
COLUMN_SIZE_EMPTY_WARNING = "对于指定的列类型，列大小不能为空。列大小设置为默认值。"
COLUMN_SIZE_EXCEEDED_LIMIT = "给定的列大小已超出限制。将大小重置为最大可能值。"
COLUMN_SIZE_INVALID_FORMAT Line0001 = "给定的列大小无效。列大小应该是一个数字。\r\n"
COLUMN_SIZE_INVALID_FORMAT Line0002 = "列大小设置为默认值。"

FOREIGN_KEY_DEPENDENCY_WARNING Line0001 = "在选定的架构中，语句 {0} 被设置为 {0} 上方语句的一个或多个列中的外键。"
FOREIGN_KEY_DEPENDENCY_WARNING Line0002 = "数据库记录器将无法生成外键。\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING Line0003 = "完成以下步骤之一以防止出现此警告：\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING Line0004 = "1. 重新排列语句，使设置为外键的语句位于从属语句之上。\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING Line0005 = "2. 重新排列语句，使语句设置为外键日志的数据库表在相关语句记录数据之前被记录。"
FOREIGN_KEY_DEPENDENCY_WARNING Line0006 = "\r\n请参阅列->外键->有效外键语句帮助主题了解更多详情。"

FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_UP Line0001 = "所选语句 {0} 无法向上移动，因为 {0} 中的一个或多个列的外键设置为 {1}。\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_UP Line0002 = "{1} 是唯一记录到 {0} 上方数据库表 {2} 的语句。\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_UP Line0003 = "删除语句 {0} 中的外键依赖项并重试该操作。"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_UP Line0004 = "\r\n请参阅列->外键->有效外键语句帮助主题了解更多详情。"

FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_DOWN Line0001 = "所选语句 {0} 无法向下移动，因为 {0} 被设置为语句 {1} 中一个或多个列中的外键。"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_DOWN Line0002 = "{0} 是唯一记录到 {1} 上方的数据库表 {2} 的语句。\r\n"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_DOWN Line0003 = "删除语句 {1} 中的外键依赖项并重试该操作。"
FOREIGN_KEY_DEPENDENCY_WARNING_ON_MOVING_DOWN Line0004 = "\r\n请参阅列->外键->有效外键语句帮助主题了解更多详情。"

FOREIGN_KEY_DEPENDENCY_ERRORPROVIDER Line0001 = "您选择了记录到表 {1} 的外键语句，但没有任何语句"
FOREIGN_KEY_DEPENDENCY_ERRORPROVIDER Line0002 = "\r\n以上 {0} 正在记录到表 {1}。数据库记录器将无法生成 "
FOREIGN_KEY_DEPENDENCY_ERRORPROVIDER Line0003 = "\r\n语句 {0} 的外键。"

FOREIGN_KEY_STATEMENT_NOT_FOUND_ERRORPROVIDER = "在所选模式的语句列表中找不到指定的外键语句。"
FOREIGN_KEY_STATEMENT_NOT_FOUND = "在所选模式的语句列表中找不到指定的外键语句。"

EXPECTED_PROPERTIES_INVALID = "预期属性文本无效。"
STATEMENT_TYPES_TO_LOG_INVALID = "记录文本的类型无效。"

AND_SIZE = "尺寸"
APPLY_TO = "应用到"
AUTO_GENERATED/COUNTER = "自动生成/计数器"
AUTO_GENERATED = "自动生成"
BATCH_OPTIMISTIC = "批量优化"
BINARY = "二进制"
BOOLEAN = "布尔值"
BROWSE = "浏览"
BSTR = "文本/字符串"
BUILD = "建造..."
BUILD_SQL_FILE = "&创建 .sql 文件..."
CANCEL = "&取消"
CHECK TO SET DEFAULT SCHEMA = "检查以设置默认模式。"
CLEAR_ALL_SCHEMA_TABLES = "清除所有模式表"
CLIENT ="客户端"
COLUMN = "列"
COLUMNS = "列/参数"
COLUMN/PARAMETER = "列/参数"
COLUMNINPUT = "输入（到数据库）"
COLUMNOUTPUT = "输出（来自数据库）"
COLUMNINOUT = "输入/输出"
COLUMNRETURNVALUE = "返回值"
COLUMNS_IN = "列在"
COLUMNS/PARAMETERS = "列/参数"
;;;;;;;;;;;;;;;;{n} 是占位符，不应本地化;;;;;;;;;;;;;;;;
GENERATED_SQL_WARNING_MESSAGE_WITH_CONFLICTS = "警告 - 如果您直接执行生成的 \"SQL\" 命令而不解决以下冲突（或可能存在但未在下文提及的任何其他冲突），则生成的 \"SQL\" 命令可能无法按预期工作："
GENERATED_SQL_WARNING_MESSAGE_WITHOUT_CONFLICTS = "警告 - 如果您直接执行生成的 \"SQL\" 命令，它们可能无法按预期工作。请确保解决所有存在的冲突。"
MULTIPLE_CREATE_TABLE_SQL_COMMANDS_EXIST = "表 '{0}' 存在多个 'CREATE TABLE' SQL 命令实例。请只保留该命令的一个有效实例并删除其他实例。"
MULTIPLE_CREATE_PROCEDURE_SQL_COMMANDS_EXIST = "过程 '{0}' 存在多个 'CREATE PROCEDURE' SQL 命令实例。请只保留该命令的一个有效实例并删除其他实例。"
MULTIPLE_DROP_TABLE_SQL_COMMANDS_EXIST = "表 '{0}' 存在 'DROP TABLE' SQL 命令的多个实例。请只保留该命令的一个有效实例并删除其他实例。"
MULTIPLE_DROP_PROCEDURE_SQL_COMMANDS_EXIST = "过程 '{0}' 存在多个 'DROP PROCEDURE' SQL 命令实例。请只保留该命令的一个有效实例并删除其他实例。"
MULTIPLE_CLEAR_TABLE_SQL_COMMANDS_EXIST = "表 '{0}' 存在多个 'CLEAR TABLE' SQL 命令实例。请只保留该命令的一个有效实例并删除其他实例。"
COLUMN_NOT_FOUND = "在表 '{1}' 中找不到列 '{0}'"
COLUMN_SIZE_MISMATCH = "表 '{1}' 中的列 '{0}' 的最大大小 '{2}' 小于当前架构中指定的大小 '{3}'。"
COLUMN_TYPE_MISMATCH = "表 '{1}' 中的列 '{0}' 的数据类型不正确 '{2}'。应为 '{3}'。"
PROCEDURE_NOT_FOUND = "未找到过程 '{0}'。"
MISSING_SQL_TEXT = "命令文本不是有效的 SQL 命令文本。"
COMMAND = "命令"
COMMAND_TEXT = "文本命令"
COMMENT = "注释"
COMPONENT_PATH_WARNING Line0001 = "数据链路条目包含对 %1 目录或其子目录中文件的引用。"
COMPONENT_PATH_WARNING Line0002 = "您应该将此文件的副本放在 %2 目录之一中，然后在数据链路中使用它。"
COMPONENT_PATH_WARNING Line0003 = "未来版本的 TestStand 可能会替换 %1 目录中的文件。"
CONNECTION_ERROR = "连接到数据源时出错，原因："
CONNECTION_STRING = "连接字符串表达式"
EXPECTED_PROVIDER_ABSENT = "此文件类型所需的数据库提供程序 '%1' 的 '%2' 位版本在此计算机中不存在。安装此提供程序或指定一个连接字符串，该字符串在新数据链接中使用不同的提供程序对话。"
ACCESS_64BIT_ERROR = "请参阅"将 Access 数据库与 TestStand 64 位结合使用"知识库文章，了解有关如何解决此错误的更多信息。"
USING_INCORRECT_ACCESS_PROVIDER = "指定的访问提供程序/驱动程序在 64 位中不可用。使用 64 位提供程序/驱动程序配置连接字符串以解决此错误。"
COPY = "复制"
COPY_OF = "备份"
CURSOR_LOCATION = "光标位置"
CURSOR_TYPE = "光标类型"
CUT ="剪切"
DATA_LINK_OPTIONS = "数据链接选项"
;;;;;;;;;;;;;;;;{n} 是占位符，不应本地化;;;;;;;;;;;;;;;;
DATA_SYNTAX_NOT_FOUND = "所选数据类型 ({0}) 的 SQL 语法{1}无法从提供商处获取。"
DATABASE_OPTIONS = "数据库选项"
DATABASE_MANAGEMENT_SYSTEM = "数据库管理系统"
DATETIME = "日期/时间"
DELETE = "删除"
;;;;;;;;;;;;;;;;%1 和 %2 是占位符，不应本地化;;;;;;;;;;;;;;;;
DELETE_CONFIRMATION = "您确定要删除 %1 %2 吗？"
DIRECTION = "&方向"
DISABLE_DATABASE_LOGGING = "禁用数据库日志(&D)"
DLL_LOAD_ERROR = "无法加载文件 BuildConnectionString.dll 或缺少函数，错误号"
DOUBLE = "双精度"
Done = "&完成"
DROP_ALL_SCHEMA_TABLES_AND_OR_PROCEDURES = "删除所有模式表和/或过程"
DUPLICATE = "重复"
DYNAMIC = "动态"
LOGGING_AND_DATALINK_OPTIONS = "记录/数据链接选项"
EDIT_MISSING_VALUES = "您没有指定一些必需的值。"
EXPECTED_PROPERTIES = "预期属性"
EXCLUDE_FLOW_CONTROL = "排除流量控制"
EXPRESSION = "&Value to Log"
VALUE = "&值"
FIX = "&修复"
FLOAT = "浮动"
FOREIGN_KEY = "所有者密钥"
FORMAT = "&格式"
FORWARD_ONLY = "仅转发"
GENERATE_SQL = "&生成 SQL"
REVALIDATE = "&重新生效"
ADD_MISSING_ITEMS = "添加缺少的项目"
DROP_ALL_SCHEMA_TABLES = "删除所有模式表"
GET_VALUE_FROM_RECORDSET = "从记录集中获取值"
GET_VALUE_FROM_OUTPUT_PARAMETER = "从输出参数中获取值"
GET_VALUE_FROM_RETURNVALUE = "从返回值中获取值"
GET_VALUE_FROM_EXPRESSION = "使用表达式值"
GUID = "GUID"
GUID_DATATYPE_HELP = "对于 GUID 主键，列/参数类型必须是字符串或 GUID"
FORMAT = "&帮助"
IGNORE_PASSED/DONE/SKIPPED = "排除通过/完成/跳过"
IGNORE = "&忽略"
INCLUDE_ADDITIONAL_RESULTS = "包括其他结果"
INCLUDE_EXECUTION_TIMES = "包括执行时间"
INCLUDE_OUTPUT_VALUES = "包括测量值"
INCLUDE_STEP_RESULTS = "包括步骤和结果"
INCLUDE_TEST_LIMITS = "包括测试限制"
INTEGER = "整数"
KEYSET = "键组"
LOAD_FILE = "&本地 .udl 文件..."
LOCK_TYPE = "位置&k类型"
LOGGING_OPTIONS = "记录选项"
MEASUREMENT = "测量"
MEASUREMENT_RESULTS = "测量结果"
MULTIPLE_TABLES_DEFINED = "有多个语句记录到同一个表。您应该在执行生成的 SQL 语句后重新验证架构。"
MYSQL = "MySQL"
NAME = "&名称"
NEW = "新建"
;;;;;;;;;;;;;;;;{n} 是占位符，不应本地化;;;;;;;;;;;;;;;;
NO_COLUMNS_DEFINED = "没有定义列。"
NO_MISSING_ITEMS = "没有表明缺少表或列的错误"
NO_STATEMENTS_DEFINED = "没有为架构定义语句。"
NOT_A_KEY = "不是钥匙"
ERROR_MESSAGE_DESCRIPTION = "启动对话框时出现以下错误：\r\n"
COULD_NOT_RELOAD_SCHEMAS = "无法从 '{0}' 模式文件加载 NI 数据库模式。\r\n文件路径：{1}"
COULD_NOT_LOAD_SCHEMAS = "无法从配置文件 {0} 加载 NI 数据库模式。\r\n有关详细信息，请参阅帮助主题。"
COULD_NOT_LOAD_OPTIONS = "无法从配置文件 {0} 加载数据库选项。因此将选项设置为默认值。\r\n"
;;;;;;;;;;;;;;;;{n} 是占位符，不应本地化;;;;;;;;;;;;;;;;
NUMBER_OF_COLUMNS_MISMATCH = "SQL 命令文本中的列数与模式中定义的列数/参数不匹配。"
NUMBER_OF_PARAMETERS_MISMATCH = "SQL 命令文本中参数标记的数量与模式中定义的列/参数数量不匹配。"
OBJECT_TYPE_MISMATCH = "正在粘贴的对象类型与所选类型不匹配。"
ALLOW_EDITING_DISABLED = "不允许编辑选定的模式。通过在模式面板中选中"允许编辑模式"来启用编辑。"
INVALID_INPUT_STRING = "输入的输入字符串无效。"
OPEN="打开"
OPTIMISTIC = "乐观"
ORACLE ="Oracle"
PARAMETER = "参数"
PARAMETERS_IN = "参数输入"
PARENT="父"
PASSED/DONE_ONLY = "通过/仅完成"
PASTE = "粘贴"
PESSIMISTIC = "封闭式"
PRECONDITION = "先决条件"
PRIMARY_KEY = "主要钥匙"
;;;;;;;;;;;;;;;;{n} 是占位符，不应本地化;;;;;;;;;;;;;;;;
PRIMARY_KEY_NOT_FOUND = "列 '{0}' 不是表 '{1}' 中的主键"
READ_ONLY = "只读"
RECORDSET = "记录集"
RELOAD_BUTTON = "&Reload NI Schemas..."
RELOAD_DIALOG_NAME = "重新加载 NI 模式"
NI_SCHEMAS = "NI &Schemas"
RELOAD_CONFIRMATION Line0001 = "重新加载默认 NI 模式将删除名称中带有 (NI) 的所有模式，并将选定版本的默认 NI 模式添加到模式面板。对现有 NI 模式所做的任何修改都将丢失。\r\ n\r\n选择要重新加载的默认 NI 架构版本"
RELOAD_2016_TO_2019 = "2016 到 2019"
RELOAD_2012_TO_2014SP1 = "2012 到 2014 SP1"
RELOAD_41_TO_2010SP1 = "4.1 到 2010 SP1"
RELOAD_2x_TO_40 = "2.x 到 4.0"
RELOAD_2020_OR_LATER = "2020 年及以后"
RESULT_FILTERING_EXPRESSION = "结果过滤表达式"
SAVE_FILE = "&保存 .udl 文件..."
SCHEMA = "架构"
SCHEMAS = "模式"
CHECKED_SCHEMA = "检查模式："
SCHEMA_NOT_FOUND Line0001 = " - 在当前配置中找不到请求的架构名称。"
SCHEMA_NOT_FOUND Line0002 = "这可能意味着 National Instruments 默认模式已被当前版本的 Teststand 替换，或者数据库选项配置文件已损坏。"
SCHEMA_NOT_FOUND Line0003 = "重新配置数据库选项。"
SCHEMA_VALIDATION = "模式验证 - "
SELECT = "选择"
SELECT_DATA_LINK_FILE = "选择数据链接文件"
SAVE_DATA_LINK_FILE = "保存数据链接文件"
SELECT_TYPES_TO_LOG = "为语句选择所需的类型"
SELECT_EXPECTED_PROPERTIRES = "为语句选择所需的属性"
SELECT_STATEMENT = "选择声明&lect"
SELECT_SQL_FILE = "选择 SQL 文件"
SAVE_SQL_FILE = "保存 SQL 文件"
SERVER = "SERVER "
SHARE_DATA_LINK_BETWEEN_EXECUTIONS = "在执行之间共享数据链接&k"
SIZE = "&大小（以字节为单位）"
SMALLINT = "小整数"
BIGINT = "大整数"
UBIGINT = "无符号大整数"
SQL_FILES = "SQL 文件"
SQL_SERVER = "SQL服务器"
SQL_STATEMENT = "SQL语句"
SQL_TOOLS = "SQL &工具"
STATEMENT="声明"
STATEMENT_COMMAND = "命令"
STATEMENT_PROCEDURE = "存储过程"
STATEMENTS="声明"
STATEMENTS_IN = "语句在"
STATIC = "静态"
STEP = "步骤"
STEP_RESULT = "步骤结果"
STEP_RESULT_PROPERTY = "属性结果"
STORE_GUID_VALUE = "存储 GUID 值"
STORE_GUID = "存储 GUID 值"
STRING (BSTR) = "字符串 (BSTR)"
STRING (VARCHAR) = "字符串 (VarChar)"
SYBASE = "资料库"
DATABASE_OPTIONS_DIALOG_ERROR = "尝试使数据库选项对话框成为应用程序模态时发生错误。"
DATALINK_BUILD_ERROR = "无法启动\"数据链接属性\"对话框。"
ERROR_NUMBER = ", 错误号 "
USE_UDL_FILE_ERROR = "无法使用 UDL 文件。"
LOAD_UDL_FILE_ERROR = "无法加载 UDL 文件。"
SAVE_UDL_FILE_ERROR = "无法保存 UDL 文件。"
LOGGING_DATALINK_ERROR = "记录/数据链接选项卡错误/警告："
SCHEMA_TAB_ERROR = "架构选项卡错误/警告："
SYNTAX_ERROR_PREFIX = "所选架构：{0}\r\n"
SYNTAX_ERROR_STATEMENT_TEXT = "命令文本"
SYNTAX_ERROR_STATEMENT_PRECOND = "先决条件"
SYNTAX_ERROR_COLUMN_TEXT = "表达式"
SYNTAX_ERROR_COLUMN_PRECOND = "先决条件"
MESSAGE_CATEGORY = "类别"
DESCRIPTION_MESSAGE = "描述"
ERRORS_AND_WARNINGS = "错误和警告"
ERRORS_ONLY = "仅限错误"
WARNINGS_ONLY = "仅警告"
MESSAGE_LEVEL = "&消息级别"

SYNTAX_ERROR_PROMPT = "你想纠正这个问题吗？"
TABLE = "表"
TABLE_NOT_FOUND = "未找到表 '{0}'。"
UNABLE_TO_VALIDATE_PROCEDURE = "无法验证过程 '{0}'，因为在数据库中找不到对应于当前语句的表。"
TABLES = "表格"
TEXT = "文本"
DIFFERENCES_FOUND = "将架构与数据源进行比较后发现以下差异。"
TRAVERSE_OPTIONS_BUTTON = "&遍历选项..."
TRAVERSE_OPTIONS = "遍历选项"
TYPE = "类型&e"
PRIMARY_TYPE = "类别&类型"
TYPES_TO_LOG = "类型&s记录"
UDL_FILES = "UDL 文件 (*.udl)"
UDL_READ_ERROR = "无法从 .udl 文件读取，验证格式，错误号："
UDL_WRITE_ERROR = "无法保存到 .udl 文件，错误号："
UNSPECIFIED = "未指定"
USE_FILE = "使用&e .udl 文件..."
USE_ON_THE_FLY_LOGGING = "使用动态日志"
USE_TRANSACTION_PROCESSING = "使用交易&处理"
UUT = "UUT"
UUT_RESULT = "UUT 结果"
VALIDATE = "&验证..."
VIEW = "&查看数据"
Window = "窗口"
Err_InvalidDBConfigFile = "%s 文件包含无效信息。\n删除文件并重新配置数据库选项。"
Err_FileNotFound = "找不到 {0} 文件。"
IMPORT_DATABASE_OPTIONS_SCHEMA = "导入数据库选项架构"
EXPORT_DATABASE_OPTIONS_SCHEMA = "导出数据库选项架构"
IMPORT = "导入"
EXPORT ="出口"
EXPORT_SCHEMA = "导出模式"
EXPORT_OPTION = "导出选项"
EXPORT_ALL_SCHEMAS = "导出所有模式(&A)"
EXPORT_SELECTED_SCHEMA = "导出选定模式(&S)"
DATA_FILES = "数据文件 (*.ini)"
MOVE_UP = "上移"
MOVE_DOWN = "下移"
NO_SCHEMAS_FOUND = "在所选文件中未找到架构。"
CONNECTION_NAME = "（来自数据库选项）"
UNKNOWN_DBMS_TYPE = "未知的 DBMS 类型"
DATALINK_SAVE_ERROR = "连接字符串是对数据链接文件的引用。您不能在新的数据链接文件中保存引用。"
OTF_TRANSACTION_PROCESSING_CONFLICT = "您正在尝试启用使用即时日志记录和使用事务处理。当您启用使用即时日志记录时，使用事务处理选项不可用。您要继续吗？"

;;错误对话框
ERROR_MESSAGE_TITLE = "数据库选项中的错误/警告"
DONE = "&完成"
NEXT = "&下一步"
BACK = "&返回"

CONTROL_COLUMN = "控制"
DESCRIPTION_COLUMN = "描述"
FIX_COLUMN = "修复"
STATEMENT_COLUMN = "声明"
COLUMN_COLUMN = "列"

;;这些是在错误对话框中没有显示的快捷方式编写的
CONNECTION_STRING_CONTROL = "连接字符串表达式"
RESULT_FILTERING_EXPRESSION_CONTROL = "结果过滤表达式"
PRECONDITION_CONTROL = "先决条件"
COMMAND_TEXT_CONTROL = "命令文本"
LOCK_TYPE_CONTROL = "锁定类型"
FOREIGN_KEY_CONTROL = "外键"
EXPECTED_PROPERTIES_CONTROL = "预期属性"
TYPES_TO_LOG_CONTROL = "记录类型"
TYPE_CONTROL = "类型"
FILTER = "&过滤器"

INFORMATION_MESSAGE = "数据库选项中没有错误和警告。"

[DATABASEOPTIONS_SCHEMA_COMMENT]
;;模式的帮助文本，名称应与模式名称匹配

Generic Recordset (NI) Line0001 = "此模式使用 SELECT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。此模式使用主键的自动递增字段。"
Generic Recordset (NI) Line0002 = "您不能将此模式与 Oracle 一起使用，因为 Oracle 不支持自动递增字段。SELECT 语句使用'TOP 1'子句通过阻止记录集访问数据库中的现有记录来提高性能。 \r\n\r\n"
Generic Recordset (NI) Line0003 = "架构按如下方式处理结果：\r\n"
Generic Recordset (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
Generic Recordset (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
Generic Recordset (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
Generic Recordset (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
Generic Recordset (NI) Line0008 = "- 将通用属性信息记录到PROP_RESULT。\r\n"
Generic Recordset (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
Generic Recordset (NI) Line0010 = " 作为字符串值。\r\n"
Generic Recordset (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
Generic Recordset (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
Generic Recordset (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
Generic Recordset (NI) Line0014 = "- 记录数字限制测试和多数字限制测试\r\n"
Generic Recordset (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

Generic Insert (NI) Line0001 = "该架构使用 INSERT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。该架构为主键值生成唯一的 GUID 值。\r\n"
Generic Insert (NI) Line0002 = "\r\n"
Generic Insert (NI) Line0003 = "架构处理结果如下：\r\n"
Generic Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
Generic Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
Generic Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
Generic Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
Generic Insert (NI) Line0008 = " - 将通用属性信息记录到 PROP_RESULT。\r\n"
Generic Insert (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
Generic Insert (NI) Line0010 = " 作为字符串值。\r\n"
Generic Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
Generic Insert (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
Generic Insert (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
Generic Insert (NI) Line0014 = "- 记录数值极限测试和多重数值极限测试\r\n"
Generic Insert (NI) Line0015 = " 结果为 PROP_NUMERICLIMIT。\r\n"

SQL Server Stored Proc (NI) Line0001 = "此架构使用存储过程语句来记录结果并仅支持与 Microsoft SQL Server 一起使用。此架构为主键值生成唯一的 GUID 值。\r\n"
SQL Server Stored Proc (NI) Line0002 = "\r\n"
SQL Server Stored Proc (NI) Line0003 = "架构按如下方式处理结果：\r\n"
SQL Server Stored Proc (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
SQL Server Stored Proc (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
SQL Server Stored Proc (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
SQL Server Stored Proc (NI) Line0007 = "- 将属性结果记录到表中，如下所示:\r\n"
SQL Server Stored Proc (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
SQL Server Stored Proc (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
SQL Server Stored Proc (NI) Line0010 = " 作为字符串值。\r\n"
SQL Server Stored Proc (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
SQL Server Stored Proc (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
SQL Server Stored Proc (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
SQL Server Stored Proc (NI) Line0014 = "- 记录数值限制测试和多重数值限制测试\r\n"
SQL Server Stored Proc (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

Oracle (NI) Line0001 = "该模式使用 SELECT 语句记录结果并仅支持与 Oracle 一起使用。该模式使用数据库序列生成主键值。\r\n"
Oracle (NI) Line0002 = "\r\n"
Oracle (NI) Line0003 = "架构处理结果如下：\r\n"
Oracle (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
Oracle (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
Oracle (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
Oracle (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
Oracle (NI) Line0008 = " - 将一般属性信息记录到 PROP_RESULT。\r\n"
Oracle (NI) Line0009 = " - 将字符串、数字和布尔值记录到\r\n"
Oracle (NI) Line0010 = " PROP_RESULT 作为字符串值。\r\n"
Oracle (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
Oracle (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
Oracle (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 \r\n"
Oracle (NI) Line0014 = " PROP_DIGITALWAVEFORM。\r\n"
Oracle (NI) Line0015 = " - 记录数字限制测试和多个数字限制测试\r\n"
Oracle (NI) Line0016 = " 结果为 PROP_NUMERICLIMIT。\r\n"

MySQL Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 MySQL 一起使用。该模式为主键值生成唯一的 GUID 值。字符串、主键和外键列的数据类型应为 \ "字符串 (VarChar)\"。\r\n\r\n"
MySQL Insert (NI) Line0002 = "注意：如果系统为小数点指定逗号 (,) 字符，请确保启用 Don't Use Setlocale\" MySQL ODBC 驱动程序选项。\r\n\r\n"
MySQL Insert (NI) Line0003 = "架构处理结果如下：\r\n"
MySQL Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
MySQL Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
MySQL Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL表。\r\n"
MySQL Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
MySQL Insert (NI) Line0008 = " - 将一般属性信息记录到 PROP_RESULT。\r\n"
MySQL Insert (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
MySQL Insert (NI) Line0010 = " 作为字符串值。\r\n"
MySQL Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
MySQL Insert (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
MySQL Insert (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
MySQL Insert (NI) Line0014 = " - 记录数值限制测试和多重数值限制测试\r\n"
MySQL Insert (NI) Line0015 = " 结果为 PROP_NUMERICLIMIT。\r\n"

Sybase Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 Sybase 一起使用。此模式为主键值生成唯一的 GUID 值。使用 \"String (VarChar)\" 作为字符串的数据类型，并使用 \"uniqueidentifier\" 作为主键和外键列的数据类型。\r\n"
Sybase Insert (NI) Line0002 = "\r\n"
Sybase Insert (NI) Line0003 = "架构处理结果如下：\r\n"
Sybase Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
Sybase Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
Sybase Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
Sybase Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
Sybase Insert (NI) Line0008 = " - 将一般属性信息记录到 PROP_RESULT。\r\n"
Sybase Insert (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
Sybase Insert (NI) Line0010 = " 作为字符串值。\r\n"
Sybase Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
Sybase Insert (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
Sybase Insert (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
Sybase Insert (NI) Line0014 = " - 记录数值限制测试和多重数值限制测试\r\n"
Sybase Insert (NI) Line0015 = " 结果为 PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 Generic Recordset (NI) Line0001 ="此模式使用 SELECT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。该模式使用主键的自动递增字段。"
TS 2012-2014 SP1 Generic Recordset (NI) Line0002 = "您不能将此模式与 Oracle 一起使用，因为 Oracle 不支持自动递增字段。SELECT 语句使用"TOP 1"子句通过阻止记录集访问现有的来提高性能数据库中的记录。\r\n\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0010 = "作为字符串值。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0014 = "- 将数值极限测试和多重数值极限测试结果记录到\r\n"
TS 2012-2014 SP1 Generic Recordset (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 Generic Insert (NI) Line0001 = "此架构使用 INSERT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。该架构为主键值生成唯一的 GUID 值。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0002 = "\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0010 = "作为字符串值。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、 NI_IviWave 和\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0013 ="- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0014 = "- 将数值极限测试和多重数值极限测试结果记录到\r\n"
TS 2012-2014 SP1 Generic Insert (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0001 = "此模式使用存储过程语句来记录结果并仅支持与 Microsoft SQL Server 一起使用。该模式为主键值生成唯一的 GUID 值。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0002 = "\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0010 = "作为字符串值。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0014 = "- 将数值限制测试和多个数值限制测试结果记录到\r\n"
TS 2012-2014 SP1 SQL Server Stored Proc (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 Oracle (NI) Line0001 = "该架构使用 SELECT 语句记录结果并仅支持与 Oracle 一起使用。该架构使用数据库序列生成主键值。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0002 = "\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 Oracle (NI) Line0010 = " 作为字符串值。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0014 = " - 将数值极限测试和多重数值极限测试结果记录到\r\n"
TS 2012-2014 SP1 Oracle (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 MySQL Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 MySQL 一起使用。该模式为主键值生成唯一的 GUID 值。字符串、主键和外部的数据类型键列应该是 \"String (VarChar)\".\r\n\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0002 = "注意：如果系统为小数点指定逗号 (,) 字符，请确保启用 Don't Use Setlocale\" MySQL ODBC 驱动程序选项。\r\n\ r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0008 = " - 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0010 = " 作为字符串值。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0012 = " NI_IviWavePair 到PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0014 = " - 将数值限制测试和多个数值限制测试结果记录到\r\n"
TS 2012-2014 SP1 MySQL Insert (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 2012-2014 SP1 Sybase Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 Sybase 一起使用。该模式为主键值生成唯一的 GUID 值。使用 \"String (VarChar)\" 作为字符串的数据类型，并使用 \"uniqueidentifier\" 作为主键和外键列的数据类型。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0002 = "\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0010 = "作为字符串值。\r\n\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0014 = "- 将数值限制测试和多重数值限制测试结果记录到\r\n"
TS 2012-2014 SP1 Sybase Insert (NI) Line0015 = " PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 Generic Recordset (NI) Line0001 ="此模式使用 SELECT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。该模式使用自动递增字段作为主键。"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0002 = "您不能将此模式与 Oracle 一起使用，因为 Oracle 不支持自动递增字段。SELECT 语句使用"TOP 1"子句通过阻止记录集访问现有的来提高性能数据库中的记录。\r\n\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0013 ="- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0014 = "- 记录数值限制测试和多重数值限制测试\r\n"
TS 4.1-2010 SP1 Generic Recordset (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 Generic Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并支持与 Microsoft Access 或 Microsoft SQL Server 一起使用。该模式为主键值生成唯一的 GUID 值。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0002 = "\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、 NI_IviWave 和\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0013 ="- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0014 = "- 记录数值极限测试和多重数值极限测试\r\n"
TS 4.1-2010 SP1 Generic Insert (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0001 = "此模式使用存储过程语句来记录结果并仅支持与 Microsoft SQL Server 一起使用。该模式为主键值生成唯一的 GUID 值。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0002 = "\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0011 = "- 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0014 = "- 记录数值限制测试和多重数值限制测试\r\n"
TS 4.1-2010 SP1 SQL Server Stored Proc (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 Oracle (NI) Line0001 = "该架构使用 SELECT 语句记录结果并仅支持与 Oracle 一起使用。该架构使用数据库序列生成主键值。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0002 = "\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0012 = " NI_IviWavePair 到 PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0014 = " - 记录数字限制测试和多个数字限制测试\r\n"
TS 4.1-2010 SP1 Oracle (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 MySQL Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 MySQL 一起使用。该模式为主键值生成唯一的 GUID 值。字符串、主键和外部的数据类型键列应该是 \"String (VarChar)\".\r\n\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0002 = "注意：如果系统为小数点指定逗号 (,) 字符，请确保启用 \"Don't Use Setlocale\" MySQL ODBC 驱动程序选项。\r\ n\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0008 = " - 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0009 = " - 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0013 = " - 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0014 = " - 记录数字限制测试和多个数字限制测试\r\n"
TS 4.1-2010 SP1 MySQL Insert (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 4.1-2010 SP1 Sybase Insert (NI) Line0001 = "此模式使用 INSERT 语句记录结果并仅支持与 Sybase 一起使用。该模式为主键值生成唯一的 GUID 值。使用 \"String (VarChar)\" 作为字符串的数据类型，并使用 \"uniqueidentifier\" 作为主键和外键列的数据类型。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0002 = "\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0003 = "架构处理结果如下：\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0004 = "- 将 UUT 结果记录到 UUT_RESULT 表。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0005 = "- 将步骤结果记录到 STEP_RESULT 表。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0006 = "- 将序列调用步骤详细信息记录到 STEP_SEQCALL 表。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0007 = "- 将属性结果记录到表中，如下所示：\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0008 = "- 将一般属性信息记录到 PROP_RESULT。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0009 = "- 将字符串、数字和布尔值记录到 PROP_RESULT \r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0010 = "作为字符串值。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0011 = " - 记录 LabVIEWAnalogWaveform、NI_IviWave 和\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0012 = " NI_IviWavePair to PROP_ANALOGWAVEFORM。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0013 = "- 将 LabVIEWDigitalWaveform 记录到 PROP_DIGITALWAVEFORM。\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0014 = " - 记录数值限制测试和多重数值限制测试\r\n"
TS 4.1-2010 SP1 Sybase Insert (NI) Line0015 = "结果为 PROP_NUMERICLIMIT。\r\n"

TS 2.x-4.0 Generic Recordset (NI) Line0001 = "此模式仅适用于 Microsoft SQL Server 和 Access。此模式将新记录附加到打开的记录集中。语句使用的表必须"
TS 2.x-4.0 Generic Recordset (NI) Line0002 ="使用自动递增主键。如果需要数据类型，请使用此模式"
TS 2.x-4.0 Generic Recordset (NI) Line0003 ="键为数字或者如果你想将结果记录到 Microsoft Access"
TS 2.x-4.0 Generic Recordset (NI) Line0004 ="使用单台计算机的数据库。请注意，您不能将此模式与 Oracle 一起使用"
TS 2.x-4.0 Generic Recordset (NI) Line0005 = "因为 Oracle 不支持自动递增键。\r\n\r\n"
TS 2.x-4.0 Generic Recordset (NI) Line0006 = "SELECT 语句使用‘TOP 1’子句通过阻止记录集访问数据库中的现有记录来提高性能。"
TS 2.x-4.0 Generic Recordset (NI) Line0007 = "防止记录集访问数据库中的现有记录。"

TS 2.x-4.0 Generic Insert (NI) Line0001 ="此架构仅适用于 Microsoft SQL Server 和 Access。此架构为 TestStand 记录的每条记录执行插入命令。架构生成"
TS 2.x-4.0 Generic Insert (NI) Line0002 ="主键值的唯一 GUID 值。主键和外键列的数据类型必须"
TS 2.x-4.0 Generic Insert (NI) Line0003 = "be string. 此架构通常比通用记录集架构更快。使用此 "
TS 2.x-4.0 Generic Insert (NI) Line0004 ="如果您想将结果从多台计算机记录到单个 Access 数据库的架构。"

TS 2.x-4.0 SQL Server Stored Proc (NI) Line0001 = "此模式仅适用于 Microsoft SQL Server。该模式调用存储过程"
TS 2.x-4.0 SQL Server Stored Proc (NI) Line0002 = "执行插入命令。存储过程效率更高。模式生成"
TS 2.x-4.0 SQL Server Stored Proc (NI) Line0003 ="主键值的唯一 GUID 值。如果数据库使用此模式"
TS 2.x-4.0 SQL Server Stored Proc (NI) Line0004 ="服务器在单独的 PC 上运行。如果您结合使用并行或批处理模型"
TS 2.x-4.0 SQL Server Stored Proc (NI) Line0005 = "使用此架构，不要启用此对话框的数据链接选项卡上的共享执行之间的数据链接选项。"

TS 2.x-4.0 Oracle (NI) Line0001 ="仅将此模式与 Oracle 一起使用。该模式将新记录附加到打开的记录集，并且"
TS 2.x-4.0 Oracle (NI) Line0002 = "使用数据库序列生成主键值。模式存储测量 "
TS 2.x-4.0 Oracle (NI) Line0003 = "将结果排列成 BLOB 类型的列。Oracle 7 不支持 BLOB 数据类型或表"
TS 2.x-4.0 Oracle (NI) Line0004 ="具有多种大型二进制数据类型。"

TS 2.x-4.0 MySQL Insert (NI) Line0001 ="仅将此模式与 MySQL 一起使用。该模式为每条记录执行插入命令"
TS 2.x-4.0 MySQL Insert (NI) Line0002 = "TestStand 记录。该模式为主键值生成唯一的 GUID 值。"
TS 2.x-4.0 MySQL Insert (NI) Line0003 = "字符串、主键和外键列的数据类型应为 \"String (VarChar)\"。\r\n\r\n"
TS 2.x-4.0 MySQL Insert (NI) Line0004 = "注意：如果系统为小数点指定逗号（，）字符，请确保 MySQL ODBC 驱动程序 "
TS 2.x-4.0 MySQL Insert (NI) Line0005 = "选项\"不使用 Setlocale\" 已启用。"

TS 2.x-4.0 Sybase Insert (NI) Line0001 ="仅将此模式与 Sybase Adaptive Server Anywhere 一起使用。该模式为每条记录执行插入命令"
TS 2.x-4.0 Sybase Insert (NI) Line0002 = "TestStand 记录。该模式为主键值生成唯一的 GUID 值。"
TS 2.x-4.0 Sybase Insert (NI) Line0003 = "字符串的数据类型应为 \"String (VarChar)\"，主键和外键列的数据类型应为 \"uniqueidentifier\"。"

TS 1.x Access/SQL (NI) Line0001 = "此模式与记录结果的 TestStand 1.x 应用程序向后兼容"
TS 1.x Access/SQL (NI) Line0002 = "使用 Microsoft Access 或 Microsoft SQL Server 的数据库。"

TS 1.x Oracle (NI) Line0001 = "此模式与将结果记录到的 TestStand 1.x 应用程序向后兼容"
TS 1.x Oracle (NI) Line0002 = "使用 Oracle 7 或 Oracle 8 的数据库。"

[DBOPTIONS_TRAVERSEOPTIONS_UUT]
LOG_OPTIONS = "日志选项"
LOG_LABEL = "针对 UUT 结果执行语句时执行以下操作："
SKIP_RESULT = "跳过此 UUT 的剩余 UUT 结果语句"
SKIP_SUBRESULT = "跳过此 UUT 的步骤结果（注意：此选项不适用于即时记录。）"
SKIP_BUILTIN = ""
SKIP_CUSTOM = ""
SKIP_ADDITIONAL = ""

[DBOPTIONS_TRAVERSEOPTIONS_STEP]
LOG_OPTIONS = "日志选项"
LOG_LABEL = "当语句执行到步骤结果时执行以下操作："
SKIP_RESULT = "跳过此步骤的剩余步骤和结果语句"
SKIP_SUBRESULT = "跳过此步骤的属性结果"
SKIP_BUILTIN = "跳过内置属性结果"
SKIP_CUSTOM = "跳过自定义属性结果"
SKIP_ADDITIONAL = "跳过额外的属性结果"

[DBOPTIONS_TRAVERSEOPTIONS_PROP]
LOG_OPTIONS = "日志选项"
LOG_LABEL = "在为属性结果执行语句时执行以下操作："
SKIP_RESULT = "跳过此属性的剩余属性和结果语句"
SKIP_SUBRESULT = "跳过此属性的子属性结果"
SKIP_BUILTIN = ""
跳过自定义 = ""
跳过附加 = ""


[MODEL_DATABASE]
OPENING_DATABASE = "打开数据库"
LOGGING_TO_DATABASE = "记录到数据库"
LOGGING_UUT_TO_DATABASE = "将 UUT 结果记录到数据库"
LOGGING_STEPS_TO_DATABASE = "记录步骤结果到数据库"


[LOAD OPTION STRINGS]
PreloadWhenOpened = "打开序列文件时预加载"
PreloadWhenExecuted = "执行开始时预加载"
DynamicLoad = "动态加载"
DynamicLoadAll = "动态加载"
UseStepLoadOpt = "使用分步加载选项"

[UNLOAD OPTION STRINGS]
UnloadOnPreconditionFailure = "前提条件失败时卸载"
UnloadAfterStepExecution = "步骤执行后卸载"
UnloadAfterSequenceExecution = "序列执行后卸载"
UnloadWithSequenceFile = "序列文件关闭时卸载"
UnloadWithFile = "序列文件关闭时卸载"
UseStepUnloadOpt = "使用分步卸载选项"

[VALUE DISPLAY STRINGS]
BOOLEAN_TRUE = "真"
BOOLEAN_FALSE = "假"
ARRAY = "..."
OBJECT = "..."

[STEP_TYPE]
MENU_EDIT_ITEM_DEFAULT_NAME = "编辑..."
MENU_ITEM_NAME_WITH_ACTUAL_NAME = "%1 (%2)"

[PORT_LIMITS]
PORT_DLG_TITLE = "导入/导出顺序限制"
PORT_DONE = "__完成"
PORT_FORMAT = "格式:"
TAB_DELIMITED = "制表符分隔文本 (.txt)"
COMMA_DELIMITED = "逗号分隔文本 (.csv)"
EXCEL_FORMAT = "Excel 文件 (.xls)"
PORT_START = 开始数据__标记:"
PORT_END = "__数据结束标记："
PORT_DESTSRC_LABEL = "来源/目的地"
PORT_CLIP_RADIO = "__剪贴板"
PORT_FILE_RADIO = "__文件"
PORT_BROWSE_FILE = "__浏览..."
PORT_VIEW = "__查看文件"
PORT_IMPORT_OPTS_MSG = "导入选项："
PORT_SKIP = "跳过以以下内容开头的行："
PORT_USE_FIRST_ROW = "第一行数据指定每列的步骤__属性"
PORT_MAPPING = "指定列到步骤属性映射:\n(用逗号分隔属性名称)"
PORT_IMPORT = "__导入"
PORT_EXPORT = "导出"
PORT_HELP = "__帮助"
PORT_FILE_NOT_FOUND = "（未找到文件）"
PORT_NO_FILE_SPECIFIED = "（未指定文件）"
PORT_NUM_IMPORTED = "找到 %d 个限制。\n%d 个限制是从 %d 行数据中导入的\n"
PORT_IMPORT_ERR = "导入步骤限制时发生错误，代码 = %d"
PORT_IMPORT_COMPLETE_TITLE = "导入完成"
PORT_SAVE_TITLE = "将限制保存到文件："
PORT_LOAD_TITLE = "从文件中加载限制："
PORT_NUM_EXPORTED = "从 %d 个步骤中导出了 %d 个限制。"
PORT_DEFAULT_FILE_BASE_NAME = "限制"
PORT_FILE_BROWSE_TITLE = "选择限制文件"
PORT_BROWSE_DLG_SELECT_BTN = "&选择"
PORT_BROWSE_TXT_DLG_FILTER = "制表符分隔文本 (*.txt)|*.txt|所有文件 (*.*)|*.*||"
PORT_BROWSE_CSV_DLG_FILTER = "逗号分隔文本 (*.csv)|*.csv|所有文件 (*.*)|*.*||"
PORT_BROWSE_XLS_DLG_FILTER = "Excel 电子表格 (*.xls)|*.xls|所有文件 (*.*)|*.*||"
PORT_ERROR_TITLE = "错误："
PORT_SEQUENCE_FILE = "__序列文件："
PORT_SEQUENCE = "顺序__序列："
PORT_EXPORT_COMPLETE_TITLE = "导出完成"
PORT_TOOLMENU_ITEM = "导入/导出限制..."
PORT_FILE_EXISTS = "文件 %s 已经存在。\n是否替换现有文件？"
PORT_EXCEL_FILE_IN_USE = "文件 %s 当前加载到 Excel 中。\n覆盖电子表格内容吗？"
PORT_YES = "__是"
PORT_NO = "__否"
APPEND_TO_END_OF_FILE = "__附加到文件"
PORT_DECIMAL_POINT= "小数点："

[CONVERT_STEP_IDS]
DLG_TITLE = "转换步骤 ID"
PROMPT_FOR_CONVERT_TYPE = "此序列将您指定的序列文件中的表达式转换为使用步骤名称或步骤 ID。选择您要执行的转换类型："
PROMPT_FOR_FILE_SELECT_TYPE = "要指定要转换的文件，您可以\n1) 选择转换所有文件的目录或\n2) 使用对话框选择单个文件。"
USE_STEP_ID_BUTTON = "使用步骤 ID"
USE_STEP_NAME_BUTTON = "使用步骤名称"
CANCEL_BUTTON = "取消"
SELECT_DIR_BUTTON ="1) 按目录"
SELECT_FILES_BUTTON = "2) 按单个文件"
UNABLE_TO_CONVERT_MSG Line0001= "注意：某些使用步骤 ID 的表达式无法转换为步骤名称\n"
UNABLE_TO_CONVERT_MSG Line0002 = "因为有多个同名的步骤并且在\n中使用了一个步骤名称"
UNABLE_TO_CONVERT_MSG Line0003 = "表达式将指向错误的步骤。"
UNABLE_TO_CONVERT_MSG Line0004 = "要查找这些实例，请搜索\n包含文本'ID#:'的表达式。"

NUM_FILES_UPDATED = "%1 个文件已更新。"

[FIXUP_SEQ_FILES]
TOOLMENU_ITEM_TEXT = "更新序列文件..."
PICK_DIRECTORY = "更新：选择要搜索的目录"
OPEN_CANCELED_TITLE = "打开取消"
OPEN_CANCELED_MSG = "你取消了打开文件'%1'。\n\n你想继续更新剩余的文件吗？"
OPEN_ERROR_TITLE = "打开文件时出错"
OPEN_ERROR_MSG = "打开文件 '%1' 时发生以下错误。\n\n%2\n\n你想继续更新剩余的文件吗？"
SAVE_CANCELED_TITLE = "保存取消"
SAVE_CANCELED_MSG = "你取消了保存文件'%1'。\n\n你想继续更新剩余的文件吗？"
SAVE_ERROR_TITLE = "保存文件时出错"
SAVE_ERROR_MSG = "保存文件 '%1' 时发生以下错误。\n\n%2\n\n你想继续更新剩余的文件吗？"
RESULT_TITLE = "结果"
RESULT_NONE_SAVED = "没有文件被保存。"
RESULT_FILES_SAVED = "保存了以下序列文件：\n\n"
OK_BTN_LABEL = "确定"
CANCEL_BTN_LABEL = "取消"
YES_BTN_LABEL = "是"
NO_BTN_LABEL = "否"
YES_ALL_LABEL = "全部同意"
NO_ALL_LABEL = "拒绝所有人"
YES_TO_ALL_BTN_LABEL = "全部同意"
RETRY_BTN_LABEL = "重试"
NUM_FILES_UPDATED = "%1 个文件已更新。"
UPGRADE_WARNING = "警告"
UPGRADE_TO_OLD_VERSION_WARN = "%1\n是在较早版本的 TestStand 中创建的。\n\n如果您将文件更新到 TestStand %2，您可能无法在较早版本的 TestStand 中打开它。\n\n更新文件？"
UPGRADE_TO_NEW_VERSION_WARN = "%1\n是在较新版本的 TestStand 中创建的。\n\n如果您将文件重新保存到 TestStand %2，较新版本的 TestStand 中的一些设置可能会丢失。\n\n更新文件？"
PROGRESS_DLG_TITLE = "更新中"
PROGRESS_DLG_MSG_FINDING_FILES = "正在寻找要转换的文件。\n\n\n"
PROGRESS_DLG_MSG_FILE = "文件："
PROGRESS_DLG_STOP = "停止"

[UPDATE_VI_CALLS_TOOL]
LV_DEV_NOT_SET_TITLE = "未设置 LabVIEW 开发系统"
LV_DEV_NOT_SET = "要使用此工具，您必须配置 LabVIEW 适配器以使用 LabVIEW 开发系统。"
LV_DEV_VERSION_NOT_SUPPORTED_TITLE = "LabVIEW 开发系统版本不受支持"
LV_NXG_DEV_NOT_SET_TITLE = "未设置 LabVIEW NXG 开发系统"
LV_NXG_DEV_NOT_SET = "要使用此工具，您必须配置 LabVIEW NXG 适配器以使用 LabVIEW NXG 开发系统。"
LV_AND_LV_NXG_EV_NOT_SET_TITLE = "未设置 LabVIEW 开发系统和 LabVIEW NXG 开发系统"
LV_AND_LV_NXG_DEV_NOT_SET = "要使用此工具，您必须将 LabVIEW 适配器配置为使用 LabVIEW 开发系统，并将 LabVIEW NXG 适配器配置为使用 LabVIEW NXG 开发系统。"
LV_DEV_VERSION_NOT_SUPPORTED = "TestStand 需要 LabVIEW %2 或更高版本来更新 VI。\n您已注册版本 '%1'。该工具现在将关闭。"
TOOLMENU_ITEM_TEXT = "更新 VI/LV NXG VI 调用..."
SELECT_FILES_DIALOG_TITLE = "更新 VI/LV NXG VI 调用"
FILES_TO_UPDATE_PAGE = "要更新的文件"
STATUS_PAGE = "状态"
FILES_TO_UPDATE_LABEL = "要更新的文件"
ACTIVE_SEQFILE_LABEL = "活动序列文件："
FILES_UNDER_DIRECTORY_LABEL = "目录下的所有序列文件："
SPECIFIC_FILES_ON_DISK_LABEL = "特定序列文件："
ADD_FILES_BTN = "&添加文件..."
REMOVE_FILES_BTN = "&删除"
REMOVE_ALL_FILES_BTN = "全部删除&移动"
ALL_FILES_IN_WORKSPACE_LABEL = "当前工作区中的所有序列文件"
IGNORE_LOCKED_FILES_LABEL = "忽略锁定的文件"
LV_DEV_NOT_SET_OR_LV_NXG_NOT_INSTALLED = "要使用此工具，您必须配置 LabVIEW 适配器以使用 LabVIEW 开发系统，或者您必须安装 LabVIEW NXG。"
LV_NXG_NOT_INSTALLED = "只有安装了 LabVIEW NXG 才能处理调用 LabVIEW NXG 代码模块的步骤。"

TYPE_OF_CALLS_LABEL = "要更新的呼叫类型"
LABVIEW_NXG_LABEL = "LabVIEW NXG"
LABVIEW_LABEL = "LabVIEW"
PROCESS_EXPRESS_VIS = "处理 Express VI 调用"
PROCESS_STANDARD_VIS = "处理标准 VI 调用"
PROCESS_LVNXGVIS = "处理 LabVIEW NXG VI 调用"
REPORT_PROBLEMS_ONLY = "仅报告问题（不会进行任何更改）"
RELOAD_PROTOTYPE = "修改后重新载入原型"
FORCE_RELOAD_PROTOTYPE = "强制原型重载"
IGNORE_VI_NAMESPACE = "忽略 VI 命名空间"
LV_NXG_VI_CALL_32BIT_TS = "调用 LabVIEW NXG 代码模块的步骤只能在更新 VI 调用工具的 64 位版本中处理。"

LOG_RESULTS_LABEL = "记录结果"
DESTINATION_LABEL = "目的地："
REPORT_ERRORS_ONLY = "只报告有错误的步骤"
REPORT_PARAM_CHANGES = "报告参数变化"
SELECT_LOG_FILE_DLG_TITLE = "选择日志文件"
TEXT_FILE_FILTER = "文本 (*.txt)|*.txt|所有文件 (*.*)|*.*||"
BROWSE_DIRECTORY_TITLE = "选择更新文件的目录"
ADD_FILES_DLG_TITLE = "添加文件"
CONFIG_VI_PASSWORDS = "密码..."
UPDATE_CALLS = "更新调用"
STOP_UPDATING = "停止"

CONFIGURATION_VI_PASSWORD_TITLE = "要使用的配置 VI 密码"
ADD_PASSWORD = "添加"
DELETE_PASSWORD = "删除"
PASSWORD_LABEL = "密码："

UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0001 = "用法:\n\tUpdateVICallsApp.exe <path> [options]\n\nPath可以是一个序列文件，一个目录，或者一个TestStand工作区文件。如果是一个目录，则该目录下的所有序列文件"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0002 = "或其子目录将被更新。如果它是一个工作区文件，该工作区文件中引用的所有序列文件将被更新。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0003 = "\n选项：\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0004 = "\n/help /? - 打印此帮助。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0005 = "\n/StandardVI:{skip|logOnly|reloadModified|forceReload} - 检查所有调用标准 VI 的 LabVIEW 步骤实例，除非使用跳过选项。请参阅下面的选项说明。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0006 = ":skip - 跳过处理标准 VI 调用步骤。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0007 = ":logOnly -（默认）仅报告错误。不修改序列文件。更新建议将添加到报告中。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0008 = ":reloadModified - 将新的 VI 原型用于包含自上次读取原型以来已修改的 VI 的步骤。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0009 = ":forceReload - 重新加载 VI 原型，即使自从上次读取原型后原型没有改变。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0010 = "\n/ExpressVI:{skip|logOnly|reloadModified|forceReload} - 检查所有调用 Express VI 的 LabVIEW 步骤实例，除非使用跳过选项。见上文选项说明。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0011 = "\n/LabVIEWNXGVI:{skip|logOnly|reloadModified|forceReload} - 检查所有调用 LabVIEW NXG VI 的 LabVIEW NXG 步骤实例，除非使用跳过选项。见上文选项说明。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0012 = "\n/ignoreVINamespace - 查找 VI 的绝对路径时不使用 VI 命名空间。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0013 = "\n/logFile <path> - 将更新的步骤日志保存到给定位置的文件中。如果指定的文件已经存在，TestStand 会覆盖该文件。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0014 = "\n/reportErrorsOnly - 仅记录更新失败或有任何其他问题阻止步骤实例执行的步骤实例。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0015 = "\n/reportParameterChanges - 如果 VI 原型更改，记录 TestStand 添加或删除的参数。除非使用 /StandardVI:reloadModified、/StandardVI:forceReload、/ExpressVI:reloadModified 或 /ExpressVI:forceReload，否则无法使用。 \n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0016 = "\n/VIPasswords \"<password1>[,<password2>,...]\" - 在更新 Express VI 步骤时使用这个逗号分隔的密码列表来解锁配置 VI。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0017 = "如果密码包含逗号、反斜杠或引号，请使用转义序列 \\、\\\\ 或 \\\" 分别表示这些字符。将整个列表用引号引起来。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0018 = "\n/seqFilePasswords \"<password3>[,<password4>,...]\" - 使用逗号分隔的密码列表来解锁序列文件。使用与密码相同的语法来处理此列表与 /VIPasswords 一起使用的列表\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0019 = "\n/silent - 禁止工具从命令提示符输出。\n"
UPDATE_VI_CALLS_COMMAND_LINE_HELP Line0020 = "\n/env \"<EnvironmentFilePath>\" - 指定引擎环境文件。环境文件影响更新 VI 调用工具用于查找代码模块的搜索目录。"

UPDATE_VI_CALLS_APP_GENERIC_ERROR = "更新 VI 调用时发生未知错误。请联系 National Instruments 支持。"
UPDATE_VI_CALLS_APP_PROCESS_SEQUENCE_FILES_ERROR = "更新序列文件中的 VI 调用时出错。"
UPDATE_VI_CALLS_APP_LOG_FILE_INVALID = "无法写入指定的日志文件。"
UPDATE_VI_CALLS_APP_LV_DEV_NOT_SET = "无法更新 VI 调用。要更新 VI 调用，您必须配置 LabVIEW 适配器以使用 LabVIEW 开发系统。"
UPDATE_VI_CALLS_APP_LV_NXG_NOT_INSTALLED = "无法更新 LabVIEW NXG VI 调用。要更新 LabVIEW NXG VI 调用，您必须安装 LabVIEW NXG。"

UPDATE_VI_CALLS_APP_GET_SEQUENCE_FILE_ERROR = "无法打开路径为 '%1' 的序列文件"
UPDATE_VI_CALLS_APP_LOAD_SEQUENCE_FILE_ERROR_PREFIX = "加载序列文件时出错："

UPDATE_VI_CALLS_APP_INVALID_CFG_NO_ARGS = "未提供命令行参数。您必须至少指定一个路径，/? 或 /help。使用 /? 或 /help 显示帮助。"
UPDATE_VI_CALLS_APP_INVALID_CFG_NO_FILE_PASSWDS = "/seqFilePasswords 需要逗号分隔的密码列表来解锁序列文件。"
UPDATE_VI_CALLS_APP_INVALID_CFG_NO_VI_PASSWDS = "/VIPasswords 需要逗号分隔的密码列表来解锁锁定的 Express VI"
UPDATE_VI_CALLS_APP_INVALID_CFG_NO_LOG = "/logFile 需要日志文件的路径。"
UPDATE_VI_CALLS_APP_INVALID_CFG_UNEXPECTED_TOKEN = "项目 '%1' 不是预期的。"
UPDATE_VI_CALLS_APP_INVALID_CFG_INVALID_PATH = "路径 '%1' 无效。"
UPDATE_VI_CALLS_APP_INVALID_CFG_BAD_REPORT_PRAM_CHANGES = "/reportParameterChanges 开关已启用，但不会报告任何参数更改，因为不会更改 Express VI、标准 VI 或 LabVIEW NXG VI 的原型。"

UPDATE_VI_CALLS_APP_COM_EXCEPTION_NOT_REGISTERED = "初始化期间出现 COM 异常 0x80040154。检查 LabVIEW 适配器是否配置为使用已安装的 LabVIEW 开发系统版本。"
UPDATE_VI_CALLS_APP_COM_EXCEPTION_SERVER_EXECUTION_FAILED Line0001 = "初始化期间发生 COM 异常 0x80080005。"
UPDATE_VI_CALLS_APP_COM_EXCEPTION_SERVER_EXECUTION_FAILED Line0002 = "尝试关闭 LabVIEW 并重新启动 UpdateVICallsApp.exe。"
UPDATE_VI_CALLS_APP_COM_EXCEPTION_SERVER_EXECUTION_FAILED Line0003 = "如果这不能解决问题，请确认 LabVIEW 正在运行"
UPDATE_VI_CALLS_APP_COM_EXCEPTION_SERVER_EXECUTION_FAILED Line0004 = "具有与 UpdateVICallsApp.exe相同的管理员权限。"

TOOL_CONFIGURATION_ERROR = "更新 VI 调用配置无效。"

;;日志文件字符串
LOG_TITLE = "序列文件更新于："
LOG_HEADER_SEPARATOR = "-------------------------"
LOG_SEQUENCE_SEPARATOR = "===================================================================="
LOG_DATE = "日期："
LOG_TIME = "时间："
LOG_OPERATOR = "按操作员："
LOG_ACTIVE_LV_VERSION = "激活的 LabVIEW 版本："
LOG_ACTIVE_LV_NXG_VERSION = "活动的 LabVIEW NXG 版本："
LOG_SEQFILE_PATH = "路径："
LOG_SEQFILE_TYPE = "类型："
LOG_SEQFILE_TYPE_NORMAL = "正常"
LOG_SEQFILE_TYPE_MODEL = "模型"
LOG_SEQFILE_TYPE_FRONT_END_CALLBACK = "前端回调"
LOG_SEQFILE_TYPE_TEST_STAND_CALLBACK = "站回调"
LOG_SEQFILE_TYPE_TEMPLATE = "保留"
LOG_SEQ_NAME = "序列："
LOG_STEP_NAME = "步骤名称："
LOG_EXPRESS_VI_NAME = "Express VI 名称："
LOG_PROPERTY_CALL_CLASS_NAME = "属性调用类名称："
LOG_VI_PATH = "指定的 VI 路径："
LOG_VI_NAMESPACE = "VI 命名空间："
LOG_VI_ABSOLUTE_PATH = "找到 VI 路径："
LOG_MEMBER_NAME = "会员姓名："
LOG_VI_VERSION = "VI 版本："
LOG_VI_STATUS = "VI 状态："
LOG_LVNXGVI_VERSION = "LabVIEW NXG VI 版本："
LOG_GLL_VERSION = "GLL 版本："
LOG_LVNXGVI_STATUS = "LabVIEW NXG VI 状态："
LOG_LVNXGVI_NOT_FOUND = "在项目和 GLL 中找不到 LabVIEW NXG VI。"
LOG_LVNXGVI_NOT_FOUND_IN_PROJECT = "在项目中找不到 LabVIEW NXG VI。"
LOG_LVNXGVI_NOT_FOUND_IN_GLL = "在 GLL 中找不到 LabVIEW NXG VI。"
LOG_VI_AND_LVNXGVI_STATUS_NORMAL = "正常"
LOG_VI_AND_LVNXGVI_STATUS_BROKEN = "损坏"
LOG_EMPTY_PATH = "<空路径>"
LOG_EMPTY_MEMBER_NAME = "<空的成员名称>"
LOG_EMPTY_VI_NAMESPACE = "<未指定命名空间>"
LOG_EMPTY_VI_DESCRIPTION = "<未指定描述>"
LOG_PROJECT_PATH = "项目路径："
LOG_CLASS_PATH = "类路径："
LOG_GLL_PATH = "GLL 路径："
LOG_GLL_NOT_FOUND = "在磁盘上找不到 GLL。"
LOG_GLL_NOT_AT_EXPECTED_PATH = "步骤中指定的 GLL 不在预期的 GLL 路径中。预期的 GLL 路径由步骤中指定的 LabVIEW NXG 项目、组件和目标确定。"
LOG_QUALIFIED_NAME = "合格名称："
LOG_MODULE_QUALIFIED_NAME = "模块限定名称："
LOG_VI_URL = "VI URL："
LOG_CLASS_URL = "Class Url："
LOG_STATUS = "状态："
LOG_STEP_STATUS = "步骤状态："
LOG_READ_ONLY_FILE = "已跳过。文件在磁盘上是只读的。"
LOG_LOCKED_FILE = "已跳过。文件已锁定。"
LOG_VALID_FILE = "完成。"
LOG_UPDATED_EXPRESS_VI_SUCESSFULLY = "Express VI 已成功更新至 LabVIEW 版本 %1。"
LOG_UPDATED_PROPERTY_NODE_SUCESSFULLY = "属性节点调用已成功更新至 LabVIEW 版本 %1。"
LOG_LV_ERROR = "更新 Express VI 失败。LabVIEW 报告错误代码'%1'。您必须手动重新配置 Express VI。"
LOG_STATUS_NO_CHANGES = "没有做任何改变。原型是最新的。"
LOG_SKIP_FILE_NOT_FOUND = "已跳过。未找到文件。"
LOG_SKIP_LVPROJECT_AND_GLL_NOT_FOUND = "已跳过。项目路径和 GLL 路径为空或找不到指定的文件。"
LOG_SKIP_LVPROJECT_NOT_FOUND = "已跳过。项目路径为空或找不到指定的 LabVIEW NXG 项目文件。"
LOG_SKIP_GLL_EMPTY_ALWAYS_USE_RTE_SET = "已跳过。GLL 路径为空或找不到 LabVIEW NXG GLL 文件。"
LOG_LV_NXG_ADAPTER_ERROR = "打开用于更新 VI/LabVIEW NXG VI 工具的 LabVIEW NXG 时出错。\n\n其他信息："
LOG_USING_OLD_PROTOTYPE_ERROR = "该步骤最初是使用 LabVIEW 7.1.1 或更早版本配置的。步骤中存储的原型信息与 LabVIEW 2012 或更高版本不兼容。"
LOG_USING_OLD_PROTOTYPE_WARNING = "该步骤中存储的原型信息与 LabVIEW 2012 及更高版本不兼容。此警告出现在最后使用 LabVIEW 7.1.1 或更早版本配置的步骤中。该步骤将正确调用模块，但 TestStand 将生成一个使用 LabVIEW 2012 及更高版本执行该步骤时出错。National Instruments 建议您重新加载该步骤的原型。"
LOG_PROTOTYPE_CHANGED = "原型已更改。"
LOG_FORCING_PROTOTYPE_RELOAD = "强制原型重载..."
LOG_PROTOTYPE_STEP_UPDATED = "VI 调用已更新为使用新原型。"
LOG_LVNXGVI_PROTOTYPE_STEP_UPDATED = "已更新 LabVIEW NXG VI 调用以使用新原型。"
LOG_FAILED_TO_UPDATE_PROTOTYPE = "无法更新原型，出现以下错误："
LOG_PROTOTYPE_NOT_CHANGED = "未检测到原型变更。"
LOG_PROTOTYPE_STEP_NOT_UPDATED ="VI 调用未更新为使用指定的原型。\r\n\t在运行 VI 之前刷新 VI 调用。"
LOG_LVNXGVI_PROTOTYPE_STEP_NOT_UPDATED ="LabVIEW NXG VI 调用未更新为使用指定的原型。\r\n\t在运行 LabVIEW NXG VI 之前刷新 LabVIEW NXG VI 调用。"
LOG_PROTOTYPE_VI_BROKEN = "已跳过。指向损坏 VI 的 VI 调用不会更新。"
LOG_PROTOTYPE_LVNXGVI_BROKEN = "已跳过。未更新指向损坏的 LabVIEW NXG VI 的 LabVIEW NXG VI 调用。"
LOG_NEWER_VI_VERSION = "已跳过。VI 版本比当前 LabVIEW 版本更新。"
LOG_HIGHER_LVNXGVI_VERSION = "已跳过。LabVIEW NXG VI 版本比 Active LabVIEW NXG 版本更新。"
LOG_VI_NAMESPACE_CHANGE = "预期的 VI 命名空间 '%1' 与当前 VI 命名空间 '%2' 不同。"
LOG_CONFIG_VI_TIMEDOUT = "已跳过。配置对话框超时。检查 LabVIEW 中的任何弹出对话框。您可能必须关闭并重新启动 LabVIEW。另外，确认配置 VI 未锁定，如果锁定，您提供了正确的密码。"
LOG_CONFIG_VI_NOT_FOUND = "已跳过。未找到配置对话框。确认已安装 Express VI 的所有组件。"
LOG_VI_PATH_IN_LVLIBP_CHANGED = "指定 LabVIEW 打包项目库中的预期 VI 路径 '%1' 与当前 VI 路径 '%2' 不同。"
LOG_VI_DESCRIPTION_CHANGE = "预期的 VI 描述 '%1' 与当前 VI 描述 '%2' 不同。"
LOG_LVNXGVI_DESCRIPTION_CHANGE = "LabVIEW NXG VI 描述已更改。"
LOG_GLL_PATH_CHANGED = "GLL 路径已更改。"
LOG_CLUSTER_MAPPING_ERRORS = "集群映射错误："
LOG_MAPPIN_ERROR_IN_PARAMETER = "参数 '%1': "
LOG_CLUSTER_MAPPING_NO_ERRORS = "<未找到>"
LOG_STEP_SEPARATOR = "________________________________"
LOG_UNABLE_TO_GET_PROJECT_REFERENCE = "无法获取 '%1' 项目的引用"
LOG_UNABLE_TO_GET_APPLICATION_REFERENCE = "无法获取项目上下文引用"
LOG_UNABLE_TO_GET_VI_REFERENCE_WITH_PROJECT = "无法从位于 '%2' 的项目中获取位于 '%1' 的 VI 的引用"
LOG_UNABLE_TO_GET_VI_REFERENCE_WITHOUT_PROJECT = "无法在 '%1' 获取 VI 的引用"
LOG_UNABLE_TO_GET_MODULE_INFO = "访问 LabVIEW NXG 模块时出错。\n附加信息："
LOG_PARAMS_ADDED = "添加了以下参数："
LOG_PARAMS_DELETED = "以下参数已删除："
LOG_PARAM_TYPE_AND_VALUE = "[类型：%1，值：%2]"
LOG_PARAM_UNSPECIFIED_VALUE = "<未指定>"
LOG_PARAM_USING_CONFIG_VALUE = "<使用配置值>"
LOG_PARAM_USING_DEFAULT_VALUE = "<使用默认值>"
LOG_STOPPED = "--- 更新未完成。已被用户停止。---"
LOG_COMPLETED_SUCESSFULLY = "--- 完成更新 ---"
LOG_ELAPSED_TIME = "经过时间："
LOG_UPDATING_ASYNCHRONOUS_VI = "（异步 VI 调用）"
LOG_UPDATING_ASYNCHRONOUS_LVNXGVI = "（异步 LabVIEW NXG VI 调用）"
LOG_ADAPTER_EXCEPTION = "访问 LabVIEW NXG 适配器时出错。\n附加信息："
LOG_COULD_NOT_GET_NEW_STATUS = "获取 LabVIEW NXG VI 的新状态时遇到错误。"
LOG_UPDATING_LV_NXG_VI_IN_RTE = "使用 LabVIEW NXG 运行时引擎更新 LabVIEW NXG VI。"
LOG_ADAPTER_SETTINGS = "适配器设置："
LOG_LV_NXG_ADAPTER_SETTING = "LabVIEW NXG："
LOG_LV_ADAPTER_SETTING = "LabVIEW:"
LOG_ADAPTER_SETTING_DEV = "开发系统"
LOG_ADAPTER_SETTING_RTE = "运行引擎"

UPDATE_VI_CALLS_APP_UPDATE_STEP_ERROR = "无法更新步骤 '%1'。"
;;如果事情如此糟糕我们甚至无法获得步骤名称，则会使用此错误
UPDATE_VI_CALLS_APP_UPDATE_STEP_GENERIC_ERROR = "无法更新未知步骤"

;;当由于独立可执行文件使用更新 VI 调用工具而没有操作员登录时。
;;将显示在一行中："操作员：无"
UPDATE_VI_CALLS_NONE_OPERATOR = "无"


;;UI 菜单左面板 
[NI_STEPTYPES]
LABEL_MENU_ITEM_NAME = "标签"
LABEL_DEF_STEP_NAME = "标签"
SC_MENU_ITEM_NAME = "序列调用"
SC_DEF_STEP_NAME = "序列调用"
TEST_TYPE_MENU_NAME = "&测试"
ACTION_MENU_ITEM_NAME = "&动作"
ACTION_DEF_STEP_NAME = "动作"
STRING_MENU_ITEM_NAME = "&字符串值测试"
STRING_DEF_STEP_NAME = "字符串值测试"
STRING_EDIT_STEP_MENU_NAME = "编辑预期字符串..."
NUM_MENU_ITEM_NAME = "数字极限测试"
NUM_DEF_STEP_NAME = "数值极限测试"
NUM_EDIT_STEP_MENU_NAME = "编辑限制..."
MULTI_NUM_MENU_ITEM_NAME = "&多重数值极限测试"
MULTI_NUM_DEF_STEP_NAME = "多重数值极限测试"
PASSFAIL_MENU_ITEM_NAME = "&通过/失败测试"
PASSFAIL_DEF_STEP_NAME = "通过/失败测试"
PASSFAIL_EDIT_STEP_MENU_NAME = "编辑通过/失败源..."
PASSFAIL_DESCRIPTION_NAME = "通过/失败测试"
NUMERIC_LIMIT_DESCRIPTION_NAME = "数值极限测试"
MULTI_NUMERIC_LIMIT_DESCRIPTION_NAME = "多数值极限测试"
STRING_VALUE_DESCRIPTION_NAME = "字符串值测试"
ACTION_DESCRIPTION_NAME = "动作"
EDIT_SUBSTEP_MENU_ITEM_NAME = "编辑"
EDIT_DEF_SUBSTEP_NAME = "编辑"
PRE_SUBSTEP_MENU_ITEM_NAME = "准备步骤"
PRE_DEF_SUBSTEP_NAME = "前"
POST_SUBSTEP_MENU_ITEM_NAME = "后步骤"
POST_DEF_SUBSTEP_NAME = "发布"
GENERIC_SUBSTEP_MENU_ITEM_NAME = "自定义"
GENERIC_DEF_SUBSTEP_NAME = "自定义"

[CUSTOM_STEPTYPES]
DEFAULT_STEP_NAME = "步骤"

;; STEPTYPE_NAMES 部分由序列文件文档使用
[STEPTYPE_NAMES]
PassFailTest = "通过/失败测试"
NumericLimitTest = "数值极限测试"
StringValueTest = "字符串值测试"
Action="行动"
SequenceCall = "序列调用"
Statement="声明"
MessagePopup = "消息弹出窗口"
CallExecutable = "调用可执行文件"
LimitLoaderStep = "限制装载机"
Goto="转到"
Label = "标签"
PropertyLoaderStep = "属性加载器"
NI_VariableAndPropertyLoader = "属性加载器"

NI_Lock = "锁定"
NI_Semaphore = "信号量"
NI_Rendezvous = "交会"
NI_Queue = "队列"
NI_Notification = "通知"
NI_Wait = "等待"
NI_ThreadPriority = "线程优先级"
NI_BatchSync = "批量同步"

NI_OpenDatabase = "打开数据库"
NI_OpenSQLStatement = "打开 SQL 语句"
NI_CloseSQLStatement = "关闭 SQL 语句"
NI_CloseDatabase = "关闭数据库"
NI_DataOperation = "数据库操作"
NI_PropertyLoader = "属性加载器"

NI_IviDmm = "IVI 数字万用表"
NI_IviScope = "IVI 示波器"
NI_IviFgen = "IVI 函数发生器"
NI_IviDCPower = "IVI 电源"
NI_IviSwitch = "IVI 开关矩阵"
NI_IviTools = "IVI 工具步骤"


[SEQ_FILE_CONV]
OUT_MSG_DLG_TITLE = "来自序列文件转换器的消息："
CONV_RPTS_ERROR = "序列文件转换器，'%1'，报告错误"
CANT_CONV = "无法转换 '%1'"
WARN_NEWER_THAN_EXPECTED = "转换器 '%1' 报告文件的版本比预期的要新。\n是否仍要尝试转换文件？"
FILEDLG_TITLE = "选择一个文件进行转换："
SUCCESS_MSG = "转换成功：\n\n成功生成文件 '%1'"
WARN_ALREADY_EXISTS = "文件 '%1' 已经存在。\n你想覆盖这个文件吗？"
SELECT_CONV_DLG_TITLE = "选择转换器："
EXPLAIN_MULTI_CONV = "不止一个转换器可以转换所选文件。选择您要使用的转换器："


[REPORT_COLOR_NAMES]
Terminated = "'终止'文本"
Failed ="'失败'文本"
Error ="'错误'文本"
Passed ="'通过'文本"
Skipped = "'跳过'文本"
Running = "'运行'文本"
Done ="'完成'文本"
TerminatedBg = "'终止'背景"
FailedBg = "'失败'背景"
ErrorBg = "'错误'背景"
PassedBg = "'通过'背景"
SkippedBg = "'跳过'背景"
RunningBg = "'运行'背景"
DoneBg = "'完成'背景"
UUTSeparator = "UUT 分隔符"
HeaderSeparator = "页眉分隔符"
TableBorder = "表格边框"
MainBg = "'主要'背景"
SetupBg = "'设置'背景"
CleanupBg = "'清理'背景"
LabelBg = "项目标签背景"
ValueBg = "物品价值背景"
ReportTextBg = "步骤报告文本背景"
FailureStackLabelBg = "失败链标题背景"
FailureStackValueBg = "故障链背景"
BatchHeadingBg = "批报告标题背景"

[SEQ_FILE_DOC_BATCH_SYNC_NAMES]
0 ="使用序列文件设置"
1 ="使用模型设置"
2 ="不同步"
3 ="串行（一次一个线程）"
4 = "并行（所有线程同时进入）"
5 ="仅一个线程（第一个线程执行步骤，其余线程跳过）"

[SEQ_FILE_DOC]
MEAS_NAME_LBL = "测量名称："
END_OF_MEAS_LBL = "测量结束"
DOC_MAX_ARRAY_DISPLAY_EXCEEDED = "超出最大数组元素显示"
YES_BTN = "是"
NO_BTN = "否"

DOC_DLG_COULD_NOT_FIND_DOCGEN_SEQFILE = "找不到所需的序列文件："
DOC_DLG_UNSAVED_SEQ_FILE = "未保存的序列文件"
OVERWRITE_EXISTING_FILE = "文件已经存在。覆盖它？"
DOC_DLG_CANCEL = "__取消"
DOC_DLG_OK = "__确定"
DOC_DLG_HELP = "__帮助"
DOC_DLG_GEN_DOC_FOR_LBL = "生成文档："
DOC_DLG_FILE_FORMAT_LBL = "文件格式："
DOC_DLG_SHOW_PARAMS = "显示参数"
DOC_DLG_SHOW_LOCALS = "显示当地人"
DOC_DLG_SHOW_FILEGLOBALS = "显示序列文件全局"
DOC_DLG_SHOW_GLOBALS = "显示空间站全局"
DOC_DLG_PROPDISP_OPTS_LBL = "属性/变量"
DOC_DLG_VALUEDISP_OPTS_LBL = "数值显示选项"
DOC_DLG_SHOW_HIDDEN_PROPS = "显示隐藏属性"
DOC_DLG_SHOW_SUBPROPS = "显示子属性"
DOC_DLG_SHOW_ARRAY_ELEMS = "显示数组元素"
DOC_DLG_MAX_ELEMS = "要显示的最大元素数"
DOC_DLG_LAUNCH_VIEWER = "完成后启动查看器"
DOC_DLG_DEST_FILE_PATH = "目标文件路径："
DOC_DLG_FILE_BROWSE = "文件浏览"
DOC_DLG_HTML_FMT = "HTML"
DOC_DLG_TEXT_FMT = "Text"
DOC_DLG_FILE_DLG_HTML_FILTER = "HTML (*.html)|*.html|所有文件(*.*)|*.*||"
DOC_DLG_FILE_DLG_TEXT_FILTER = "Text (*.txt)|*.txt|所有文件 (*.*)|*.*||"
DOC_DLG_STATUS_GLOBALS = "文档站全局变量"
DOC_DLG_STATUS_SFGLOBALS = "记录序列文件全局"
DOC_DLG_STATUS_PARAMS = "记录序列参数"
DOC_DLG_STATUS_LOCALS = "记录序列局部变量"
DOC_DLG_STATUS_STEPS = "记录步骤"
DOC_DLG_LOCKED_FILE_LBL Line0001 = "注意：序列文件被锁定，内容不可查看。序列文件\n"
DOC_DLG_LOCKED_FILE_LBL Line0002 = "文档将不包括任何序列细节。"

DOC_STATION_GLOBALS = "空间站全局："

SFDOC_TOOLMENU_TEXT = "序列文件文档..."
SFDOC_TOOLMENU_SUBMENU = "序列文件文档"
TEXT_SFDOC_TOOLMENU_ITEM = "生成文本文档..."
HTML_SFDOC_TOOLMENU_ITEM = "生成 HTML 文档..."

DOC_TITLE = "序列文件文档"
DOC_HEADER_SEPARATOR = "----------------------------------------"
DOC_HEADER = "序列文件文档创建于："
DOC_DATE = "日期："
DOC_TIME = "时间："
DOC_OPERATOR = "通过操作员："
DOC_USER_NONE = "无"
DOC_LOAD_AND_UNLOAD_OPTION = "模块加载和卸载选项："
DOC_LOAD_OPTION = "模块加载选项："
DOC_UNLOAD_OPTION = "模块卸载选项："
DOC_DISABLE_RESULTS = "禁用所有步骤的结果："
DOC_SEQFILE_PATH = "路径："
DOC_SEQFILE_VERSION = "版本："
DOC_SEQFILE_UNKNOWN = "未知"
DOC_SEQFILE_LOCKED = "序列文件被锁定"
DOC_SEQFILE_MODELOPT = "模型选项："
DOC_SEQFILE_MODELFILE = "模型文件："
DOC_SEQFILE_NUM_SEQUENCES = "序列数："
DOC_SEQFILE_NUM_STEPS = "总步数："
DOC_SEQFILE_TYPE = "类型："
DOC_SEQFILE_TYPE_NORMAL = "正常"
DOC_SEQFILE_TYPE_MODEL = "型号"
DOC_SEQFILE_TYPE_FRONT_END_CALLBACK = "前端回调"
DOC_SEQFILE_TYPE_TEST_STAND_CALLBACK = "站回调"
DOC_SEQFILE_TYPE_TEMPLATE = "保留"
DOC_SEQFILE_DEFAULT_BATCH_SYNC = "默认批量同步："
DOC_SEQFILE_GLOBALS = "序列文件全局："
DOC_SEQ_NAME = "序列："
DOC_SEQ_COMMENT = "描述："
DOC_SEQ_GOTO_CLEANUP_ON_FAIL = "失败时转到清理："
DOC_SEQ_TYPE = "类型："
DOC_SEQ_TYPE_NORMAL = "正常"
DOC_SEQ_TYPE_CALLBACK = "回调"
DOC_SEQ_TYPE_EDIT_ENTRY_POINT = "编辑入口点"
DOC_SEQ_TYPE_EXECUTION_ENTRY_POINT = "执行入口点"
DOC_SEQ_TYPE_DEBUG_ENTRY_POINT = "调试入口点"
DOC_SEQ_TYPE_CONFIG_ENTRY_POINT = "配置入口点"
DOC_SEQ_TYPE_CONVERT_ENTRY_POINT = "转换入口点"
DOC_SEQ_NUM_MAIN_STEPS = "主要步骤数："
DOC_SEQ_NUM_SETUP_STEPS = "设置步骤数："
DOC_SEQ_NUM_CLEANUP_STEPS = "清理步骤数："
DOC_SEQ_PARAMS = "参数："
DOC_SEQ_LOCALS = "当地人："
DOC_STEP_NAME = "步骤："
DOC_STEP_TYPE = "步骤类型："
DOC_STEP_TYPE_AND_ADAPTER = "步骤类型，适配器："
DOC_STEP_ADAPTER = "适配器："
DOC_STEP_DESC = "描述："
DOC_STEP_PRECOND = "先决条件："
DOC_STEP_COMMENT = "评论："
DOC_STEP_INBUF = "InBuf:"
DOC_STEP_COMP_TYPE = "比较类型："
DOC_STEP_LIMIT_HIGH = "上限："
DOC_STEP_LIMIT_LOW = "下限："
DOC_STEP_LIMIT = "限制："
DOC_STEP_UNITS = "单位："
DOC_STEP_DATASOURCE = "数据源："
DOC_STEP_LIMIT_STRING = "预期字符串："
DOC_STEP_EXEC_FLOW = "流程属性："
DOC_FILE_SELECT_TITLE = "保存序列文件文档："
DOC_CREATED_SUCCESSFULLY_VIEW_NOW = "'%s' 已成功创建。现在查看吗？"
DOC_PROGDLG_TITLE = "生成序列文件文档"
DOC_PROGDLG_PERCENT_DONE = "完成百分比"
DOC_PROGDLG_CANCEL = "取消"
DOC_STEP_RUN_MODE = "运行模式："
DOC_STEP_STEP_FAIL_SEQ_FAIL = "步骤失败导致序列失败："
DOC_STEP_IGNORE_RTE = "忽略运行时错误："
DOC_STEP_PRE_EXPR = "预表达："
DOC_STEP_POST_EXPR = "表达式后："
DOC_STEP_STATUS_EXPR = "状态表达："
DOC_STEP_LOOP_TYPE = "循环类型："
DOC_STEP_LOOP_INIT_EXPR = "循环初始化表达式："
DOC_STEP_LOOP_INC_EXPR = "循环递增表达式："
DOC_STEP_LOOP_WHILE_EXPR = "循环表达式："
DOC_STEP_LOOP_STATUS_EXPR = "循环状态表达式："
DOC_STEP_LOOP_REC_ITER = "记录循环迭代结果："
DOC_STEP_PASS_ACT = "通过行动："
DOC_STEP_PASS_ACT_TARGET = "通过行动目标："
DOC_STEP_FAIL_ACT = "失败行动："
DOC_STEP_FAIL_ACT_TARGET = "行动目标失败："
DOC_STEP_CUST_ACT_EXPR = "自定义动作表达式："
DOC_STEP_CUST_TRUE_ACT = "自定义真实动作："
DOC_STEP_CUST_TRUE_ACT_TARGET = "自定义真实行动目标："
DOC_STEP_CUST_FALSE_ACT = "自定义错误动作："
DOC_STEP_CUST_FALSE_ACT_TARGET = "自定义虚假行动目标："
DOC_STEP_RECORD_RESULTS = "记录结果："
DOC_STEP_REQUIREMENTS = "要求："

[SEQ_FILE_CONVERTERS]
SFCONV_TOOLMENU_SUBMENU = "用于从 TestStand 2012 中删除的迁移菜单项的工具"
LV_SFCONV_TOOLMENU_ITEM = "用于从 TestStand 2012 中删除的迁移菜单项的工具"
CVI_SFCONV_TOOLMENU_ITEM = "用于从 TestStand 2012 中删除的迁移菜单项的工具"

[DISTRIBUTION_WIZARD]
TOOLMENU_ITEM = "部署 TestStand 系统..."
WINDOW_TITLE = "为运行时分发组装测试 VI"
CONTINUE_BTN = "继续"
CANCEL_BTN = "取消"
YES_BTN = "是"
OVERWRITE_MSG= "VI:%s 已经存在。覆盖它？"
YES_ALL_BTN = "全部同意"
NO_BTN = "否"
ADD_BTN = "添加"
SUCCESS_MSG = "VI 打包成功。确保将目标目录添加到分发安装中的 TestStand 搜索路径列表中。"
ERROR_MSG = "打包 VI 时出错。"
OK_BTN = "确定"
SELECT_DIR_BTN = "选择"
NO_VIS_MSG = "这些序列文件不包含使用 LabVIEW 标准原型适配器的步骤，或者指定的路径无效。"
INVALID_VIS_MSG Line0001 = "该序列文件包含一个或多个使用 LabVIEW 标准原型适配器的步骤"
INVALID_VIS_MSG Line0002 = "但路径规范无效。"
NO_VIS_TITLE = "组装测试 VI"
READING_VI_PATH_MSG = "读取 VI 路径"
OVERWRITE_SOURCE_MSG Line0001 = "您不能将 VI 汇编到与源 VI 相同的目录中。\n\n"
OVERWRITE_SOURCE_MSG Line0002 = "您正在尝试将以下源 VI 汇编到同一位置。\n\n"
OVERWRITE_SOURCE_MSG Line0003 = "点击确定选择另一个目录。"
DUPLICATE_PATH_ERROR = "以下 VI 的路径重复：\n"
OVERWRITE_DUP_PATH Line0001 = "VI:%s 已经存在。\n"
OVERWRITE_DUP_PATH Line0002 = "覆盖它？"
MULT_WINDOW_TITLE = "选择序列文件"
PACKAGING_MSG = "打包VI"
ASK_DYNAMIC_MSG Line0001 = "如果测试使用 VI 服务器动态调用 VI，\n"
ASK_DYNAMIC_MSG Line0002 = "您必须手动添加动态调用的 VI。\n"
USING_DYNAMIC_BTN="添加动态 VI"
NOT_USING_DYNAMIC_BTN="跳过动态VI"
DYNAMIC_MSG Line0001 = "如果使用 VI 服务器动态调用 VI，则必须手动添加这些 VI，以便它们\n"
DYNAMIC_MSG Line0002 = "已打包。点击浏览按钮找到一个VI，然后修改相对路径并\n"
DYNAMIC_MSG Line0003 = "单击添加按钮将 VI 添加到包中。单击继续以打包 VI。\n"
VIS_IN_PACKAGE_MSG = "这个包中包含的顶级 VI 是：\n"
ABS_PATH_LABEL = "绝对路径"
REL_PATH_LABEL = "相对路径"
BROWSE_BTN = "浏览"

[STRUCT_CONVERTER]
DefaultPacking = "默认适配器包装"
1BytePacking = "1 字节边界"
2BytePacking = "2 字节边界"
4BytePacking = "4 字节边界"
8BytePacking = "8 字节边界"
16BytePacking = "16 字节边界"

Real32 = "32 位实数（浮点数）"
Real64 = "64 位实数（双精度）"
Int8 = "带符号的 8 位整数"
UInt8 = "无符号 8 位整数"
Int16 = "带符号的 16 位整数"
UInt16 = "无符号 16 位整数"
Int32 = "带符号的 32 位整数"
UInt32 = "无符号 32 位整数"
Int64 = "带符号的 64 位整数"
UInt64 = "无符号 64 位整数"

8BitBool = "8 位布尔值"
16BitBool = "16 位布尔值"
32BitBool = "32 位布尔值"

DispatchPtrObj = "Active X 自动化 IDispatch 指针"
UnknownPtrObj = "Active X 自动化 IUnknown 指针"
CVIAutomationHandle = "CVI Active X 自动化句柄"

CString = "C 字符串（常量）"
UnicodeString = "Unicode 字符串 (const)"
CStringBuffer = "C 字符串缓冲区"
UnicodeStringBuffer = "Unicode 字符串缓冲区"
LabVIEWString = "LabVIEW 字符串"

StoreArrayAsMember = "嵌入式数组"
StorePointerToArray = "指向数组的指针"
StoreLabVIEWArray = "LabVIEW 数组"

StoreStructAsMember = "嵌入式结构"
StorePointerToStruct = "指向结构的指针"

StoreStringInline = "内联字符串"
StorePointerToString = "指向字符串的指针"

[TSEDIT]
ErrGeneralTitle = "错误"
ErrGeneralDesc = "发生以下错误：\n"

[RESULTSERVER]
AFX_IDS_APP_TITLE = "结果服务器"
UNKNOWN_ITEM_EXCEPTION = "期望的物品不存在。"
MAIN_WINDOW_TITLE 	= "结果服务器"
COMPLETED_STR = "项目已完成"
UNPROCESSED_STR = "等待处理的项目"
USER_STR = "用户："
TS_IN_Q_STR = "排队等候"
TS_PROCESSING_STR = "处理中..."
TS_DONE_STR = "完成"
TS_DISABLED_STR = "禁用"
TS_QING_STR = "排队中..."
OK_LABEL = "确定"
CANCEL_LABEL = "取消"
DONE_LABEL = "完成"
ADD_STATION_LABEL = "添加"
DELETE_STATION_LABEL = "删除"
CONFIG_DATABASE_LABEL = "数据库选项"
CONFIG_REPORT_LABEL = "报告选项"
EXISTING_STATIONS = "车站："
PROCESS_MODEL_LABEL = "进程模型（确定对话框中的可用选项）"
DISPLAY_REPORT_OPTIONS_SEQUENCE_NAME = "配置报告选项"
DISPLAY_DATABASE_OPTIONS_SEQUENCE_NAME = "配置数据库选项"
GET_REPORT_OPTIONS_SEQUENCE_NAME = "获取报告选项"
GET_DATABASE_OPTIONS_SEQUENCE_NAME = "获取数据库选项"
CONFIGURE_RP_OPTIONS_DIALOG_TITLE = "配置报告选项"
CONFIGURE_DB_OPTIONS_DIALOG_TITLE = "配置数据库选项"
BROWSE_LABEL = "浏览..."
EDIT_STATION_LABEL = "重命名"
USE_INCOMING_RP_OPTIONS_LABEL = "使用来自客户端进程的报告选项"
USE_INCOMING_DB_OPTIONS_LABEL = "使用来自客户端进程的数据库选项"
STATION_LISTVIEW_HEADER = "车站"
EMPTY_FILE_NAME_FULL_PATH_TEXT = "（未指定文件）"
FILE_NOT_FOUND_FULL_PATH_TEXT = "（未找到文件）"
SEARCHING_FOR_PATH_TEXT = "（正在搜索文件......）"
INVALID_MODEL_PATH = "您必须在模型组合框中指定一个包含显示报告选项序列的序列文件。"
SEQUENCE_FILES = "序列文件"
BEGIN_PAREN = " ( "
END_PAREN = " )"
NOT_APPLICABLE_STR = "不适用"
DEFAULT_STATION_NAME = "默认"
NO_DELETE_DEFAULT_MSG = "您不能删除默认报告和数据库选项。"
NO_EDIT_DEFAULT = "您不能编辑默认报告和数据库选项配置文件名称。"
ARE_YOU_SURE_MSG = "你想删除所选项目吗？"
NO_STATION = "不存在这样的站名。"
NO_EMPTY_STATION_NAMES = "站名不能为空。"
COPY_STRING = "副本"
NO_ITEM_SELECTED = "您必须在列表视图中选择一个站点进行编辑。"
POLL_LOCATION_LABEL = "包含传入结果文件的文件夹："
CONFIGURE_SERVER_DIALOG_TITLE = "服务器配置"
HELP = "&帮助"
FILE = "&文件"
EDIT = "&编辑"
CONFIGURE = "&配置"
VIEW = "&视图"
ID_LOGIN = "&登录\tCtrl+L"
ID_LOGIN_PROMPT = "登录新用户"
ID_UNLOAD_ALL_MODULES = "卸载所有模块"
ID_UNLOAD_ALL_MODULES_PROMPT = "卸载所有模块"
ID_APP_EXIT = "退出"
ID_APP_EXIT_PROMPT = "退出应用程序；提示保存文档"
ID_DELETE = "&删除\t"
ID_DELETE_TOOLTIP = "删除"
ID_DELETE_PROMPT = "从列表中删除项目"
ID_SELECT_ALL = "选择所有\t Ctrl+A"
ID_SELECT_ALL_PROMPT = "选择队列中的所有项目"
ID_SERVER_OPTIONS = "&服务器选项"
ID_SERVER_OPTIONS_PROMPT = "配置服务器选项"
ID_EXTERNAL_VIEWERS = "&外部查看器..."
ID_EXTERNAL_VIEWERS_PROMPT = "配置外部查看器"
ID_SEARCH_DIRECTORIES = "搜索目录..."
ID_SEARCH_DIRECTORIES_PROMPT = "打开 TestStand 搜索目录对话框"
ID_CONFIGURE_REPORT = "&报告选项.."
ID_CONFIGURE_REPORT_PROMPT = "打开配置报告选项对话框"
ID_CONFIGURE_DATABASE = "&数据库选项.."
ID_CONFIGURE_DATABASE_PROMPT = "打开配置数据库选项对话框"
ID_UNPROCESSED_RESULTS = "&未处理的结果"
ID_UNPROCESSED_RESULTS_TOOLTIP = "未处理的结果"
ID_UNPROCESSED_RESULTS_PROMPT = "查看未处理结果列表"
ID_PROCESSED_RESULTS = "已处理的结果"
ID_PROCESSED_RESULTS_TOOLTIP = "已处理结果"
ID_PROCESSED_RESULTS_PROMPT = "查看处理结果日志"
ID_VIEW_REPORT = "&查看报告"
ID_VIEW_REPORT_PROMPT = "显示与所选项目相关的报告"
ID_APP_ABOUT = "&关于结果服务器..."
ID_APP_ABOUT_PROMPT = "显示程序信息、版本号和版权"
ID_START_TOOLTIP = "开始处理"
ID_START_PROMPT = "开始处理"
ID_STOP_TOOLTIP = "处理当前结果后停止"
ID_STOP_PROMPT = "在当前结果集之后暂停数据处理"
ID_TERMINATE_TOOLTIP = "立即终止处理"
ID_TERMINATE_PROMPT = "立即暂停数据处理"
ID_MOVE_UP_TOOLTIP = "向上移动"
ID_MOVE_UP_PROMPT = "在队列中向上移动项目"
ID_MOVE_DOWN_TOOLTIP = "向下移动"
ID_MOVE_DOWN_PROMPT = "在队列中向下移动项目"
ID_DISABLE_TOOLTIP = "禁用"
ID_DISABLE_PROMPT = "禁用当前项目"
AFX_IDS_IDLEMESSAGE = "就绪"
IDR_MAINFRAME = "ResultServer\n\nResult\n\n\nResultServer.Document\nResult Document"
AFX_IDS_SCSIZE = "改变窗口大小"
AFX_IDS_SCMOVE = "改变窗口位置"
AFX_IDS_SCMINIMIZE = "将窗口缩小为图标"
AFX_IDS_SCMAXIMIZE = "将窗口放大到全尺寸"
AFX_IDS_SCRESTORE = "将窗口恢复到正常大小"
AFX_IDS_SCTASKLIST = "激活任务列表"
STATION_ID_LV_HEADER = "站号"
UUT_LV_HEADER = "UUT"
UUT_STARTED_LV_HEADER = "UUT 开始于"
UUT_STATUS_LV_HEADER = "UUT 状态"
STATUS_LV_HEADER = "状态"
OPERATOR_LV_HEADER = "操作员"
RESULT_FILE_LV_HEADER = "结果文件路径"
REPORT_FILENAME_LV_HEADER = "报告文件名"
PROCESSING_COMPLETED_LV_HEADER = "处理完成于"
PROCESSING_TIME_LV_HEADER = "UUT 处理时间"
ERROR_CREATING_RP_DIALOG = "初始化报告选项对话框时发生错误。TestStand 无法继续。"
ERROR_CREATING_DB_DIALOG = "初始化数据库选项对话框时发生错误。TestStand 无法继续。"
	
[PropDescr_PropFlags]
PropFlags_NotEditable = "不可编辑"
PropFlags_PassByReference = "通过引用"
PropFlags_Hidden = "隐藏"
PropFlags_HiddenInTypes = "隐藏类型"
PropFlags_DontTypeCheckParameter = "不输入检查参数"
PropFlags_Propagate = "传播"
PropFlags_PermitPropagation = "允许传播"
PropFlags_IsMeasurementValue = "测量值"
PropFlags_IsLimit = "限制"
PropFlags_IncludeInReport = "包括在报表中"
PropFlags_DontCopyToResults = "不要复制结果"
PropFlags_NotDeletable = "不可删除"
PropFlags_CommentNotEditable = "不可编辑的描述"
PropFlags_NameNotEditable = "名称不可编辑"
PropFlags_ExcludeFromComparison = "从比较中排除"
PropFlags_Shared = "共享"
PropFlags_SharedAtRunTime = "运行时共享"
PropFlags_ExcludeFromCopy = "排除复制"
PropFlags_UnstructuredProperty = "非结构化属性"

[PropDescr_RTS]
RTS ="序列属性"
EPNameExpr = "入口点名称表达式"
EPEnabledExpr = "入口点启用表达式"
EPMenuHint = "入口点菜单提示"
EPIgnoreClient = "入口点忽略客户端文件"
EPInitiallyHidden = "隐藏入口点执行"
EPCheckToSaveTitledFile = "执行前保存修改后的序列文件"
EPCheckToLoadNewerFile = "在执行前加载陈旧的序列文件"
ShowEPForFileWin = "当客户端文件窗口处于活动状态时显示入口点"
ShowEPForExeWin = "执行窗口激活时显示入口点"
CopyStepsOnOverriding = "创建覆盖序列时复制步骤和局部变量"
OptimizeNonReentrantCalls = "优化对此序列的非重入调用"
ShowEPAlways = "显示所有窗口的入口点"
ShowEPForEditorOnly = "仅在编辑器中显示入口点"
AllowIntExeOfEP = "允许交互执行入口点"

[PropDescr_Data]
Data ="文件属性"
Seq = "序列"
FileGlobalDefaults = "文件全局"
ModelFile = "模型文件"
LoadOpt = "加载选项"
UnloadOpt = "卸载选项"
ModelOption = "模型选项"
BatchSync = "默认批量同步"
SFGlobalsScope = "序列文件全局范围"
Users = "用户"
UserTemplates = "群组"

[PropDescr_TEInf]
TS = "步骤属性"
SData = "模块属性"
id = "步骤编号"
PreCond = "先决条件"
LoadOpt = "加载选项"
UnloadOpt = "卸载选项"
Mode ="运行模式"
WindowActivation = "TestStand 窗口激活"
NoResult = "丢弃结果"
StepFCSeqF = "步骤失败导致序列失败"
IgnoreRTE = "忽略运行时错误"
PassAct = "通过"
FailAct = "失败时"
PassActTarget = "通过目标"
FailActTarget = "目标失败"
CustExpr = "自定义条件表达式"
CustTrueAct = "自定义条件为真"
CustFalseAct = "自定义条件为假"
CustTrueActTarget = "在自定义条件真实目标上"
CustFalseActTarget = "自定义条件错误目标"
LoopType = "循环类型"
LoopWhile = "循环表达式"
LoopStatus = "循环状态表达式"
LoopIncrement = "循环增量表达式"
LoopInitialize = "循环初始化表达式"
LoopOpt = "循环选项"
PreExpr = "预表达"
PostExpr = "表达式后"
StatusExpr = "状态表达式"
HasModule = "有模块"
CanSpecifyModule = "可以指定模块"
CanEditCode = "可以编辑代码"
CanEditModulePrototype = "可以编辑模块原型"
PrecondIntExe = "交互模式下的前提条件评估"
UseMutex = "使用锁"
BatchSyncOpt = "批量同步选项"
MutexNameOrRef = "锁定名称或引用"
SwitchEnabled = "开关启用"
VirtualDeviceName = "虚拟设备名称"
SwitchOperation = "切换操作"
RouteGroupConnect = "要连接的路线"
RouteGroupDisconnect = "要断开的路由"
MulticonnectMode = "多连接模式"
OperationOrder = "连接/断开操作顺序"
ConnectionLifetime = "连接生命周期"
WaitForDebounce = "等待去抖动"
ResultOption = "结果记录选项"

[PropDescr_SEQUENCE]
GotoCleanupOnFail = "在序列失败时转到清理"
RecordResults = "记录结果"
FailureAction = "失败操作"
RTS ="序列属性"

[PropDescr_FlexGStepAdditions]
SData = "灵活的 LabVIEW 适配器属性"
ProjectPath = "项目路径名"
ViPath = "VI 路径名"
RemoteProjectPath = "远程项目路径"
RemoteVIPath = "远程 VI 路径"
ShowFrnPnl = "调用时显示 VI 前面板"
ViDescription = "VI 描述"
TDChecksum = "连线板校验和"
AutoDetectLVRT = "自动检测 LabVIEW 运行时引擎"
RemoteHost = "远程主机"
RemoteHostByExpr = "通过表达式指定主机"
parms = "参数"
OverrideClassPath = "覆盖类路径"
OverrideBinaryClassPath = "覆盖二进制类路径"
OverrideProjectPath = "覆盖项目路径"
OverrideBinaryProjectPath = "覆盖二进制项目路径"
OverrideVIPath = "覆盖 VI 路径"
OverrideBinaryVIPath = "覆盖二进制 VI 路径"
OverrideNamespace = "覆盖命名空间"
OverrideBinaryNamespace = "覆盖二进制命名空间"
BuildSpecificationName = "构建规范名称"
OverrideVIChecksum = "覆盖 VI 校验和"
OverrideBinaryVIChecksum = "覆盖二进制 VI 校验和"

[PropDescr_SeqCallStepAdditions]
SData = "序列适配器属性"
SFPath = "文件路径名"
SeqName = "序列名称"
SFPathExpr = "文件路径名表达式"
SeqNameExpr = "序列名称表达式"
ActualArgs = "实际参数"
UseCurFile = "使用当前文件"
SpecifyByExpr = "为路径名和序列指定表达式"
Async = "在新线程中运行子序列"
AutoWaitAsync = "等待子序列在当前序列结束时完成"
AsyncThreadExpr = "用于存储对新线程的对象引用的表达式"
AsyncApartmentThreaded = "使用单线程单元"
RemoteExecution = "远程执行"
RemoteHost = "远程主机"
RemoteHostExpr = "远程主机表达式"
SpecifyHostByExpr = "通过表达式指定主机"
UsePrototype = "使用存储的原型而不是来自所选序列的原型"
SpecifyByExpression = "通过表达式指定"
IgnoreTerminate = "忽略终止"
CreateThreadSuspended = "初始暂停"
ThreadOpt = "多线程执行选项"
ExecModelOpt = "进程模型选项"
ExecTypeMask = "附加执行类型掩码设置"
ExecTypeMaskExpr = "执行类型掩码表达式"
ExecBreakOnEntryExpr = "进入时中断"
ExecModelPath = "模型路径名"
ExecModelPathExpr = "模型路径名表达式"
ExecSync = "同步"

[PropDescr_HTBasicStepAdditions]
SData = "HTBasic 适配器属性"
SubName = "子程序名称"
SetWorkingDirType = "HTBasic 工作目录"
ShowApp = "调用时显示 HTBasic 应用程序"
SeqContextType = "传递序列上下文"
ModulePath = "子程序文件路径名"
WorkingDirPath = "工作目录路径"

[PropDescr_FlexCStepAdditions]
SData = "DLL 灵活适配器属性"
LibPath = "DLL 路径名"
Func="功能"
Conv = "调用约定"
ModuleSrcPath = "模块源路径"
parms = "参数"
ModulePrjPath = "项目文件"
ModuleWorkspacePath = "工作区文件"
ModuleCreateSrcType = "创建代码类型"

[PropDescr_FlexCVIStepAdditions]
SData = "LabWindows/CVI 适配器属性"
ModuleSrcPath = "包含函数的源文件的路径名"
AlwaysRunInProcess = "始终在进程中运行"
ModulePrjPath = "要打开的 CVI 项目文件的路径名"
ModuleWorkspacePath = "工作区文件"
LibPath = "模块路径名"
Func = "函数名"
Conv = "调用约定"
ModuleType = "模块类型"
parms = "参数"
SeqContextType = "传递序列上下文"
ArrayDimensionsSize = "维度"

[PropDescr_AutomationStepAdditions]
SData = "ActiveX/COM 适配器属性"
ObjectVariable = "对象引用"
ServerName = "服务器名称"
CreateObject = "创建对象"
CreateFromFilePath = "从文件路径创建对象"
CoClassName = "CoClass 名称"
InterfaceName = "接口名称"
RemoteMachine = "远程主机"
RemoteMachineByExpr = "为主机指定表达式"
UseLoadSpec = "使用步进加载/卸载选项指定对象创建时间和生命周期"
MakeCall = "调用方法或访问类"
MemberType = "会员类型"
MemberName = "会员姓名"
HasMemberInfo = "有会员信息"
HasReturnValue = "有返回值"
TypeLibLocale = "类型库语言环境"
TypeLibVersion = "类型库版本"
Name ="参数名称"
ArgVal = "参数值"
ArgDisplayVal = "参数显示值"
Type = "对象类型"
DisplayType = "对象显示类型"
TypeValid = "类型是否有效"
Direction = "参数方向"
IsUserOptional = "用户可选"
IsServerOptional = "服务器是否可选"
IsByRef = "通过引用"
IsSafeArray = "是安全数组"
VTableIndex = "虚拟表索引"

[PropDescr_DotNetStepAdditions]
SData = "DotNet 适配器属性"
Call = "网络调用"
AssemblyPath = "程序集路径"
AssemblyStrongName = "全局程序集强名称"
AssemblyLocation = "组装地点"
ClassVariable = "对象引用"
ClassName = "类"
IsStruct = "是结构"
CreateInstance = "创建对象或初始化结构"
DisposeCreatedInstance = "释放对象时调用 Dispose"
RemoteSpecifyExpr = "为主机指定表达式"
RemoteURL = "远程 URL"
RemoteUseLoadSpec = "使用步进加载/卸载选项指定对象创建时间和生命周期"
CallMember = "调用方法或访问属性"
MemberType = "会员类型"
HasReturnValue = "有返回值"
Params = "参数"
ConstructorParams = "构造函数参数"
StructDef = "结构定义"
ModuleSrcPath = "包含函数的源文件"
ModulePrjPath = "Visual Studio DotNet 项目文件"
ModuleSlnPath = "Visual Studio DotNet 解决方案文件"
FunctionName = "方法名"

[PropDescr_NoneStepAdditions]
SData = "无适配器属性"

[PropDescr_CallExecutable]
TS = "步骤属性"
Executable ="可执行路径名"
Arguments = "参数表达式"
WaitCondition = "等待条件"
TimeToWait = "等待时间（秒）"
InitialWindowState = "初始窗口状态"
TerminateOnAbort = "如果步骤终止或中止则终止可执行文件"
ProcessHandle = "进程句柄"
ExitCodeStatusAction = "退出代码状态操作"

[PropDescr_MessagePopup]
TS = "步骤属性"
TitleExpr = "标题表达式"
MessageExpr = "消息表达式"
Button1Label = "按钮 1 标签"
Button2Label = "按钮 2 标签"
Button3Label = "按钮 3 标签"
Button4Label = "按钮 4 标签"
CenterDialog = "居中对话框"
ShowResponse = "显示响应文本框"
MaxResponseLength = "最大响应字符串长度"
DefaultResponse = "默认响应字符串"
ButtonLocation = "按钮排列"
ActiveCtrl = "主动控制"
DefaultButton = "默认按钮"
CancelButton = "取消按钮"
TimerButton = "超时按钮"
TimeToWait = "等待时间（秒）"

[PropDescr_Statement]
TS = "步骤属性"

[PropDescr_NumericLimitTest]
TS = "步骤属性"
Comp = "比较类型"
InBuf = "在缓冲区中"
DataSource = "数据源表达式"

[PropDescr_NI_MultipleNumericLimitTest]
DataSource = "数据源表达式"
UseIndividualDataSources = "为每个测量指定一个数据源"
InBuf = "在缓冲区中"
NumericArray = "数值数组"
DataSourceArray = "数据源数组"

[PropDescr_Action]
TS = "步骤属性"

[PropDescr_StringValueTest]
TS = "步骤属性"
String = "期望的字符串值"
Comp = "比较类型"
InBuf = "在缓冲区中"
DataSource = "数据源表达式"

[PropDescr_PassFailTest]
TS = "步骤属性"
InBuf = "在缓冲区中"
DataSource = "数据源表达式"

[PropDescr_SequenceCall]
TS = "步骤属性"

[PropDescr_AutomationParameter]
DisplayType = "显示类型"
IsByRef = "通过引用"
IsUserOptional = "用户可选"
ArgVal = "值"
ArgDisplayVal = "枚举值"
IsSafeArray = "是安全数组"

[PropDescr_FCParameter]
Type = "类别"
ObjType = "对象类型"
StructType = "结构类型"
NumType = "数字数据类型"
NumPass = "数字通行证"
StrPass = "字符串传递"
ElemPass = "元素传递"
ArrayDimensionsSize = "维度"
StrSize = "缓冲区大小"
ResultAct = "结果动作"
ArgVal = "值表达式"
ArgDisplayVal = "枚举值"
ArgValImag = "虚数值表达式"
EnumerationType = "枚举类型"

[PropDescr_FCVIParameter]
Type = "类别"
ObjType = "对象类型"
StructType = "结构类型"
NumType = "数字数据类型"
NumPass = "数字通行证"
StrPass = "字符串传递"
ElemPass = "元素传递"
ArrayDimensions = "维度"
ArrayDimensionSize = "数组维度的大小"
StrSize = "缓冲区大小"
ResultAct = "结果动作"
ArgVal = "值表达式"
ArgDisplayVal = "枚举值"
ArgValImag = "虚数值表达式"
EnumerationType = "枚举类型"

[PropDescr_DotNetParameter]
ArgVal = "值表达式"
ArgDisplayVal = "枚举值"
DisplayType = "显示类型"
IsOptional = "可选"
CallDispose = "处置"
IsArray = "是数组"
MultiElement = "数组/结构元素"

[PropDescr_SequenceArgument]
UseDef = "使用默认值"
Expr = "值表达式"

[PropDescr_VIParameter]
ArgVal = "值表达式"
ArgDisplayVal = "枚举值"
WireRequirement = "电线要求"
ArrayType = "数组类型"
ClusterType = "集群类型"
NumType = "数字数据类型"
ReferenceType = "引用类型"
StrPass = "字符串传递"
DisplayType = "显示类型"
ComplexParts = "复数部分"
ArrayClusterProto = "数组簇原型"
ArrayClusterEls = "数组/簇元素"
ConnectorNumber = "连接器编号"
LegacyClusterType = "旧集群数据类型"
UseDefaultValues = "使用 VI 控件默认值"

[PropDescr_VIParameterElement]
ArgVal = "值表达式"
ArgDisplayVal = "枚举值"
WireRequirement = "电线要求"
ArrayType = "数组类型"
ClusterType = "集群类型"
NumType = "数字数据类型"
ReferenceType = "引用类型"
StrPass = "字符串传递"
DisplayType = "显示类型"
ComplexParts = "复数部分"
ArrayClusterProto = "数组簇原型"
ArrayClusterEls = "数组/簇元素"

[PropDescr_LimitLoaderStep]
TS = "步骤属性"
File ="限制文件"
UseExpr = "使用表达式指定文件"
FileExpr = "文件表达式"
Format = "文件格式"
StartMarkerExpr = "表示数据开始的字符串表达式"
EndMarkerExpr = "表示数据结束的字符串表达式"
Skip = "跳过开头为"的行
MapColumnsUsingFirstRow = "使用第一行映射列"
ColumnMapping = "为步骤属性映射指定列"
DecimalPoint = "小数点格式"

[PropDescr_Goto]
TS = "步骤属性"

[PropDescr_Label]
TS = "步骤属性"

[PropDescr_WaitForThread]
TS = "步骤属性"
Timeout ="超时（毫秒）"
TimeoutEnabled = "超时启用"
ErrorOnTimeout = "超时导致运行时错误"
SpecifyBy = "指定线程"
ThreadRefExpr = "线程引用表达式"
SeqCallName = "序列调用名称"
SeqCallStepGroupIdx = "序列调用步骤组"

[PropDescr_TSDifferSpecificPropFile1RootSections]
Data="文件属性"
Seq = "序列"
FileGlobalDefaults = "文件全局"

[PropDescr_TSDifferSpecificPropFile2RootSections]
Data ="文件属性"
Seq = "序列"
FileGlobalDefaults = "文件全局"

[PropDescr_NI_VariableAndPropertyLoader]
ColumnListSource = ""
ColumnList = ""
PropertiesListSource = "属性列表源"
ProperiesList = ""
DataSourceType = "数据位置"
Skip = "跳过以开头的行"

[PropDescr_File]
Path ="文件位置"
DecimalPoint = "小数点"
UseExpr = "使用表达式指定文件"
FileExpr = "文件名表达式"
StartMarkerExpr = "数据标记开始"
EndMarkerExpr = "数据标记结束"
MapColumnsUsingFirstRow = "第一行数据指定每列的步骤属性"

[PropDescr_Database]
SQLStatementHandle = "语句句柄"
SQLStatement = "SQL SELECT 语句"
StepNameColumn = "步骤名称列"
AppendTypeName = "将数据类型附加到列名"
MaxColumnSize = "列名的最大大小"
FilterUsingColumnList = "只导入匹配特定列值的行"

[PropDescr_DatabasePropertyMapping]
PropertyName = "属性名称"
ColumnName = "列名/列号"

[PropDescr_DatabaseColumnValue]
ColumnName = "列名/列号"
Data ="值"
FormatString = "格式化字符串"
ColumnNumber = "列号"
WriteNull = "写空"

[PropDescr_NI_Lock]
NameOrRefExpr = "锁定名称表达式"
AlreadyExistsExpr = "已经存在？"
LifeTimeRefExpr = "锁定生命周期引用表达式"
LifeTime = "锁定参考生命周期"
TimeoutEnabled = "超时启用"
TimeOutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
NumThreadsWaitingExpr = "等待锁定锁的线程数"
LockLifetime = "锁定操作生命周期"
CreateIfDoesNotExist = "如果不存在则创建"

[PropDescr_NI_BatchSync]
TimeoutEnabled = "超时启用"
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
SectionNameExpr = "章节名称"
SectionType = "章节类型"

[PropDescr_NI_BatchSpec]
NameOrRefExpr = "批次名称表达式"
LifetimeRefExpr = "批次引用生命周期"
AlreadyExistsExpr = "已经存在？"
ThreadRefExpr = "对象对线程的引用"
OrderNumExpr = "Order Number (最低编号线程先行)"
NumThreadsWaitingExpr = "在同步部分等待的线程数"
NumThreadsInBatchExpr = "批处理线程数"
DefaultBatchSyncExpr = "默认批量同步"
DefaultBathSyncOutExpr = "默认批同步（输出）"

[PropDescr_NI_Semaphore]
NameOrRefExpr = "信号量名称表达式"
LifetimeRefExpr = "信号量生命周期参考"
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
AlreadyExistsExpr = "已经存在？"
InitialCountExpr = "初始信号量计数"
NumThreadsWaitingExpr = "等待获取信号量的线程数"
InitialCountOutExpr = "初始信号量计数（输出）"
CurrentCountExpr = "当前计数"
Lifetime = "信号量参考生命周期"
AutoRelease = "自动释放"
TimeoutEnabled = "超时启用"
AcquireLifetime = "获取生命周期"

[PropDescr_NI_Rendezvous]
NameOrRefExpr = "集合名称表达式"
LifetimeRefExpr = "集合点生命周期参考"
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
AlreadyExistsExpr = "已经存在？"
RendezvousCountExpr = "每个集合点的线程数"
NumThreadsWaitingExpr = "等待会合的线程数"
RendezvousCountOutExpr = "每个集合点的线程数（输出）"
Lifetime = "Rendezvous Reference Lifetime"
TimeoutEnabled = "超时启用"

[PropDescr_NI_Queue]
NameOrRefExpr = "队列名称表达式"
LifetimeRefExpr = "队列生命周期引用"
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
AlreadyExistsExpr = "已经存在？"
MaxNumElementsExpr = "最大元素数"
MaxNumElementsOutExpr = "最大元素数（输出）"
NumThreadsWaitingEnqueueExpr = "等待入队的线程数"
NumThreadsWaitingDequeueExpr = "等待出队的线程数"
NumElementsExpr = "元素数（输出）"
DataExpr = "存储队列元素数组的位置（输出）"
ByRef = "按引用而不是按值存储"
EnqueueLocation = "插入位置"
DequeueLocation = "出队自"
FullQueueOption = "如果队列已满"
WhichQueueExpr = "哪个队列？"
TimeoutEnabled = "超时启用"
RemoveElement = "删除元素"

[PropDescr_NI_Notification]
NameOrRefExpr = "通知名称表达式"
LifetimeRefExpr = "通知生命周期参考"
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
AlreadyExistsExpr = "已经存在？"
NumThreadsWaitingExpr = "等待通知的线程数"
DataExpr = "存储数据的位置"
ByRef = "按引用而不是按值存储数据"
WhichNotificationExpr = "哪个通知？"
IsSetExpr = "已设置？"
IsAutoClearExpr = "自动清除吗？"
AutoClear = "通知一个线程后自动清除"
PulseNotifyOpt = "脉冲通知选项"

[PropDescr_NI_Wait]
TimeoutExpr = "超时表达式（秒）"
ErrorOnTimeout = "超时导致运行时错误"
ThreadRefExpr = "要等待的线程的对象引用"
TimeExpr = "指定等待时间"
WaitForTarget = "等待"
SpecifyBySeqCall = "通过序列调用指定"
SeqCallName = "序列调用名称"
SeqCallStepGroupIdx = "序列调用步骤组"
ExecutionRefExpr = "等待执行的对象引用"
TimeoutEnabled = "超时启用"

[PropDescr_NI_ThreadPriority]
SetPriorityExpr = "新线程优先级"
GetPriorityExpr = "存储线程优先级的位置"

[PropDescr_NI_IviDmm]
LogicalName = "逻辑名称"
InstrOperation = "操作"
SettingsSource = "设置属性/变量"

[PropDescr_NI_IviDmmConfig]
ACMaxFreq = "最大交流频率"
ACMinFreq = "最小交流频率"
MeasFunction = "测量函数"
RangeMode = "测距模式"
Range = "值 (+/-)"
TriggerDelayMode = "触发延迟模式"
TriggerDelay = "触发延迟值"
TriggerSource = "触发源"
MeasCompleteDest = "多点 - 测量完成目标"
SampleCount = "多点 - 样本计数"
SampleInterval = "多点 - 采样间隔 (ms)"
SampleTrigger = "多点 - 样本触发器"
TriggerCount = "多点 - 触发计数"
VoltageRangeForFreq = "频率的电压范围 (Vrms)"
AutoZero = "自动归零"
PowerlineFreq = "电力线频率"
TriggerSlope = "触发斜率"

[PropDescr_Temperature]
TransducerType = "传感器类型"
TCType = "热电偶 - 类型"
TCRefJunctionType = "参考结 - 类型"
TCFixedRefJunction = "参考结 - 值"
RTDAlpha = "Rtd - 阿尔法"
RTDResistance = "Rtd - 电阻"
ThermistorResistance = "热敏电阻 - 电阻"

[PropDescr_NI_IviSoftFrontPanel]
WindowTitle = "窗口标题"
ShowModal = "显示模态"
WaitForClose = "在继续之前等待用户关闭"
AllowControl = "允许控制"
AllowUserToClose = "允许用户关闭"
CloseWhenSessionClosed = "释放执行时自动关闭窗口"
UseDefaultLocation = "使用默认位置"
AutoReadInterval = "自动读取间隔"

[PropDescr_Readings]
Dest = "测量目标"
DataType = "数据类型"
CopyDataToResult = "复制数据到执行结果"
TimeoutStatus = "设置超时状态"
Timeout ="超时（毫秒）"
IsOverRangeStatus = "如果超出范围则设置状态"

[PropDescr_GetInfo]
AutoRangeValue = "获取自动量程值"
ApertureTimeValue = "获取光圈时间信息 - 时间"
ApertureTimeUnits = "获取光圈时间信息 - 单位"
ActualRecordLength = "获取实际记录长度"
SampleRate = "获取采样率"
SampleMode = "获取采样模式"
AcquistionStatus = "获取收购状态"
AutoProbeSenseValue = "获取自动探测感应值"
QueryMaxCurrentLimit = "最大电流限制（输出）"
VoltageLevel = "电压电平（输入）"
QueryMaxVoltageLevel = "最大电压电平（输出）"
CurrentLimit = "电流限制（输入）"
QueryOutputState = "查询输出状态"
OutputState = "值"

[PropDescr_NI_IviScope]
InstrOperation = "操作员"
SettingsSource = "设置属性/变量"

[PropDescr_NI_IviScopeConfig]
AcquisitionType = "采集类型"
NumAverages = "平均数"
NumEnvelopes = "信号数"
MinNumPoints = "水平 - 最小点数"
TimePerRecord = "水平 - 每条记录的时间"
AcqStartTime = "水平 = 采集开始时间"
MeasLowRef = "测量低参考值"
MeasMidRef = "测量中间参考"
MeasHighRef = "测量高参考值"

[PropDescr_NI_IviReading]
Dest = "测量目标"
IsOverRangeStatus = "如果超出范围则设置状态"
CopyDataToResult = "复制数据到执行结果"

[PropDescr_NI_IviFgen]
InstrOperation = "操作"
SettingsSource = "设置属性/变量"

[PropDescr_NI_IviFgenConfig]
AutoStopStart = "自动停止/启动"
OutputMode = "输出模式"
RefClockSource = "参考时钟源"
ArbSampleRate = "任意波形采样率"
InternalTriggerRate = "内部触发率"
AMModulation = "AM 调制内部"
FMModulation = "FM 调制内部"
PreserveExistingChannels = "保留现有频道"
PreserveExistingArbWfms = "保留现有波形"

[PropDescr_AMModulation]
InternalDepth = "深度"
InternalWaveForm = "波形"
InternalFrequency = "频率"

[PropDescr_FMModulation]
InternalDeviation = "偏差"
InternalWaveform = "波形"
InternalFrequency = "频率"

[PropDescr_NI_IviFgenChannel]
DcOffset = "直流偏移"
DutyCycleHigh = "占空比高"
BurstCount = "突发计数"
StartPhase = "开始阶段"
AMEnabled = "AM 调制 - 启用"
AMSource = "AM 调制 - 源"
FMEnable = "FM 调制 - 启用"
FMSource = "FM 调制 - 源"

[PropDescr_Sequences]
MaxLoopCount = "获取最大循环次数"
MaxNumSequences = "获取最大序列数"
MaxSequenceLength = "获取最大序列长度"
MinSequenceLength = "获取最小序列长度"

[PropDescr_Waveforms]
MaxNumWaveforms = "获取最大波形数"
MaxWaveformSize = "获取最大波形大小"
MinWaveformSize = "获取最小波形大小"
WaveformQuantum = "获取波形量程"

[PropDescr_NI_IviTools]
InstrOperation = "操作"
SettingsSource = "设置属性/变量"

[PropDescr_SessionInfo]
SMReference = "会话管理器参考"
DriverHandle = "C 驱动程序句柄"
DriverReference = "COM 驱动程序参考"
ActiveXReference = "ActiveX 参考"

[PropDescr_Init]
DoIdQuery = "执行ID查询"
DoReset = "重置"
OptionsString = "额外的初始化选项"
ReInitBehavior = "重新初始化操作"

[PropDescr_ErrorInfo]
PrimaryError = "主要错误代码"
SecondaryError = "二级错误代码"
ErrorElaboration = "错误说明"

[PropDescr_NI_IviDCPower]
InstrOperation = "操作"
SettingsSource = "设置属性/变量"
ResetOutputProtection = "复位输出保护"
LogicalName = "逻辑名"

[PropDescr_NI_IviDCPowerChannel]
VoltageLevel = "电压电平 (V)"
OutputRnageMode = "输出范围模式"
VoltageRange = "电压范围 (V)"
CurrentRange = "电流量程 (A)"
CurrentLimitBehavior = "限流行为"
CurrentLimit = "电流限制"
OVPEnabled = "OVP 启用"
OVPLimit = "OVP 限制"
TriggerSource = "触发源"
TriggerCurrentLimit = "触发电流限制"
TriggerVoltageLevel = "触发电压电平"

[PropDescr_NI_IviDCPowerReadChannel]
MeasureType = "测量类型"
Dest = "测量目标"

[PropDescr_NI_IVISwitch]
LogicalName = "逻辑名称"
InstrOperation = "操作"
SettingsSource = "设置属性/变量"
IviOperation = "IVI Switch (True) 或 Switch Executive (False)"
SetPath = "设置路径"
ConnectDisconnect = "连接/断开设置"
SoftFrontPanel = "软前面板"
GetInfo = "获取信息"
ScanningConfig = "扫描配置"

[PropDescr_NI_IviSwitchConnectDisconnect]
SwitchExec = "切换执行"

[PropDescr_SwitchExec]
RouteGroupToDisconnect = "要断开的路由"
RouteGroupToConnect = "要连接的路线"
ConnectionLifeTime = "连接生命周期"
WaitForDebounce = "等待去抖动"
OperationOrder = "操作指令"
MulticonnectMode = "多连接模式"
FindRoute = "寻找路线"
FindRouteChan1 = "查找路由通道 1"
FindRouteChan2 = "查找路由通道 2"
FindRouteStatus = "查找路由状态"
IsDebounced = "已去抖动"

[PropDescr_IVI]
IsScanning = "正在扫描"
CanConnect = "可以连接"
CanConnectChan1 = "可以连接通道 1"
CanConnectChan2 = "可以连接通道 2"
IsDebounced = "已去抖动"
GetPath = "获取路径"
GetPathChan1 = "获取路径通道 1"
GetPathChan2 = "获取路径通道 2"
GetNumOfColumns = "获取列数"
GetNumOfRows = "获取行数"
ChannelInfo = "频道信息"

[PropDescr_NI_IviSwitchChanInfo]
ChannelName = "频道名称"
GetBandWidth = "获取带宽"
GetCharacteristicImpedance = "获取特性阻抗"
GetMaxACVoltage = "获取最大交流电压"
GetMaxCarryACCurrent = "获取最大进位交流电流"
GetMaxCarryDCCurrent = "获取最大承载直流电流"
GetMaxCarryDCPower = "获取最大承载直流功率"
GetMaxDCVoltage = "获取最大直流电压"
GetMaxSwitchACCurrent = "获取最大开关交流电流"
GetMaxSwitchACPower = "获取最大开关交流功率"
GetMaxSwitchingDCCurrent = "获取最大开关直流电流"
GetMaxSwitchingDCPower = "获取最大开关直流功率"
GetSettlingTime = "获取稳定时间"
GetWireMode = "获取有线模式"
IsConfigurationChan = "是配置通道"
IsSourceChan = "是源频道"

[PropDescr_NI_IviSwitchScanningConfig]
ScanList = "扫描列表"
ScanAdvancedOutput = "扫描高级输出"
ScanMode = "扫描模式"
SoftwareScanMode = "软件扫描模式"
TriggerInput = "触发输入"
ScanDelay = "扫描延迟"
ContinuousScan = "连续扫描"

[PropDescr_NI_IviSwitchWait]
WaitOperation = "等待操作"
MaxTime = "最大时间"

[PropDescr_Configure]
MakeConfigurationChanChannel = "创建配置通道"
MakeConfiguation = "进行配置"
MakeSourceChanChannel = "创建源频道"
MakeSource = "制作来源"
SetPath = "设置路径"

[PropDescr_NI_OpenDatabase]
ConnectionString = "连接字符串"
DatabaseHandle = "数据库句柄（数字）"

[PropDescr_NI_OpenSQLStatement]
PageSize = "记录中的页面大小"
CommandTimeout = "命令超时"
CacheSize = "缓存大小"
MaxRecordsToSelect = "要选择的最大记录数"
CursorType = "游标类型"
CursorLocation = "光标位置"
MarshalOptions = "元帅选项"
LockType = "锁定类型"
CommandType = "命令类型"
DatabaseHandle = "数据库句柄（数字）"
StatementHandle = "语句句柄（数字）"
SQLStatement = "SQL语句"
NumberOfRecordsSelected = "选择的记录数"

[PropDescr_NI_CloseSQLStatement]
StatementHandle = "语句句柄（数字）"

[PropDescr_NI_CloseDatabase]
DatabaseHandle = "数据库句柄（数字）"

[PropDescr_NI_DataOperation]
DatabaseHandle = "数据库句柄（数字）"
RecordToOperateOn = "记录操作"
RecordIndex = "记录索引"
ColumnListSource = "列列表来源"
SQLStatement = "SQL语句"
ColumnList = "列值"

[PropDescr_PythonStepAdditions]
SData = "Python 适配器属性"
PythonCall = "Python 适配器属性"
UseAdapterSettingsForInterpreterSession = "为 Python 解释器使用适配器设置"
InterpreterSessionScope = "要使用的 Python 解释器"
PythonVersion = "Python 版本"
PythonVirtualEnvironmentPath = "Python 虚拟环境"
InterpreterLocation = "解释器参考"
CreateIfInterpreterDoesNotExist = "如果不存在则创建解释器"
ModulePath = "Python 模块路径"
OperationType = "操作类型"
OperationScope = "操作范围"
ClassName = "类名"
ClassInstanceLocation = "类实例"
FunctionOrAttributeName = "函数/属性名称"

[PropDescr_NI_PythonParameter]
Name = "名称"
Type = "类型"
ArgumentValue = "值"


[RPT_FLAGGED_NAME]
MEASUREMENT = "测量"
NUMERIC = "测量值"
CHANNEL = "频道"
TYPE = "类型"
INITIALX = "初始 X"
DELTAX = "增量 X"
DATA = "数据"
LIMITS ="限制"
LOW ="低"
HIGH = "高"
COMP = "比较类型"

STRING = "字符串"
UNITS = "单位"
BUTTONHIT = "按钮索引"
TIMEOUTOCCURED = "发生超时"
RESPONSE = "对话框响应文本"
EXITCODE = "退出代码"
NUMLIMITSINFILE = "文件中的限制数"
NUMROWSINFILE = "文件中的行数"
NUMLIMITSAPPLIED = "应用的限制数"
PASSFAIL = "通过/失败"
NUMPROPERTIESREAD = "读取的属性数"
NUMPROPERTIESAPPLIED = "应用的属性数"
TIMEOUTOCCURRED = "发生超时"
STATUS = "阅读"
状态 = "状态"

[RPT_FLAGGED_NAME_COMP]
EQ = "EQ (==)"
EQT = "EQT (== +/-)"
NE = "NE (!=)"
GT = "GT (>)"
LT = "LT (<)"
GE = "GE (>=)"
LE ="LE（<=）"
GTLT = "GTLT (> <)"
GELE = "GELE (>= <=)"
GELT = "GELT (>= <)"
GTLE = "GTLE (> <=)"
LTGT = "LTGT (< >)"
LEGE = "LEGE (<= >=)"
LTGE = "LTGE (< >=)"
LEGT = "LEGT (<= >)"
LOG = "无比较"
CaseSensitive = "区分大小写"
IgnoreCase = "忽略大小写"

[TSOTFRG]
UnspecifiedError = "未指定的错误"
NotInitialized = "未初始化"
CantChangeReportFormat = "报告格式一旦开始执行就不能更改。"
InvalidStepGroup = "无效步骤组"
InvalidSequenceContext = "无效序列上下文"
ErrorCreatingTempReportFile = "创建临时报告文件时出错。"
ErrorSavingReportFile = "保存报告文件时发生错误。"
UnableToLoadLibrary = "无法从 <TestStand>\\bin 文件夹加载库 dbghelp.dll"

[WORDS]
;;译者注意：我想用"或"一词分隔任意数量的字符串，
;;例如数字或字符串或参考。该字符串将像这样构建：
;; Number INFIX_OR String INFIX_OR Reference POSTFIX_OR。我的印象是用日语
;; INFIX_OR 和 POSTFIX_OR 可以是同一个词，这是有意义的。
INFIX_OR = " or "
POSTFIX_OR = ""
ELLIPSIS = "..."


[STEP_SELECTION]
INDICES_OF_SELECTED_STEPS_PANE_TEXT = "已选择 %1 个步骤 [%2]"
INDEX_OF_SELECTED_STEP_PANE_TEXT = "已选择 1 个步骤 [%1]"
NO_SELECTED_STEPS_PANE_TEXT = "没有选择步骤"
NUM_STEPS_PANE_TEXT = "步数：%1"
CURRENT_STEP_INDEX_PANE_TEXT = "当前步骤索引：%1"
NAMED_STEP_IS_CURRENT_STEP_PANE_TEXT = "当前步骤：'%1'"
NAMED_STEP_SELECTED_PANE_TEXT = "已选择'%1'"
NONE_STEP_PANE_TEXT = "无"
STEP_TERMINATOR = "<结束组>"
STEP_INSERTION_POINT = "<插入点>"

INDICES_OF_SELECTED_TESTS_PANE_TEXT = "已选择 %1 个测试 (%2)"
INDEX_OF_SELECTED_TEST_PANE_TEXT = "已选择 1 个测试 (%1)"
NO_SELECTED_TESTS_PANE_TEXT = "没有选择测试"
NUM_TESTS_PANE_TEXT = "测试数量：%1"
CURRENT_TEST_INDEX_PANE_TEXT = "当前测试编号：%1"

[ENUM_VALUES]
ModuleLoadOptions.LoadOption_PreloadWhenOpened = "打开序列文件时预加载"
ModuleLoadOptions.LoadOption_PreloadWhenExecuted = "执行开始时预加载"
ModuleLoadOptions.LoadOption_DynamicLoad = "动态加载"

ModuleUnloadOptions.UnloadOption_AfterSequenceExecution = "序列执行后卸载"
ModuleUnloadOptions.UnloadOption_AfterStepExecution = "步骤执行后卸载"
ModuleUnloadOptions.UnloadOption_OnPreconditionFailure = "前提条件失败时卸载"
ModuleUnloadOptions.UnloadOption_WithSequenceFile = "卸载序列文件时卸载"
			
WindowActivationOptions.WinActOption_ActivateWhenStepCompletes = "步骤完成时激活"
WindowActivationOptions.WinActOption_IfActiveReactivateWhenStepCompletes = "如果最初处于活动状态，则在步骤完成时重新激活"
WindowActivationOptions.WinActOption_None = "不激活"

ResultRecordingOptions.ResultRecordingOption_Disabled = "禁用"
ResultRecordingOptions.ResultRecordingOption_Enabled = "启用"
ResultRecordingOptions.ResultRecordingOption_EnabledAndOverrideSequenceSetting = "已启用（覆盖序列设置）"

BatchSynchronizationOptions.BatchSyncOption_UseSeqFileSetting = "使用序列文件设置"
BatchSynchronizationOptions.BatchSyncOption_UseModelSetting = "使用模型设置"
BatchSynchronizationOptions.BatchSyncOption_NoSync = "不同步"
BatchSynchronizationOptions.BatchSyncOption_Serial = "串行（一次一个线程）"
BatchSynchronizationOptions.BatchSyncOption_Parallel = "并行（所有线程同时进入）"
BatchSynchronizationOptions.BatchSyncOption_OneThreadOnly = "只有一个线程（第一个线程执行步骤，其余线程跳过）"
			
EvalPrecondOptions.EvalPrecondOption_EvaluatePrecond = "评估前提条件"
EvalPrecondOptions.EvalPrecondOption_NoEvaluatePrecond = "不评估前提条件"
EvalPrecondOptions.EvalPrecondOption_UseStationOption = "使用站选项"

PostActionValues.PostAction_NextStep = "转到下一步"
PostActionValues.PostAction_GotoStep = "转到步骤"
PostActionValues.PostAction_Terminate = "终止执行"
PostActionValues.PostAction_CallCallback = "调用顺序"
PostActionValues.PostAction_Break = "中断"

StepLoopTypes.LoopType_Custom = "自定义"
StepLoopTypes.LoopType_FixedNumLoops = "固定循环次数"
StepLoopTypes.LoopType_NoLoop = "无"
StepLoopTypes.LoopType_PassFailCount = "通过/失败计数"

RunModes.RunMode_Normal = "正常"
RunModes.RunMode_Skip = "跳过"
RunModes.RunMode_ForcePass = "强制通过"
RunModes.RunMode_ForceFail = "强制失败"

SeqCallTraceSettings.SeqCallTrace_UseCurrent = "使用当前跟踪设置"
SeqCallTraceSettings.SeqCallTrace_Enable = "按顺序启用跟踪"
SeqCallTraceSettings.SeqCallTrace_Disable = "按顺序禁用跟踪"
SeqCallTraceSettings.SeqCallTrace_UseExecutionSetting = "使用初始执行设置"

HTBasicWorkingDirTypes.HTBasicWorkingDir_DoNotChange = "不要改变工作目录"
HTBasicWorkingDirTypes.HTBasicWorkingDir_HTBasicServer = "HTBasic 服务器目录"
HTBasicWorkingDirTypes.HTBasicWorkingDir_SubroutineFileDir = "子程序文件目录"
HTBasicWorkingDirTypes.HTBasicWorkingDir_AdapterDefault = "使用适配器默认值"
HTBasicWorkingDirTypes.HTBasicWorkingDir_Specify = "使用指定目录"

SeqCallMultithreadOptions.SeqCallMultithread_None = "无"
SeqCallMultithreadOptions.SeqCallMultithread_NewThread = "使用新线程"
SeqCallMultithreadOptions.SeqCallMultithread_NewExecution = "使用新执行"
SeqCallMultithreadOptions.SeqCallMultithread_Remote = "使用远程计算机"

SeqCallNewExecModelOptions.SeqCallNewExecModel_None = "不要使用进程模型"
SeqCallNewExecModelOptions.SeqCallNewExecModel_SpecifyModel = "使用特定的进程模型"
SeqCallNewExecModelOptions.SeqCallNewExecModel_UseModelOfCurrentFile = "使用指定客户端文件的进程模型"

SeqCallWaitForExecOptions.SeqCallWait_BeforeNextStep = "执行下一步之前"
SeqCallWaitForExecOptions.SeqCallWait_DoNotWait = "不要等待"
SeqCallWaitForExecOptions.SeqCallWait_EndOfSequence = "在当前序列的末尾"

DotNetModuleMemberTypes.DotNetMember_DoNotCall = "请勿调用"
DotNetModuleMemberTypes.DotNetMember_CallMethod = "调用方法"
DotNetModuleMemberTypes.DotNetMember_GetProperty = "获取属性"
DotNetModuleMemberTypes.DotNetMember_SetProperty = "设置属性"
DotNetModuleMemberTypes.DotNetMember_CallConstructor = "调用构造函数"

SwitchExecOperations.SwitchExecOperation_Connect = "连接"
SwitchExecOperations.SwitchExecOperation_Disconnect = "断开连接"
SwitchExecOperations.SwitchExecOperation_DisconnectAll = "全部断开"
SwitchExecOperations.SwitchExecOperation_ConnectDisconnect = "连接/断开连接"
SwitchExecOperations.SwitchExecOperation_FindRoute = "查找路线"

SwitchExecOperationOrders.SwitchExecOperationOrder_DisconnectBeforeConnect = "连接前断开"
SwitchExecOperationOrders.SwitchExecOperationOrder_DisconnectAfterConnect = "连接后断开"

SwitchExecLifetimes.SwitchExecLifetime_Manual = "手动"
SwitchExecLifetimes.SwitchExecLifetime_Execution = "执行"
SwitchExecLifetimes.SwitchExecLifetime_Thread = "线程"
SwitchExecLifetimes.SwitchExecLifetime_Sequence = "序列"
SwitchExecLifetimes.SwitchExecLifetime_Step = "步骤"

SwitchExecMulticonnectModes.SwitchExecMulticonnectMode_None = "无多重连接"
SwitchExecMulticonnectModes.SwitchExecMulticonnectMode_Multiconnect = "多连接路由"
SwitchExecMulticonnectModes.SwitchExecMulticonnectMode_Default = "使用路由的默认设置"

FailureActions.FailureAction_GotoCleanup = "去清理"
FailureActions.FailureAction_None = "无"
FailureActions.FailureAction_UseStationOption = "使用站点选项"

[WORKSPACE_DOCUMENTATION]
ReportConst.Header.Title = "工作区"
ReportConst.Header.Date = "日期"
ReportConst.Header.Time = "时间"
ReportConst.Header.Files = "文件"
ReportConst.Header.Missing = "缺失"
ReportConst.Header.Name = "名称"
ReportConst.Header.Type = "类型"
ReportConst.Header.Path = "路径"
ReportConst.Header.File_Version = "文件版本"
ReportConst.Header.File_Format = "文件格式"
ReportConst.Header.Modification_Date = "修改日期"
ReportConst.Header.Workspace_Location = "工作区位置"
;; SCC 是"源代码控制"的缩写
ReportConst.Header.SccStatus = "SCC 状态"

WSDOC_TOOLMENU_TEXT = "工作区文件文档..."
TITLE = "工作区文档"
WORKSPACE="工作区："
FORMAT = "报告格式："
DESTINATION = "报告目的地："
REPORT_DESTINATION = "报告目的地"
TEMPLATE_FILE = "模板文件"

HTML = "HTML"
TEXT = "Text"

DEFAULT_REPORT_NAME = "工作区文档"

PROPERTIES_TO_DOCUMENT = "要记录的属性"
NUMBER_OF_FILES = "文件数量"
ABSOLUTE_PATH = "绝对路径"
FILE_VERSION = "文件版本"
FILE_FORMAT = "文件格式"
MODIFICATION_DATE = "修改日期"

LAUNCH_VIEWER = "启动查看器"

PROGRESS_LABEL = "正在生成："

ERROR_EMPTY = "%1 为空。请选择一个 %1。"
ERROR_NOWORKSPACE = "没有当前的工作空间。请打开所需的工作空间来记录。"
ERROR_FILE_VERSION_UNKOWN = "未知"
ERROR_FILE_FORMAT_UNKOWN = "未知"

SELECT_WORKSPACE = "选择工作区..."

REPORT_FINISHED = "报告已创建。"

Scc.CheckedIn = "签入"
Scc.CheckedOutByOther = "已被其他人签出"
Scc.CheckedOutByYouAndOther = "你和其他人签出"
Scc.CheckedOutByYou = "已由您签出"

WorkspaceObjType_WorkspaceFile = "工作区"
WorkspaceObjType_ProjectFile = "项目"
WorkspaceObjType_Folder = "文件夹"
WorkspaceObjType_SequenceFile = "序列文件"
WorkspaceObjType_OtherFile = "其他"

;;当不再支持旧的资源使用分析器时，可以删除部分
[RESOURCE_USAGE_PROFILER]
CLEAR = "清除"
CLOSE = "关闭"
RESOURCE_USAGE_PROFILER_TITLE = "资源使用分析器"
RESOURCE_USAGE_PER_THREAD = "每个线程的资源使用"
THREAD_USAGE_PER_RESOURCE = "每个资源的线程使用情况"
FIRST_EVENT_TIME = "首次活动时间"
LAST_EVENT_TIME = "上次活动时间"
TIMESPAN = "总时间跨度"
VISIBLE_EVENTS = "可见事件"
HIDDEN_EVENTS = "隐藏事件"
INCOMPLETE_OPERATIONS = "未完成的操作"
TIMESPAN_OF_SELECTED_OPERATIONS = "选定操作的时间跨度"
LOCK_EVENTS = "锁定事件"
AUTO_SCHEDULE_USE_RESOURCE_EVENTS = "自动安排使用资源事件"
BATCH_SYNCHRONIZED_SECTION_EVENTS = "批量同步部分事件"
NOTIFICATION_EVENTS = "通知事件"
QUEUE_EVENTS = "队列事件"
RENDEZVOUS_EVENTS = "会合事件"
SEMAPHORE_EVENTS = "信号量事件"
WAIT_EVENTS = "等待事件"
PROCESS_MODEL_EVENTS = "处理模型事件"
HIDDEN="隐藏"
STEPSTEP = "步骤"
STEP_GROUP = "步骤组"
SEQUENCE="序列"
FILE = "文件"
SOURCE ="来源"
AUTOSCHEDULE = "自动计划"
LOCK = "锁定"
RESOURCE_ALTERNATIVE_INDEX = "资源替代索引"
THREAD = "线程"
EXECUTION ="执行"
RESOURCE_NAME = "资源名称"
OPERATION_NAME = "操作"
EVENT ="事件"
TIME = "时间（秒）"
ABSOLUTE_TIME = "绝对时间"
TIMEOUT_PERIOD = "超时时间（秒）"
SOCKET_SUFFIX = "{套接字: %1}"
STEP_INDEX = "步骤索引"
TEST_SOCKET = "测试插座"
OPERATION_INDEX = "操作索引"
SYNCHRONIZATION_STATE = "状态"
ZOOM_MODE = "缩放模式："
MANUAL = "手动"
FIT_TO_WINDOW = "适合窗口"
ZOOM_PERCENT = "缩放百分比："
STATISTIC = "统计"
VALUE ="价值"
SUMMARY ="总结"
RESOURCES ="资源"
EXECUTIONS ="执行"
THREADS = "线程"
OPERATIONS ="操作"
EVENTS ="事件"
RESOURCE = "资源"
OPERATION ="操作"
TIME_IN_USE = "使用时间（秒）"
PERCENT_TIME_IN_USE = "使用时间百分比"
TIME_BLOCKED = "封锁时间（秒）"
PERCENT_TIME_BLOCKED = "阻塞时间百分比"
CUMULATIVE_TIME_IN_USE_FOR_ALL_THREADS = "所有线程的累计使用时间（秒）"
CUMULATIVE_TIME_BLOCKED_FOR_ALL_THREADS = "所有线程的累计阻塞时间（秒）"
ACCESSING_THREADS = "访问线程"
TRUE = "真"
FALSE = "假"
COMPLETED = "完成"
START_TIME = "开始时间（秒）"
END_TIME = "结束时间（秒）"
DURATION = "持续时间（秒）"
IN_USE_TIME = "使用时间（秒）"
BLOCKED_TIME = "阻塞时间（秒）"
RESOURCE_USAGE_TOOL_ITEM = "分析资源使用情况"
INDEX = "索引"
THREAD_ID = "线程 ID"
EXECUTION_ID = "执行 ID"
FILE_FILTER = "资源使用配置文件 (*.tpf)|*.tpf||"
SAVE_PROFILE = "保存配置文件"
SAVE = "保存"
OPEN ="打开"
OPEN_PROFILE = "打开配置文件"
FILE_EXTENSION = "tpf"
UNABLE_TO_OPEN_PROFILE_FILE = "无法打开配置文件。"
UNABLE_TO_SAVE_PROFILE_FILE = "无法保存配置文件。"
UNNAMED_SYNC_OBJECT = "未命名的同步对象"
WARNING = "警告"
PLEASE_NOTE = "请注意"
SAVING_INCOMPLETE_OPERATIONS = "配置文件包含 %1 个未完成的操作。您确定要保存吗？"
PAUSED_DUE_TO_LOAD = "分析器显示暂停，因为你已经加载了一个配置文件。请注意，分析器在显示暂停时保留新事件，如果你恢复显示，这些事件将变得可见。"
FILE_MENU = "&文件"
OPEN_ITEM = "&打开..."
SAVE_ITEM = "&保存..."
EXIT_ITEM = "退出&退出"
EDIT_MENU = "&编辑"
COPY_ITEM = "&复制"
DELETE_ITEM = "&删除"
SELECT_ALL_ITEM = "&全选"
VIEW_MENU = "&视图"
SHOW_WAITS_ITEM = "显示阻塞线程"
SHOW_PROCESS_MODELS_ITEM = "显示进程模型"
SHOW_LOCKS_ITEM = "显示锁"
SHOW_AUTOSCHEDULING_ITEM = "显示自动调度"
SHOW_BATCH_ITEM = "显示批量同步部分"
SHOW_QUEUES_ITEM = "显示队列"
SHOW_NOTIFICATIONS_ITEM = "显示通知"
SHOW_SEMAPHORES_ITEM = "显示信号量"
SHOW_RENDEZVOUS_ITEM = "显示会合点"
SHOW_WAIT_OPERATIONS_ITEM = "显示等待操作"
SHOW_ALL_OPERATIONS_ITEM = "显示全部"
SHOW_NO_OPERATIONS_ITEM = "不显示"
DISCARD_HIDDEN_EVENTS_ITEM = "丢弃隐藏信息"
GOTO_SEQUENCE_FILE_ITEM = "转到序列文件中的步骤"
GOTO_EXECUTION_ITEM = "转到执行步骤"
SELECT_ASSOCIATED_ITEM = "选择关联"
SELECT_EVENTS_ITEM = "事件"
SELECT_OPERATIONS_ITEM = "操作"
SELECT_THREADS_ITEM = "线程"
SELECT_EXECUTIONS_ITEM = "执行"
SELECT_RESOURCES_ITEM = "资源"
HELP_MENU = "&帮助"
HELP_OVERVIEW_ITEM = "&帮助概览"
HELP_TOPIC_ITEM = "帮助主题(&T)"
DISCARD_EVENTS_MSG = "你确定要删除 %1 个当前隐藏的事件并丢弃任何未来的隐藏事件吗？"
DELETE_ITEMS_MSG = "您确定要删除 %1 个选定的 %2 吗？\n\n%3 个事件将被删除。"
DELETE_EVENTS_MSG = "您确定要删除 %1 个选定事件吗？"
DELETE_EVENTS_AND_ASSOCIATED_EVENTS_MSG = "您确定要删除 %1 个选定事件和 %2 个相关事件吗？"
DISCARD_HIDDEN_INFORMATION_ENABLED = "（隐藏信息的丢弃已启用）"
SECONDS_SUFFIX = "(s)"
THREAD_BLOCKED = "线程阻塞"
RESOURCE_IN_USE = "正在使用的资源"
OPERATION_LEGEND = "行动图例："
PAUSE_DISPLAY = "暂停显示"
RESUME_DISPLAY = "恢复显示"

;;当不再支持旧的资源使用分析器时，可以删除部分
[SYNCHRONIZATION_MECHANISMS]
NotASynchronizationMechanism = "不是同步机制"
Semaphore = "信号量"
Lock = "锁定"
Rendezvous="集合点"
Queue = "队列"
Notification="通知"
Batch ="批次"
AutoSchedule = "自动计划"
Wait ="等待"

[PROFILER_WINDOW]
PROFILER_TOOL_ITEM = "分析执行"
CLEAR = "清除"
CLOSE = "关闭"
PROFILER_WINDOW_TITLE = "TestStand 执行分析器"
ITEM_USAGE_PER_THREAD = "每个线程的物品使用情况"
THREAD_USAGE_PER_ITEM = "每个项目的线程使用"
FIRST_EVENT_TIME = "首次活动时间"
LAST_EVENT_TIME = "上次活动时间"
TIMESPAN = "总时间跨度"
VISIBLE_EVENTS = "可见事件"
HIDDEN_EVENTS = "隐藏事件"
INCOMPLETE_OPERATIONS = "未完成的操作"
TIMESPAN_OF_SELECTED_OPERATIONS = "选定操作的时间跨度"
LOCK_EVENTS = "锁定事件"
AUTO_SCHEDULE_USE_RESOURCE_EVENTS = "自动安排使用资源事件"
BATCH_SYNCHRONIZED_SECTION_EVENTS = "批量同步部分事件"
NOTIFICATION_EVENTS = "通知事件"
QUEUE_EVENTS = "队列事件"
RENDEZVOUS_EVENTS = "会合事件"
SEMAPHORE_EVENTS = "信号量事件"
WAIT_EVENTS = "等待事件"
PROCESS_MODEL_EVENTS = "处理模型事件"
HIDDEN="隐藏"
STEP = "步骤"
STEP_GROUP = "步骤组"
SEQUENCE ="序列"
FILE = "文件"
SOURCE="来源"
AUTOSCHEDULE = "自动计划"
LOCK = "锁定"
RESOURCE_ALTERNATIVE_INDEX = "资源替代索引"
THREAD = "线程"
EXECUTION="执行"
ITEM_NAME = "项目名称"
OPERATION_NAME = "操作"
EVENT ="事件"
TIME = "时间"
ABSOLUTE_TIME = "绝对时间"
TIMEOUT_PERIOD = "超时期限"
SOCKET_SUFFIX = "{套接字: %1}"
STEP_INDEX = "步骤索引"
TEST_SOCKET = "测试插座"
OPERATION_INDEX = "操作索引"
SYNCHRONIZATION_STATE = "状态"
STATISTIC = "统计"
VALUE = "值"
SUMMARY = "总结"
ITEMS = "物品"
EXECUTIONS = "执行"
THREADS = "线程"
OPERATIONS = "操作"
EVENTS = "事件"
ITEM = "项目"
OPERATION = "操作"
TIME_IN_USE = "使用时间"
PERCENT_TIME_IN_USE = "使用时间百分比"
TOTAL_ACTUAL_TIME_IN_USE = "实际使用时间"
PERCENT_ACTUAL_TIME_IN_USE = "实际使用时间百分比"
TOTAL_CPU_TIME = "累计时间"
TOTAL_CPU_IN_USE_TIME = "累计使用时间"
TOTAL_CPU_BLOCKED_TIME = "累计阻塞时间"
AVERAGE_CPU_TIME = "平均"
MAX_CPU_TIME = "最大"
MIN_CPU_TIME = "最小"
TIME_BLOCKED = "时间阻塞"
MODULE_PATH = "模块路径"
MODULE_ENVIRONMENT = "模块环境"
MODULE_INPUTS_AND_OUTPUTS = "模块输入和输出"
LEVEL = "水平"
PERCENT_TIME_BLOCKED = "阻塞时间百分比"
ACCESSING_THREADS = "访问线程"
TRUE = "真"
FALSE = "假"
COMPLETED = "完成"
START_TIME = "开始时间"
END_TIME = "结束时间"
DURATION = "持续时间"
IN_USE_TIME = "使用时间"
BLOCKED_TIME = "封锁时间"
INDEX = "索引"
THREAD_ID = "线程 ID"
EXECUTION_ID = "执行 ID"
FILE_FILTER = "TestStand 配置文件 (*.tpf)|*.tpf||"
SAVE_PROFILE = "保存配置文件"
SAVE = "保存"
OPEN = "打开"
MERGE = "合并"
OPEN_PROFILE = "打开配置文件"
MERGE_PROFILE = "合并配置文件"
FILE_EXTENSION = "tpf"
UNABLE_TO_OPEN_PROFILE_FILE = "无法打开配置文件。"
UNABLE_TO_SAVE_PROFILE_FILE = "无法保存配置文件。"
UNNAMED_SYNC_OBJECT = "未命名的同步对象"
WARNING = "警告"
PLEASE_NOTE = "请注意"
SAVING_INCOMPLETE_OPERATIONS = "配置文件包含 %1 个未完成的操作。您确定要保存吗？"
PAUSED_DUE_TO_DATA_LOAD = "分析器数据收集已暂停，因为您加载了分析数据。您可以随时恢复数据收集。"
DISABLED_DATA_DISCARDING = "为避免在加载配置文件信息时意外丢失数据，分析器已关闭自动丢弃隐藏分析信息的选项。您可以随时重新启用此选项。"
FILE_MENU = "&文件"
OPEN_ITEM = "&打开..."
MERGE_ITEM = "&合并..."
SAVE_ITEM = "&保存..."
OPTIMIZE_PROFILING_SPEED_ITEM = "配置数据收集..."
EXIT_ITEM = "退出"
EDIT_MENU = "&编辑"
COPY_ITEM = "&复制"
DELETE_ITEM = "&删除"
SELECT_ALL_ITEM = "&全选"
VIEW_MENU = "&视图"
SHOW_WAITS_ITEM = "显示阻塞的线程"
SHOW_PROCESS_MODELS_ITEM = "显示进程模型"
SHOW_LOCKS_ITEM = "显示锁"
SHOW_AUTOSCHEDULING_ITEM = "显示自动调度"
SHOW_BATCH_ITEM = "显示批量同步部分"
SHOW_QUEUES_ITEM = "显示队列"
SHOW_NOTIFICATIONS_ITEM = "显示通知"
SHOW_SEMAPHORES_ITEM = "显示信号量"
SHOW_RENDEZVOUS_ITEM = "显示会合点"
SHOW_WAIT_OPERATIONS_ITEM = "显示等待操作"
SHOW_ALL_OPERATIONS_ITEM = "显示全部"
SHOW_NO_OPERATIONS_ITEM = "不显示"
DISCARD_HIDDEN_EVENTS_ITEM = "丢弃隐藏信息"
GOTO_SEQUENCE_FILE_ITEM = "转到序列文件中的位置"
GOTO_EXECUTION_ITEM = "转到执行中的位置"
SELECT_ASSOCIATED_ITEM = "选择关联"
SELECT_EVENTS_ITEM = "事件"
SELECT_OPERATIONS_ITEM = "操作"
SELECT_THREADS_ITEM = "线程"
SELECT_EXECUTIONS_ITEM = "执行"
SELECT_ITEMS_ITEM = "项目"
HELP_MENU = "&帮助"
HELP_OVERVIEW_ITEM = "&帮助概览"
HELP_TOPIC_ITEM = "帮助主题"
DISCARD_EVENTS_MSG = "你确定要删除 %1 个当前隐藏的事件并丢弃任何未来的隐藏事件吗？"
DELETE_ITEMS_MSG = "您确定要删除 %1 个选定的 %2 吗？\n\n%3 个事件将被删除。"
DELETE_EVENTS_MSG = "您确定要删除 %1 个选定事件吗？"
DELETE_EVENTS_AND_ASSOCIATED_EVENTS_MSG = "您确定要删除 %1 个选定事件和 %2 个相关事件吗？"
DISCARD_HIDDEN_INFORMATION_ENABLED = "（隐藏信息的丢弃已启用）"
SECONDS_SUFFIX = "(s)"
MILLISECONDS_SUFFIX = "(毫秒)"
THREAD_BLOCKED = "线程阻塞"
ITEM_IN_USE = "使用中的物品"
OPERATION_LEGEND = "行动图例："
PAUSE_UPDATES = "暂停更新"
STEPTYPEMODULE_EVENTS = "步骤类型模块事件"
STEPMODULE_EVENTS = "步骤模块事件"
STEP_EVENTS = "步骤事件"
UUT_EVENTS = "UUT 事件"
BATCH_EVENTS = "批量事件"
LOT_EVENTS = "批次事件"
SHOW_SYNCHRONIZATION = "显示同步"
SHOW_CODE_MODULES = "显示代码模块"
SHOW_UUTS_BATCHES_AND_LOTS = "显示 UUT、批次和批次"
STEP_MODULES = "步骤"
STEP_TYPE_MODULES = "步骤类型"
MODULE_LOADS = "加载"
MODULE_UNLOADS = "卸载"
LOAD_UNLOAD = "加载/卸载"
IN_USE_ACTIVE = "使用中/活动中"
BLOCKED = "阻塞"
SHOW_STEPS = "显示步骤"
SHOW_SUSPENSIONS = "显示暂停"
HIDE_OPERATIONS_SHORTER_THAN = "隐藏短于 %1 的已完成操作："
PROMPT_TO_TURN_OFF_OPTIMIZATIONS = "由于您在配置数据收集对话框中的设置，当前未收集指定类型的信息。\n\n您现在要重新启用这些类型的信息收集吗？ "
PROMPT_TO_TURN_OFF_OPTIMIZATIONS_DIALOG_TITLE = "数据收集设置冲突"
HIDING_DATA = "配置数据收集对话框指定不收集某些可见类别的探查器数据。这些数据类别现在已隐藏。如果您在配置数据收集对话框中重新启用数据收集，请记住还要选择从视图菜单显示相应类别的数据。"
HIDING_DATA_WARNING_TITLE = "隐藏分析器数据"
OLD_RESOURCE_USAGE_PROFILER_FILE = "此配置文件是一个资源使用配置文件。您必须使用 TestStand 2014 或更早版本中过时的 Resource Usage Profiler 工具加载它。"
ERROR_TITLE = "错误"
ZOOM = "缩放%"
AUTO_FIT = "自动调整"
ZOOM_IN = "放大"
ZOOM_OUT = "缩小"
ZOOM_TO_SELECTION = "缩放到选择"
NO_SERIAL_NUMBER = "<无序列号>"
NO_LOT_ID = "<没有批号>"
LOT = "很多："
MOVE_SELECTED_OPERATIONS = "移动选定的操作..."
INVERT_SELECTION = "反转选择"
NOT_AN_EXECUTION = "<非执行>"
TIME_UNITS = "时间单位"
MILLISECONDS = "毫秒 (ms)"
SECONDS = "秒数"
SELECT_ALL_INTERSECTING_TIMESPAN = "选择与选择重叠的操作"
SELECT_ALL_WITHIN_TIMESPAN = "在选择范围内选择操作"
RUNNING = "运行"
PAUSED = "暂停"
DATA_COLLECTION_BUTTON_TIP = "收集分析信息"
UPDATE_DISPLAY_BUTTON_TIP = "更新显示"
STOP_COLLECTING_WITH_INCOMPLETE_OPERATIONS_MSG = "已停止数据收集。\n\n当前有 %1 个操作仍在进行中。如果操作完成而数据收集被禁用，探查器将不会意识到完成并且操作将看起来从未完成.\n\n您要删除所有正在进行的操作吗？"
DELETE_LOADED_INCOMPLETE_OPERATIONS_MSG = "当前有 %1 个操作正在进行。如果这些操作来自之前保存的配置文件中的事件，则操作可能永远不会完成。\n\n你想删除所有正在进行的操作吗？"
TOO_SHORT_EVENTS = "由于操作持续时间不足而隐藏的事件"
DIFF_SELECTED_THREADS = "比较选定的线程..."
YOU_MUST_SELECT_TWO_THREADS = "你必须选择两个线程。"
DIFF_RESULTS = "找到 %1 对匹配操作并进行比较。找到 %2 对不匹配的操作并保持不变。"
SUSPENSION_EVENTS = "暂停/断点事件"
LOG_FILE_NEWLINE_REPLACEMENT = " "
LOG_FILE_COLUMN_SEPARATOR = "\t"
LOG_FILE_FOUR_SPACES_REPLACEMENT = " "

[PROFILER_OPTIMIZATION_DIALOG]
OPTIMIZE_PROFILING_DIALOG_TITLE = "配置数据收集"
OPTIMIZE_DIALOG_EXPLANATION_TEXT = "您可以通过减少探查器收集的信息量来减少探查器执行速度减慢的程度。取消选中您不需要探查器收集的信息类型。"
LOCATIONS = "位置（允许导航到文件和执行）"
PROCESS_MODELS = "过程模型"
SYNCHRONIZATION = "同步"
STEPS = "步骤"
MODULE_LOADS = "模块加载"
MODULE_UNLOADS = "模块卸载"
STEP_MODULES = "步骤模块"
STEP_TYPE_MODULES = "步骤类型模块"
ADAPTERS = "模块适配器："
ok = "确定"
CANCEL = "取消"
MEMORY_LIMIT_EXPLANATION = "您可以通过指定分析器在事件数量超过阈值时定期丢弃最旧的分析事件来限制分析器消耗的内存量。您还可以指定分析器定期丢弃指定持续时间之前的事件。 "
LIMIT_NUMBER_OF_EVENTS = "限制保留事件的数量"
LIMIT_PROFILE_DURATION = "以秒为单位限制配置文件的持续时间"
MODULE_FULL_PATHS_AND_ENVIRONMENTS = "模块路径和环境"
MODULE_INPUTS = "模块输入"
MODULE_OUTPUTS = "模块输出"
LIMIT_MODULE_INPUT_OUTPUT_TEXT_LENGTH = "限制模块输入/输出文本长度"
OPERATIONS_LOGGING = "指定一个文本文件来记录操作完成："
BROWSE_FOR_OPERATIONS_LOG_FILE_TIP = "浏览文件"
CLEAR_FILE_CONTENTS = "清除文件内容"
CREATE_FILE = "创建文件"
VIEW_LOG_FILE = "查看文件"
ERROR_TITLE = "错误"
SELECT_LOG_FILE_DLG_TITLE= "选择要记录已完成操作的文件"
SELECT_LOG_FILE_OK = "确定"
SELECT_LOG_FILE_FILTER = "文本文件 (*txt)|*.txt||"


[PROFILER_MOVE_SELECTED_OPERATIONS_DIALOG]
MOVE_OPERATIONS_DIALOG_TITLE = "移动选定的操作"
MOVE_OPERATION_EXPLANATION = "更改所选操作的开始时间。"
CURRENT_START_TIME = "当前初始时间："
NEW_START_TIME = "新的初始时间："
ok = "确定"
CANCEL = "取消"
MARK_WITH_COLOR = "用颜色标记："
DO_NOT_MARK = "不要标记"
MOVE_TO_UNIQUE_THREADS = "移动到唯一线程"

[PROFILER_DIFF_DIALOG]
DIFF_DIALOG_TITLE = "比较选定的话题"
DIFF_OPERATION_EXPLANATION = "对于匹配操作，将较长操作的长度减少较短操作的长度，并将较短操作的长度减少为零。"
ok = "确定"
CANCEL = "取消"
MARK_REDUCED_OPERATIONS_WITH_COLOR = "用颜色标记减少的操作："
DO_NOT_MARK = "不要标记"
MOVE_DIFFERENCES_TO_UNIQUE_THREADS = "将减少的操作移至唯一线程"

[PROFILER_MERGE_DIALOG]
MERGE_PROFILE_DIALOG_TITLE = "合并剖析数据"
MERGE_EXPLANATION = "指定如何将文件中的新数据与当前加载的数据合并。\r\n\r\n当前加载的数据从 %1 扩展到 %2。\r\n\r\n文件中的数据从 %3 延伸到 %4。"
POSITION_OF_NEW_DATA = "新数据的位置："
BEFORE_EXISTING_DATA = "在当前数据之前"
AFTER_EXISTING_DATA = "在当前数据之后"
OVERLAP_EXISTING_DATA = "重叠当前数据"
PRESERVE_ABSOLUTE_TIME = "不要更改新数据事件时间"
ok = "确定"
CANCEL = "取消"
MARK_WITH_COLOR = "用颜色标记："
DO_NOT_MARK = "不要标记"
MOVE_TO_UNIQUE_THREADS = "移动到唯一线程"


[PROFILER_MECHANISMS]
NotASynchronizationMechanism = "不是同步机制"
Semaphore = "信号量"
Lock = "锁定"
Rendezvous="集合点"
Queue = "队列"
Notification="通知"
BatchSynchronization = "批量同步"
AutoSchedule = "自动计划"
Wait = "等待"
StepTypeModule = "步骤类型模块"
StepModule = "步骤模块"
Step = "步骤"
UUT = "UUT"
Batch = "批次"
Lot = "很多"

;;当不再支持旧的资源使用分析器时，可以删除部分
[SYNCHRONIZATION_OPERATIONS]
UseResource = "使用资源"
TimeMultiple = "时间倍数"
TimeInterval = "时间间隔"
Thread = "线程"
Execution ="执行"
Enter = "输入"
Exit = "退出"
Lock = "锁定"
Unlock = "解锁"
Wait = "等待"
Set ="设置"
Clear = "清除"
Pulse ="脉冲"
Enqueue = "入队"
Dequeue = "出队"
Flush = "刷新"
Rendezvous = "集合点"
Acquire = "获取"
Release = "发布"

[PROFILER_OPERATIONS]
UseResource = "使用资源"
TimeMultiple = "时间倍数"
TimeInterval = "时间间隔"
Thread = "线程"
Execution = "执行"
Enter = "输入"
Exit = "退出"
Lock = "锁定"
Unlock = "解锁"
Wait = "等待"
Set = "设置"
Clear = "清除"
Pulse = "脉冲"
Enqueue = "入队"
Dequeue = "出队"
Flush = "刷新"
Rendezvous = "集合点"
Acquire = "获取"
Release = "发布"
Execute = "执行"
Load = "加载"
Unload = "卸载"
Test = "测试"


[BatchSyncType]
BatchSyncType_None = "无"
BatchSyncType_Serial = "串行"
BatchSyncType_Parallel = "并行"
BatchSyncType_OneThreadOnly = "只有一个线程"

[MIGRATION_TOOL]
;;界面控件
MIGRATION_TOOL_TITLE = "TestStand %TARGET_VERSION% 移植工具"
MIGRATION_TOOL = "迁移工具"
CONFLICTS_BOX_LABEL = "冲突"
PROGRESS_DLG_TEXT = "确定要从 TestStand %SOURCE_VERSION% 迁移的文件"
VER_SEL_COMBO_LABEL = "选择要迁移的版本："
NEXT_BTN_LABEL = "下一步 >>"
BACK_BTN_LABEL = "<< 返回"
CANCEL_BTN_LABEL = "取消"
&FILES_TO_COPY = "&文件复制"
FILES_TO_MIGRATE = "要迁移的 TestStand %SOURCE_VERSION% 个文件"
FILES_TO_MIGRATE_TOOLTIP = "选择 TestStand %SOURCE_VERSION% 文件迁移到 TestStand %TARGET_VERSION%"
SINCE_INSTALL = "自安装以来"
SINCE_INSTALL_TOOLTIP = "指示自从您安装 TestStand %SOURCE_VERSION% 后文件是否已更改或已添加"
NEW = "新建"
MODIFIED = "已修改"
IDENTICAL = "没有变化"
UNKNOWN = "未知"
MIGRATION_ACTION = "迁移操作"
MIGRATION_ACTION_TOOLTIP Line0001 = "表明迁移是将文件复制到 TestStand %TARGET_VERSION% 文件夹还是覆盖 TestStand %TARGET_VERSION% 文件夹中的现有文件。\r\n"
MIGRATION_ACTION_TOOLTIP Line0002 = "如果相应的 TestStand %TARGET_VERSION% 文件夹已经存在，该工具会将复制文件夹的内容添加到 TestStand %TARGET_VERSION% 文件夹的内容中。"
COPY = "复制"
OVERWRITE = "覆盖"
OVERWRITE_READONLY = "覆盖只读"
MIGRATION_ACTION_TO_NEW="应用于新模型"
MIGRATION_ACTION_TO_LEGACY="应用于遗留模型"
MIGRATION_ACTION_BOTH="适用于新旧模型"
DEFAULT_CONFIGURATION_SET_NAME="来自 TestStand %SOURCE_VERSION% 的选项"
COPY_SOURCE_PATH = "复制 TestStand %SOURCE_VERSION% 路径"
COPY_DESTINATION_PATH = "复制 TestStand %TARGET_VERSION% 路径"
COPY_LEGACY_DESTINATION_PATH = "复制旧版 TestStand %TARGET_VERSION% 路径"
EXPLORE_SOURCE_PATH = "探索 TestStand %SOURCE_VERSION% 路径"
EXPLORE_DESTINATION_PATH = "探索 TestStand %TARGET_VERSION% 路径"
EXPLORE_LEGACY_DESTINATION_PATH = "探索旧版 TestStand %TARGET_VERSION% 路径"
&HIDE_UNMODIFIED_FILES = "&隐藏自安装 TestStand %SOURCE_VERSION% 后未修改的文件"
BACKUP_&LOCATION = "&Location for backup of TestStand %TARGET_VERSION% public files:"
&REDIRECT_PATHS = "&Redirect TestStand 文件中引用 TestStand %SOURCE_VERSION% 文件夹的路径以使用 TestStand %TARGET_VERSION% 文件夹"
&MIGRATE_FILES = "&迁移文件"
BROWSE_BACKUP_TITLE = "选择备份文件夹"
NO_DIFFS = "TestStand %SOURCE_VERSION% 和 TestStand %TARGET_VERSION% 中的公共文件之间没有区别。迁移已经完成。"
NO_FILES_SELECTED = "您没有指定任何要迁移的文件。"
OVERWRITE_READONLY_SP1_FILES = "您要覆盖 TestStand %TARGET_VERSION% 公共文件夹中的只读文件吗？单击是继续并覆盖以下 {0} 个文件：\n\n"
MORE_READONLY_FILES = "<更多文件未列出>"
DEFAULT_REPORT_OPTIONS_CONFIGURATION_NAME = "报告（已迁移）"
DEFAULT_DATABASE_OPTIONS_CONFIGURATION_NAME = "数据库（已迁移）"
LEGACY_TO_NEW_MODEL_OPTIONS_MIGRATION_LOG = "{0} 迁移到配置'{1}:{2}'"
CONFLICTS_COLUMN_HEADER = "冲突"
CONFLICTS_COLUMN_TOOLTIP = "指示文件或文件夹是否有冲突。"
CONFLICTS_COLUMN_TEXT = "{0} 冲突..."
CONFLICTS_COLUMN_TEXT_FOR_FOLDER = "冲突..."
GENERIC_FOLDER_CONFLICT = "文件夹包含有冲突的项目。"
FILES = "文件"
CONFLICTS_EXPLANATION_TEXT Line0001 = "National Instruments 已对您在迁移过程中修改或将覆盖的文件进行了以下更改。\n\n"
CONFLICTS_EXPLANATION_TEXT Line0002 = "注意：因为迁移这些文件会覆盖 National Instruments 所做的更改，"
CONFLICTS_EXPLANATION_TEXT Line0003 = "National Instruments 建议您将您的更改与 National Instruments 的更改合并，而不是迁移这些文件。"
NO_CONFLICTS = "没有冲突。"
CFG_DIR_LOCATION_WARNING_HEADER = "TestStand %SOURCE_VERSION% 的配置目录已使用站点选项配置到自定义位置：\n {0}"
CFG_DIR_LOCATION_WARNING_RELOC Line0001 = "要让迁移实用程序检查和迁移配置目录的内容，您必须配置它"
CFG_DIR_LOCATION_WARNING_RELOC Line0002 = "使用默认位置或使用以下目录之一的子目录：\n"
CFG_DIR_LOCATION_WARNING_RELOC Line0003 = "{0}\n"
CFG_DIR_LOCATION_WARNING_RELOC Line0004 = "否则，您必须手动迁移配置目录的内容。"
CFG_DIR_LOCATION_WARNING_FOOTER Line0001 = "要让 TestStand %TARGET_VERSION% 使用迁移的配置文件，您必须使用 Station Options 来设置配置目录 "
CFG_DIR_LOCATION_WARNING_FOOTER Line0002 = "到迁移文件的新位置。"
CONTINUE_PROMPT = "你想继续迁移吗？"
FILES = "&帮助"
WARNING = "警告"
ERROR_PARSING_PROPERTY_OBJECT_FILE Line0001 = "{0} 似乎是属性对象文件，但无法解析。这可能表明文件已损坏。\n\n"
ERROR_PARSING_PROPERTY_OBJECT_FILE Line0002 = "错误：{1}\n\n"
ERROR_PARSING_PROPERTY_OBJECT_FILE Line0003 = "作为普通文件处理。"

;;错误和警告
ERR_NO_SOURCE_VERSIONS = "必须安装等于或高于 {0} 且早于 %TARGET_VERSION% 的 TestStand 版本才能使用 %TARGET_VERSION% 迁移实用程序。"
ERR_SEQEDIT_RUNNING = "您必须在迁移文件之前关闭 TestStand 序列编辑器。"
ERR_TESTEXEC_RUNNING = "在迁移文件之前，您必须关闭所有 TestStand 用户界面。"
ERR_BACKUP_EXISTS = "无法备份文件，因为备份文件夹已经存在。您可以删除现有的备份文件夹，选择不同的备份文件夹，或者等到自动附加的日期/时间发生变化。当前指定的备份文件夹是：\n{0 }"
ERR_NO_REG_VALUE = "注册表中不存在值 %1。"
ERR_BACKUP_FOLDER_NOT_VALID = "您没有指定有效的备份位置文件夹。"
ERR_NO_CHECKSUM_FILE = "无法确定自安装后是否创建或修改了文件，因为该文件不存在：\n{0}"
ERR_COPY_FILE = "尝试复制文件时发生错误：\n{0}\nTo:\n{1}\n\n{2}"
ERR_CREATE_DIR = "尝试创建文件夹时发生错误：\n{0}\n\n{1}"
ERR_NEW_OPTIONS_MIGRATION_FAILED = "无法将配置文件 {0} 迁移到配置 \"{1}:{2}\"。错误消息：{3}"
ERR_CURRENT_VERSION_NOT_ACTIVE = "TestStand %TARGET_VERSION% 必须是TestStand 的活动版本才能使用迁移实用程序。"
WARN_NAME_PROCESS_MODEL Line0001 = "您已选择迁移以下与 TestStand 默认过程模型同名的文件：\n"
WARN_NAME_PROCESS_MODEL Line0002 = "{0}\n\n"
WARN_NAME_PROCESS_MODEL Line0003 = "根据搜索目录的顺序，可能会使用这些文件代替默认的进程模型文件。\n\n"
WARN_NAME_PROCESS_MODEL Line0004 = "参考 NI 网站 ni.com/info 并输入信息代码 'extuuk' 以访问 National Instruments 知识库 "
WARN_NAME_PROCESS_MODEL Line0005 = "文章'如何在 TestStand 2012 中使用 TestStand 2010 或更早版本的自定义流程模型？'有关此问题的更多信息。"

;;报告
RT_MIGRATION_SUCCESS = "从 TestStand %SOURCE_VERSION% 到 TestStand %TARGET_VERSION% 的文件迁移成功完成。"
RT_MIGRATION_COMPLETE_BUT_ERRORS = "文件从 TestStand %SOURCE_VERSION% 迁移到 TestStand %TARGET_VERSION% 已完成，但出现一个或多个错误。"
RT_VIEW_REPORT_PROMPT = "你想查看迁移报告吗？"
RT_ERROR = "尝试迁移文件时发生以下错误：\r\n{0}\r\n\r\n"
RT_MIGRATION_TIME = "迁移日期/时间："
RT_BACKUP_LOCATION = "备份位置："
RT_REDIRECT_PATHS = "重定向 TestStand %SOURCE_VERSION% 路径选项："
RT_ENABLED = "启用"
RT_DISABLED = "禁用"
RT_RESTORE_INSTRUCTIONS_HEADER = "要将 TestStand %TARGET_VERSION% 恢复到迁移前的状态，请关闭迁移实用程序、TestStand 序列编辑器和任何正在运行的 TestStand 用户界面。然后运行"{0}"或完成以下步骤：\r\n "
RT_RESTORE_INSTRUCTIONS_DELETE = "{0}。删除此文件夹的内容：\r\n {1}\r\n"
RT_RESTORE_INSTRUCTIONS_COPY = "{0}。复制此文件夹的内容：\r\n {1}\r\n 至：\r\n {2}\r\n"
RT_MIGRATED_FILES = "该工具将以下文件和文件夹迁移到 TestStand %TARGET_VERSION%："
RT_MIGRATED_CONFIGURATIONS = "该工具将以下结果处理选项文件和文件夹迁移到 TestStand %TARGET_VERSION% 中的新配置："
RT_MIGRATED_CONFIGURATIONS_HELP = "迁移的配置已自动激活。您可以在结果处理对话框中更改活动配置。"
RT_NO_MIGRATED_FILES = "该工具没有将任何文件或文件夹迁移到 TestStand %TARGET_VERSION%。"
RT_ERROR_MIGRATING_FILES = "尝试将以下文件复制到 TestStand %TARGET_VERSION% 文件夹时发生错误："
RT_UPDATED_FILES = "该工具将 TestStand %SOURCE_VERSION% 路径重定向到以下文件中的 TestStand %TARGET_VERSION% 路径："
RT_ERROR_UPDATING_FILES = "无法将 TestStand %SOURCE_VERSION% 路径重定向到以下文件中的 TestStand %TARGET_VERSION% 路径，因为加载文件时发生错误："
RT_OVERWRITTEN_READ_ONLY_FILES = "该工具覆盖了 TestStand %TARGET_VERSION% 文件夹中的以下只读文件："
