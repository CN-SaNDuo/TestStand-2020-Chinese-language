;; EngineStrings.ini - TestStand 引擎字符串
;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"


[ENGINE]
FILE_FORMAT_INI_LBL = "INI（自 TestStand 2019 起已弃用）"
FILE_FORMAT_XML_LBL = "XML（最易读，最大）"
FILE_FORMAT_BINARY_LBL = "二进制（最快和最小）"
ERROR_INI_CANNOT_BE_DEFAULT = "INI 格式自 TestStand 2019 起已弃用，不能作为新序列文件的默认格式。"
ERROR_UNKNOWN_FILE_WRITING_FORMAT_1 = "未知的文件写入格式：%1"

TEST_STAND = "测试台"
CANT_START_ENGINE = "无法初始化 TestStand 引擎。"
INVALID_ENGINE_POINTER = "无效的 TestStand 引擎指针"
INVALID_UNIQUE_ID_STRING = "无效的唯一 ID：%1"

VIEW_FILE_IN_NOTEPAD_PROMPT = "你没有指定一个应用程序来处理这种类型的文件。\n你想启动记事本来查看这个文件吗？"

UNABLE_TO_DELETE_SETUP_FILE = "无法删除设置目录中的配置文件：'%1'。"

ERROR_LOADING_ICONS = "无法加载以下图标文件：\n%1"

REMOTE_MSGBOX_MESSAGE = "注意：以下消息来自远程主机 '%1'：\n\n%2"
ENGINE_ERROR_DLG_TITLE = "错误："
ENGINE_WARNING_DLG_TITLE = "警告："
ENGINE_YES_NO_DLG_TITLE = "提示："
ENGINE_INFORMATION_DLG_TITLE = "请注意："
ENGINE_GENERIC_TITLE = "测试台"
ERROR_CODE = "错误代码：%1"
SOURCE = "来源：'%1'"
READONLY_CONFIG_FILE_MSG Line0001 = "TestStand 将不会再次显示这条信息"
READONLY_CONFIG_FILE_MSG Line0002 = "在此会话期间保存此文件时出错。"
COULD_NOT_WRITE_CONFIG = "无法保存对 TestStand 配置的更改。"
COULD_NOT_WRITE_GLOBALS = "空间站全局未保存。"
COULD_NOT_WRITE_TEMPLATES = "模板未保存。"
COULD_NOT_WRITE_TOOLMENU = "无法保存对工具菜单的更改。"
COULD_NOT_WRITE_USERLIST = "无法保存对用户管理器的更改。"
COULD_NOT_WRITE_TYPES = "无法将更改保存到类型面板。"
COULD_NOT_WRITE_TYPES_BACKUP = "将类型选项板文件 %1 备份到 %2 时发生错误"
COULD_NOT_LOAD_ADAPTER = "无法加载测试环境适配器 '%1'。"
COULD_NOT_LOAD_CONVERTER = "无法加载序列文件转换器 '%1'。\n运行安装程序以重新安装或删除此转换器。"
PROMPT_TO_SAVE_TYPES = "保存对类型面板所做的更改？"
STRINGS_FILE_NOT_FOUND = "未找到所选语言 (%1) 的字符串文件。"
SET_LANGUAGE_MSG = "您的新语言设置只有在您重新启动 TestStand 后才会生效。"
USER_LIST_FILE_NOT_FOUND = "未找到用户管理器文件 '%1'。\n将使用默认文件 '%2'。"
DEFAULT_USER_NAME = "管理员"
DEFAULT_ENTRY_POINT_NAME = "\"未命名入口点\""
USER_NAME_EMPTY = "用户名或组名是空的。"
USER_NAME_RESERVED = "名称 '%1' 已保留，不是有效的用户名。"
USER_NAME_CONTAIN_SPECIAL_CHAR = "用户名 '%1' 包含一个或多个无效字符。用户名不能包含控制字符"
USER_NAME_EXISTS = "名称为 '%1' 的用户已经存在。"
USER_TEMPLATE_NAME_EMPTY = "未指定用户组名称。"
USER_TEMPLATE_NAME_RESERVED = "名称 '%1' 已保留，不是有效的用户组名称。"
USER_TEMPLATE_NAME_CONTAIN_SPECIAL_CHAR = "用户组名称不能包含控制字符。"
USER_TEMPLATE_NAME_EXISTS = "名称为 '%1' 的用户组已经存在。"
UNRELEASED_SEQUENCE_FILES_EXIST = "一些序列文件在上次 TestStand 引擎被销毁时没有发布。"
UNRELEASED_EXECUTIONS_EXIST = "一些执行在上次 TestStand 引擎被销毁时没有被释放。"
PRE_RELEASE_VERSION_EXPIRED = "此预发布版本 '%1' 已过期 %2。"
ERR_RESTARRTING_ENGINE_EXECUTIONS_STILL_RUNNING = "执行仍在运行时无法重新启动 TestStand 引擎。\n\n如果您正在泄漏执行，您可能需要退出并重新启动应用程序。"
ERR_RESTARRTING_ENGINE_UNRELEASED_EXECUTIONS_EXIST = "存在未发布的执行时无法重新启动 TestStand 引擎。\n\n如果您正在泄漏执行，您可能需要退出并重新启动应用程序。"
ERR_RESTARRTING_ENGINE_UNRELEASED_SEQUENCE_FILES_EXIST = "当序列文件仍在加载时无法重启 TestStand 引擎。\n\n如果您正在泄漏序列文件，您可能需要退出并重启应用程序。"
ERR_RESTARRTING_ENGINE_WORKSPACE_IS_OPEN = "工作区打开时无法重启 TestStand 引擎。"
ERR_ENVIRONMENTS_FEATURE_DISABLED = "此系统禁用了 TestStand 环境。"
ERR_ENVIRONMENT_PRIVILEGE = "改变环境需要 ConfigEngine 权限。"
ERR_ENGINE_INITIALIZER_ENGINE_ALREADY_CREATED = "在创建引擎后无法设置引擎启动设置（例如引擎环境）。"
ERR_RESTARTING_ENGINE_FATAL_TITLE = "致命错误"
ERR_RESTARTING_ENGINE_FATAL Line0001 = "重新启动 TestStand 引擎时发生错误。原因：\n\n%1\n\n"
ERR_RESTARTING_ENGINE_FATAL Line0002 = "引擎现在处于无法恢复的未知状态。请尝试保存您的工作并退出应用程序。"
ERR_RESTARTING_ENGINE_FATAL_UNKNOWN Line0001 = "重新启动 TestStand 引擎时发生错误。\n\n"
ERR_RESTARTING_ENGINE_FATAL_UNKNOWN Line0002 = "引擎现在处于无法恢复的未知状态。请尝试保存您的工作并退出应用程序。"
ERR_SETTING_MULTIBYTE_NOT_SUPPORTED Line0001 = "TestStand 不再支持手动启用/禁用多字节编码。"
ERR_SETTING_MULTIBYTE_NOT_SUPPORTED Line0002 = "\nTestStand 引擎在启动时根据当前系统代码页选择适当的设置。"

OPERATOR_TEMPLATE_NAME = "操作员"
TECHNICIAN_TEMPLATE_NAME = "技术人员"
DEVELOPER_TEMPLATE_NAME = "开发者"
ADMINISTRATOR_TEMPLATE_NAME = "管理员"

GLOBALS_FILE_DISPLAY_NAME = "站点全局"
GLOBALS_FILE_TYPE_DESC = "站全局文件"
TEMPLATES_FILE_TYPE_DESC = "模板文件"
TYPES_FILE_DISPLAY_NAME = "类型面板 - %1"
TYPES_FILE_TYPE_DESC = "类型文件"
INSTALLED_TYPES_FILE_DISPLAY_NAME = "新安装的类型"
USERS_FILE_DISPLAY_NAME = "用户管理器"
USERS_FILE_TYPE_DESC = "用户管理器文件"
CONFIG_FILE_DISPLAY_NAME = "引擎设置"
TESTSTAND_CONFIG_FILE_DISPLAY_NAME = "通用引擎设置"
SEARCH_DIRECTORIES_CONFIG_FILE_DISPLAY_NAME = "搜索目录"
ADAPTERCFG_CONFIG_FILE_DISPLAY_NAME = "适配器设置"
TYPE_PALETTES_CONFIG_FILE_DISPLAY_NAME = "类型面板设置"
CUSTOM_CONFIG_FILE_DISPLAY_NAME = "自定义设置"
CONFIG_FILE_TYPE_DESC = "配置文件"
TESTSTAND_CONFIG_FILE_TYPE_DESC = "通用引擎配置文件"
SEARCH_DIRECTORIES_CONFIG_FILE_TYPE_DESC = "搜索目录配置文件"
ADAPTERCFG_CONFIG_FILE_TYPE_DESC = "适配器配置文件"
TYPE_PALETTES_CONFIG_FILE_TYPE_DESC = "类型调色板配置文件"
CUSTOM_CONFIG_FILE_TYPE_DESC = "自定义配置文件"
WORKSPACE_FILE_TYPE_DESC = "工作区文件"
WORKSPACE_OPTIONS_FILE_TYPE_DESC = "工作区选项文件"
WORSPACE_PERSISTENCE_FILE_TYPE_DESC = "工作区持久性文件"
PROJECT_FILE_TYPE_DESC = "项目文件"
PROPOBJ_FILE_TYPE_DESC = "属性对象文件"
TSR_FILE_TYPE_DESC = "TestStand 结果文件"
TSR_INFO_FILE_TYPE_DESC = "TestStand 结果信息文件"

PERSISTED_OBJECTS_LOST_MSG = "之前保留的断点和监视表达式将不可用。"
NEWER_FILE_WARNING Line0001 = "警告，%1 '%2' 已被 TestStand %3 保存。"
NEWER_FILE_WARNING Line0002 = "该文件可能包含比当前加载到 TestStand 中的类型更新的版本。"
NEWER_FILE_WARNING Line0003 = "如果文件中的新类型没有启用'设置可以使用该类型的最早的 TestStand 版本'设置，新类型将替换当前加载的类型，更新类型调色板文件，并更新您使用的序列文件随后开放。"
NEWER_FILE_WARNING Line0004 = "\n\n你想加载更新的文件吗？"
TYPE_CONFLICT_WARNING = "警告，%2 (%3) 中的类型 '%1' 与先前在 %5 中加载的类型 '%4' 不同。"
TYPE_CONFLICT_WARNING_NO_FILE = "警告，正在读取的类型 '%1' 与先前在 %5 中加载的类型 '%4' 不同。"
RECONCILE_INCOMPATIBLE_TYPES_MSG = "警告：%3 (%4) 中的类型 '%1' 与当前加载的类型 '%2' 不兼容。你必须重命名这两种类型中的一种。\n"
RECONCILE_INCOMPATIBLE_TYPES_IN_UNKNOWN_FILE_MSG = "警告：正在读取的类型 '%1' 与当前加载的类型 '%2' 不兼容。你必须重命名这两种类型之一。\n"
INCOMPATIBLE_TYPES_MSG = "警告：%3 (%4) 中的类型 '%1' 与当前加载的类型 '%2' 不兼容。TestStand 无法继续此读取操作。\n"
INCOMPATIBLE_TYPES_IN_UNKNOWN_FILE_MSG = "警告：正在读取的类型 '%1' 与当前加载的类型 '%2' 不兼容。TestStand 无法继续此读取操作。\n"

NO_MODEL_DESCRIPTION = "无"
NO_MODEL_TESTSTAND_DISABLED = "无（禁用站模型）"
NO_MODEL_FILE_NOT_FOUND = "无（未找到文件）"
NO_MODEL_NOT_TESTSTAND_MODEL = "无（模型不是站模型）"
NO_MODEL_ERROR_LOADING_FILE = "无（加载文件错误）"

PROMPT_TO_SAVE_FILE_TITLE = "文件已修改"
PROMPT_TO_SAVE_FILE_MSG = "将更改保存到 %1？"
PROMPT_TO_SAVE_AUTO_CONVERTED_FILE_MSG = "由于 TestStand 在加载文件时执行的自动转换，文件 %1 被修改。保存更改？"
PROMPT_TO_SAVE_EXTERNALY_AUTO_CONVERTED_FILE_MSG = "由于 TestStand 在加载另一个文件时执行的自动转换，文件 %1 被修改。保存更改？"
PROMT_TO_SAVE_FILES_MSG = "下面的文件已经修改。保存修改？"


CODE_TMPLT_DESC_NOT_FOUND_MSG = "读取文件 '%1' 时出错。"
CODE_TMPLT_INI_FILE_NOT_FOUND_MSG = "找不到文件 '%1'。"

ERROR_EVAL_STOP_ON_EXPR = "评估 Stop 表达式时出错：\n\n%1\n\n你想继续吗？"
ERROR_EVAL_STOP_ON_EXPR_TITLE = "评估停止表达式时出错"

ERROR_IN_EXPR_TITLE = "表达错误"
EMPTY_EXPR_ERROR = "%1 不能为空。\n\n该值将导致运行时错误。"
SYNTAX_ERROR_IN_EXPR_TEXT = "%1 中的语法错误：\n\n%2\n\n该值将导致运行时错误。"
EVAL_ERROR_IN_EXPR_TEXT = "%1 中的计算错误：\n\n%2\n\n该值将导致运行时错误。"
EVAL_WARNING_IN_EXPR_TEXT = "%1 中的计算警告：\n\n%2\n\n如果您确定表达式将在运行时正确计算，您可以忽略错误或使用 #NoValidation 指令来抑制错误。"

UNIQUE_ID_COMMENT = "的唯一 ID"
CONVERT_STEP_NAMES_TO_UNIQUE_IDS_TITLE = "使用唯一的步骤 ID？"
CONVERT_STEP_NAMES_TO_UNIQUE_IDS_MSG Line0001 = "您选择的表达式按名称引用了一个或多个步骤。将新步骤添加到具有相同名称的序列中，或更改步骤名称可能会使该表达式无效。"
CONVERT_STEP_NAMES_TO_UNIQUE_IDS_MSG Line0002 = "通过其唯一 ID 而不是其名称来指定步骤可以防止这些问题。\n\n你想通过其唯一 ID 而不是步骤名称来指定此表达式中的步骤吗？"
CONVERT_STEP_NAMES_TO_UNIQUE_IDS_NOTE = "注意：此选项仅影响表达式浏览器创建的表达式。\n后操作目标、转到步骤目标、等待步骤目标和前提条件表达式始终由唯一 ID 指定。"
MSG_BACKED_UP_OLD_TYPE_PALLETE = "您以前的类型选项板文件的副本已保存到 %1"

EVAL_VERSION_EXPIRED_MSG = "您的 TestStand 评估会话已过期。"
EXPIRATION_DATE = "（过期 %1）"

USER_NO_LONGER_EXISTS = "重新加载用户文件后，用户 '%1' 不再存在。\n请使用不同的用户名登录。\n"
FILE_CONTAINS_VERSION_1_DB_BETA Line0001 = "文件 \"%1\" 包含 TestStand 1.0 数据库 Beta 组件。这些组件与 TestStand 2.0.1 不兼容。"
FILE_CONTAINS_VERSION_1_DB_BETA Line0002 = "你应该用 TestStand 1.0.1、1.0.2 或 1.0.3 打开这个文件，将它们转换成与 TestStand 2.0.1 兼容的格式。你还想打开它吗？"

CONVERTING_OLD_TYPE_PALETTE Line0001 = "您的旧类型调色板文件 '%1' 即将被删除。您将在新文件 '%2' 中找到所有自定义类型。' "
CONVERTING_OLD_TYPE_PALETTE Line0002 = "建议您将来使用此文件保存所有自定义类型。National Instruments 类型现在可以在单独的文件 '%3' 中找到。您的旧类型调色板文件将另存为 ' %4'。"

DCOM_ENABLE_REMOTE_CONNECT_ERROR = "EnableRemoteConnect 在注册表中设置为 '%1'。正确的值为 'Y' 以启用远程连接。"
DCOM_ENABLE_DCOM_ERROR = "EnableDCOM 在注册表中设置为 '%1'。正确的值为 'Y' 以启用 DCOM。"
DCOM_RUNAS_ERROR = "REngine RunAs 在注册表中设置为 '%1'。正确的值是 'Interactive User'。"
DCOM_RUNAS_EMPTY_ERROR = "在注册表中找不到 REngine RunAs。正确的值是'Interactive User'。"
DCOM_LAUNCH_PERM_ERROR = "REngine 启动权限不正确。如果您选择"允许所有用户从远程计算机访问"选项，则 REngine 必须根据操作系统向"所有人"或"匿名登录"授予启动权限。有关详细信息，请参阅到联机帮助。"
DCOM_FIX_FAILED = "无法修复一个或多个 REngine 设置：%1\n\n注意：您需要管理员权限才能更改这些设置。"

UNNAMED_PROPOBJ_FILE = "<无路径>"

NI_TYPE_VERSIONS_AUTO_ADJUSTED = "致开发人员的消息：以下类型被标记为 NI 类型，因此它们的版本自动提高到 %1（最低 TestStand 版本也提高到 %2）。\r\n\r\n% 3"

DEBUG_WARNING_TITLE = "TestStand 调试选项警告"
DEBUG_WARNING_HEADER = "站点选项，报告对象泄漏和报告的已知操作系统和组件问题，\n在关闭时报告了以下警告："
DEBUG_WARNING_UNRELEASED_FILES2 = "以下序列文件未正确释放。您必须在释放对文件的最后一个对象引用之前调用\nEngine.ReleaseSequenceFile(Ex) 方法：\n"
DEBUG_WARNING_UNRELEASED_FILES = "未为以下文件调用 Engine.ReleaseSequenceFile(Ex) 方法：\n"
DEBUG_WARNING_REFERENCES Line0001 = "对 PropertyObjects 的引用未正确释放。\n"
DEBUG_WARNING_REFERENCES Line0002 = "对象总数：%2\n"
DEBUG_WARNING_REFERENCES Line0003 = "顶级对象的数量：%1\n\n"
DEBUG_WARNING_REFERENCES Line0004 = " 注意：如果某些顶级对象被引用\n"
DEBUG_WARNING_REFERENCES Line0005 = "一个错误释放的顶级对象。例如，一个未释放的\n"
DEBUG_WARNING_REFERENCES Line0006 = "SequenceContext 对象引用了一个 SequenceFile 对象。\n\n"
DEBUG_WARNING_REFERENCES Line0007 = "以下顶级对象未被释放：\n\n"
DEBUG_WARNING_MAX_REACHED = "注意：更多对象未被释放，但未列出。\n"
DEBUG_WARNING_EXCEPTION = "警告：对 PropertyObjects 的引用未正确发布，但列表不可用。"
DEBUG_WARNING_NONE = "所有对 PropertyObjects 的引用都已正确释放。"
DEBUG_WARNING_LINE = "************************************************ **********"

ORPHAN_OBJS_LIST_GROUP = "%1s [%2 个对象未释放]\n"
ORPHAN_OBJS_LIST_UNKNOWN = "<未知类型> [%1 个对象未被释放]\n\n"
ORPHAN_OBJS_DETAIL_CONTEXT = "上下文上次执行文件 '%2' 中的序列 '%1'。"
ORPHAN_OBJS_LIST_OTHER = "以及以下未分类的对象：\n"
ORPHAN_OBJS_DETAIL_NAME 	= "姓名："
ORPHAN_OBJS_DETAIL_PATH = "路径："
ORPHAN_OBJS_DETAIL_VALUE = "价值："
ORPHAN_OBJS_DETAIL_TYPE = "类型："
ORPHAN_OBJS_VALUE_ERROR = "<访问值时发生错误>"

DEBUG_WARNING_SKCHUIDLL Line0001 = "警告：\n"
DEBUG_WARNING_SKCHUIDLL Line0002 = "您的系统包含 Microsoft Tablet PC 平台组件，skchui.dll\n"
DEBUG_WARNING_SKCHUIDLL Line0003 = "（版本 1.0.1038）。Microsoft 已报告此版本的手写\n"
DEBUG_WARNING_SKCHUIDLL Line0004 = "已知 Microsoft Office 产品的功能会导致 GDI 内存泄漏\n"
DEBUG_WARNING_SKCHUIDLL Line0005 = "托管 Microsoft Internet Explorer 控件的应用程序，例如\n"
DEBUG_WARNING_SKCHUIDLL Line0006 = " TestStand。请参阅 Microsoft 知识库文章 896429，位于\n"
DEBUG_WARNING_SKCHUIDLL Line0007 = " http://support.microsoft.com/default.aspx?scid=kb;en-us;896429，了解更多\n"
DEBUG_WARNING_SKCHUIDLL Line0008 = "有关此问题的信息以及如何卸载该功能。\n\n"

DEBUG_WARNING_LFH Line0001 = "警告：\n"
DEBUG_WARNING_LFH Line0002 = "启用 Windows 低碎片堆在启动时失败。性能可能是\n"
DEBUG_WARNING_LFH Line0003 = "加载序列文件和生成等事情显着减少\n"
DEBUG_WARNING_LFH Line0004 = "很多结果在不使用低碎片堆时。参考国家\n"
DEBUG_WARNING_LFH Line0005 = "仪器网站 ni.com/info 并输入信息代码 tslfheap 以访问\n"
DEBUG_WARNING_LFH Line0006 = "National Instruments 知识库文章，启用 Windows 低碎片化\n"
DEBUG_WARNING_LFH Line0007 = "启动 TestStand 时堆失败，有关此问题的更多信息。\n\n"

DEBUG_WARNING_OSCOMPONENTS_GENERAL Line0001 = "您可以通过禁用\n"来禁用上述操作系统和组件警告
DEBUG_WARNING_OSCOMPONENTS_GENERAL Line0002 = "调试选项对话框中的'报告已知操作系统和组件问题'复选框"

INVALID_USE_OF_PROP_VAL_TYPE_ARRAY = "你不能通过此方法使用 PropValType_Array。"
ENUM_ARRAY_TYPE_NOT_VALID = "PropValType_Enum 对数组无效。要创建枚举对象数组，请使用 PropValType_NamedType 并指定枚举类型。"

CONTACT_SUPPORT = "如果问题仍然存在，请联系 National Instruments 寻求支持。"

CYCLE_DETECTED = "\"<检测到循环>\""
JSON_TRUNCATION_MESSAGE = " ... <由于长度原因被截断>"

PYTHON_ADAPTER_EXTENDED_DATA_REMOVED = "'%2' 下 '%1' 的 Python 参数传递设置已被删除。将类型的实例作为 python 模块的参数传递时应用默认设置。"


[ENGINE_MENUS]
EXP_VAR_CHANGE_REPRESENTATION = "&Representation"
EXP_VAR_REPRESENTATION_FLOAT64 = "&双精度 64 位浮点数（默认）"
EXP_VAR_REPRESENTATION_INT64 = "带符号的 64 位整数&"
EXP_VAR_REPRESENTATION_UINT64 = "&64 位无符号整数"
INSERT_NUMBER = "插入 &Number"
INSERT_REFERENCE = "插入对象引用(&F)"
INSERT_STRING = "插入&字符串"
INSERT_BOOLEAN = "插入布尔值(&B)"
INSERT_CONTAINER = "插入容器(&C)"
INSERT_TYPES = "插入&类型"
INSERT_ARRAY_OF = "插入数组(&R)"
NUMBER = "&数字"
NUMBERS = "&数字"
REFERENCE = "对象引用(&F)"
REFERENCES = "对象引用&references"
STRING = "&字符串"
STRINGS = "&字符串"
BOOLEAN = "&布尔值"
BOOLEANS = "&布尔值"
CONTAINER = "&容器"
CONTAINERS = "&容器"
TYPES = "&类型"
ARRAY_TYPES = "&类型"
ARRAY_OF = "数组&r"
PROPERTIES = "属性&属性..."
EXP_VAR_INSERT = "&插入"
EXP_VAR_REPLACE = "替换&E"
EXP_VAR_RENAME = "&重命名\t[F2]"
EXP_VAR_DELETE = "&删除\tDel"

TOOLS = "&工具"
INSERT_STEP = "&插入步骤"
INSERT_VARIABLE = "&插入变量"

[ENGINE_PROMPTS]

[ENGINE_TOOLTIPS]
RIGHT_CLICK_TO_INSERT = "右击插入新变量"
RIGHT_CLICK_TO_EDIT = "右击编辑项目"


[EXECUTION PHASE]
MainSteps = "主要"
Main="主要"
Setup="设置"
Cleanup="清理"
0 = "设置"
1 ="主要"
2 ="清理"

[GOTO TARGETS]
CLEANUP_STEP_NAME = "<清理>"
END_STEP_NAME = "<结束组>"
SPECIFY_GOTO_BY_EXPRESSION = "<通过表达式指定>"
INVALID_TARGET = "<无效目标>"

[STEP RUN MODE]
Normal=""
Skip = "跳过"
Pass="强制通过"
Fail="强制失败"

[步骤流程]
PRE = "先决条件"
POST = "发布操作"
LOOP = "循环"
INDEX = "索引："
INTERACTIVE="互动"
MUTEX = "锁定"
BATCH = "批量"
NEW_THREAD = "新话题"
NEW_EXECUTION = "新执行"
STA = "[STA]"
CPU_AFFINITY = "[CPU 亲和性]"
PRE_EXPR = "前表达式"
POST_EXPR = "后表达式"
STATUS_EXPR = "状态表达式"
SWITCH = "开关"
BREAKPOINT = "断点"
BREAK_DISABLED = "禁用"
BREAK_CONDITIONAL = "中断条件"
ACTIVATE_WINDOW = "激活窗口"
RESULT_RECORDING_OPTION_DISABLED = "结果记录：禁用"
RESULT_RECORDING_OPTION_ENABLED = "结果记录：启用"
RESULT_RECORDING_OPTION_ENABLED_OVERRIDE_SEQUENCE_SETTING = "结果记录：启用 - 覆盖序列设置"
STEP_FAILURE_OPTION = "步骤失败选项"
LOAD_OPTION = "加载选项"
UNLOAD_OPTION = "卸载选项"
IGNORE_RTE = "忽略错误"
IGNORE_TERMINATION = "忽略终止"
SEQUENCE_CALL_TRACING_ENABLE = "启用跟踪"
SEQUENCE_CALL_TRACING_DISABLE = "禁用跟踪"
SEQUENCE_CALL_TRACING_USE_INITIAL = "使用初始跟踪设置"
ADDITIONAL_RESULTS = "额外结果"
ATTRIBUTES = "属性"

[FLOW_DETAILS]
ACTION_GOTO = "转到 %1"
ACTION_CALLBACK = "呼叫 %1"
ACTION_TERMINATE = "终止"
ACTION_BREAKPOINT = "断点"
ACTION_NEXT = "转到下一步"
RUN_MODE = "运行模式：%1\n"
PRECONDITIONs = "先决条件：\n"
CUSTOM_ACTION = "发布操作：\n"
CUST_TRIVIALLY_TRUE = " %1\n"
CUST_TRUE = " 如果 (%1)\n %2\n"
CUST_ELSE_FALSE = "否则\n %1\n"
CUST_FALSE = " 如果 ((%1) == False)\n %2\n"
POST_ACTION = "后操作：\n"
ON_PASS = " 通过 %1\n"
ON_FAIL = " 失败 %1\n"
LOOP = "循环："
CUSTOM_LOOP = "自定义循环："
LOOP_FIXED = " 循环次数：%1\n 如果 %2 %3% 的迭代通过，则循环结果失败。\n"
LOOP_PASSFAIL_COUNT = " 在 %1 次迭代 %2 或最多 %3 次迭代后停止。\n 如果 %5 %6 在 %7 次迭代中，循环结果为 %4。\n"
PASS = "通过"
FAIL = "失败"
LOOP_INIT = " %1; // 循环初始化\n"
LOOP_WHILE_INCR_STATUS = " while (%1)\n {\n ExecuteStep();\n %2; // 循环增量\n }\n Step.Status = %3; // 循环状态\n"
INTERACTIVE = "交互式执行"
INDEX = " (%1)"
MUTEX = "锁定: %1\n"
UNNAMED_MUTEX = "<未命名锁。该锁对于该步骤的实例是唯一的>"
SERIAL_BATCH = "批量同步：串行\n"
PARALLEL_BATCH = "批量同步：并行\n"
ONE_THREAD_ONLY_BATCH = "批量同步：只有一个线程\n"
EXPRESSION_INDENT = " "
PRE_EXPRESSION = "前表达式：\n"
POST_EXPRESSION = "发表表达：\n"
STATUS_EXPRESSION = "状态表达式：\n"
SWITCH_DEVICE_OPERATION = " 虚拟设备：%1\n 操作：%2\n"
SWITCH_CONNECT_ROUTES = "要连接的路线：%1\n"
SWITCH_DISCONNECT_ROUTES = "要断开的路由：%1\n"
SWITCH_LIFETIME = "生命周期：%1\n"
SWITCHING = "正在切换：\n"
BREAKPOINT = "条件断点："
BREAK_ENABLED = "已启用\n"
BREAK_DISABLED = "已禁用\n"
BREAK_CONDITION = "条件：%1\n"
BREAK_PASSCOUNT = "通过次数：%2"
WINDOW_ACTIVATE_ON_COMPLETE = "窗口激活：激活\n"
WINDOW_REACTIVATE_IF_ACTIVE = "WindowActivation：重新激活\n"
RESULT_RECORDING_OPTION_DISABLED = "结果记录：禁用"
RESULT_RECORDING_OPTION_ENABLED = "结果记录：启用"
RESULT_RECORDING_OPTION_ENABLED_OVERRIDE_SEQUENCE_SETTING = "结果记录：启用 - 覆盖序列设置"
FAIL_ON_STEP_FAIL = "步骤失败：序列失败\n"
DO_NOT_FAIL_ON_STEP_FAIL = "步骤失败：不要使序列失败\n"
PRELOAD_WHEN_OPENED = "加载选项：打开序列文件时预加载"
PRELOAD_WHEN_EXECUTED = "加载选项：执行开始时预加载"
DYNAMIC_LOAD = "加载选项：动态加载"
ON_PRECONDITION_FAILURE = "卸载选项：前提条件失败时卸载"
AFTER_STEP_EXECUTION = "卸载选项：步骤执行后卸载"
AFTER_SEQUENCE_EXECUTION = "卸载选项：序列执行后卸载"
WITH_SEQUENCE_FILE = "卸载选项：序列文件关闭时卸载"
IGNORE_RTE = "忽略运行时错误：真\n"
OPTION_OVERIDDEN_BY_FILE = "（由于覆盖序列文件设置而忽略的选项）\n"
IGNORE_TERMINATION = "忽略终止：真\n"
SEQUENCE_CALL_TRACING_ENABLE = "序列调用跟踪：启用\n"
SEQUENCE_CALL_TRACING_DISABLE = "序列调用跟踪：禁用\n"
SEQUENCE_CALL_TRACING_USE_INITIAL = "序列调用跟踪：使用初始设置\n"
ADDITIONAL_RESULTS = "记录了 %1 个附加结果\n"
ATTRIBUTES = "属性\n"

[STEP RESULT STATUS]
Done="完成"
Skipped="跳过"
Passed = "通过"
Failed="失败"
Error ="错误"
Running ="运行"
Looping = "循环"
Terminated ="终止"
Waiting ="等待"

[OBJECT TYPES]
ARRAY_ELEMENT_PROTOTYPE = "数组元素原型"
POINTER_TYPE_DESCRIPTION = "指针：%1"
POINTER_TYPE_DOTNET_UINTPTR_DESCRIPTION = "指针：%1 <UIntPtr>"
DESC_FOR_PROP_REPRESENTATION_FLOAT64 = "64 位浮点数"
DESC_FOR_PROP_REPRESENTATION_INT64 = "带符号的 64 位整数"
DESC_FOR_PROP_REPRESENTATION_UINT64 = "无符号 64 位整数"
RECURSION_DETECTED = "递归子属性"
UNKNOWN_TYPE = "未知类型"
ANY_TYPE = "任何类型"
NO_TYPE_SPECIFIED = "<未指定类型>"
NOTHING_CONSTANT = "无"
Step = "步骤"
Num = "数"
Enum = "枚举"
Ref = "对象引用"
str = "字符串"
PtrObj = "指针"
Bool = "布尔值"
Obj = "容器"
Object = "对象"
PlainRef = "普通对象引用"
PlainContainer = "普通容器"
Array = "数组"
ArrayObj = "数组"
ArrayOf = "数组"
ArrayOfX = "%1 的数组"
nums = "数字数组"
Enums = "枚举数组"
strs = "字符串数组"
Bools = "布尔数组"
Refs = "对象引用数组"
Nums 元素 = "数字"
字符串元素 = "字符串"
布尔元素 = "布尔值"
Refs Element = "对象引用"
Objs = "容器数组"
Types = "类型列表"
Type = "类型"
IVI = "IVI"
ATML = "ATML"
STD = "IEEE 1641"
LabVIEW = "LabVIEW"
StepType = "步骤类型"
StepTemplate = "步骤模板"
StepTemplates = "步骤模板列表"
PathValue = "路径值"
Sequence ="顺序"
Argument = "参数"
Arguments = "参数列表"
Parameter = "参数"
Parameters = "参数列表"
SequenceCall = "序列调用"
SequenceFile = "序列文件"
SequenceContext = "序列上下文"
SequenceFileData = "序列文件数据"
ExternalCall = "外部调用"
FCParameter = "函数参数"
FlexCStep = "弹性 C 步骤"
StdCStep = "标准 C 步骤"
GStep = "LabVIEW 步骤"
StdCVIStep = "标准 CVI 步骤"
HTBasicStep = "HTBasic 步骤"
AutomationCall = "自动化调用"
TERResult = "结果"
UserThread = "线程"
Execution="执行"
Report="报告"
EngineTestObjectWrapper = "引擎"
Module = "模块"
TYPE_DESCRIPTION = "%1，类型定义"
TYPE_INSTANCE_DESCRIPTION = "%2 (%1)"
ARRAY_DESCRIPTION = "%1%2"
BOUNDS_DESCRIPTION = "[%1]"
MULTI_DIMENSION_DESCRIPTION = "%2..%3][%1"
SINGLE_DIMENSION_DESCRIPTION = "%2..%3"
EMPTY_DIMENSION = ""
EMPTY_INDEX = "空"
UNKNOWN_INDEX = "N"
TESTOBJARRAYOBJ_TYPE_DESC_FORMAT = "数组 %1"
TESTOBJARRAYOBJ_OF_TYPE_INSTANCE_DESC_FORMAT = "%1 数组"
TWO_TYPES_COMBINED_WITH_OR = "%1 或 %2"
LIST_OF_THREE_OBJECT_TYPES = "%1、%2 或 %3"
Ref_POINTER = "持有指针的对象引用"
VICall = "ViCall"
Complex = "复数"
SemiconductorMODule = "半导体模块"

;;译者注意：像 AND、OR、NOT 这样的运算符和像 PropertyExists() 这样的表达式函数名称是编程结构，
;;不应该翻译。
;;例如：Numeric_SYM4 = "Random()"


[EXPRESSION_WIZARD]
CATEGORIES = "_Operators|Arithmetic|Assignment|Bitwise|Comparison|Logical|Other|_Constants|Colors|3Other|_Functions|Array|Numeric|Property|String|Time|Switching|2Other"
Arithmetic_SYM1 = "+"
Arithmetic_OP1 = "加"
Arithmetic_DESC1 Line0001 = "二进制加法和一元加法。如果一个操作数是字符串，另一个是数值，则运算符首先将字符串转换为数值。"
Arithmetic_DESC1 Line0002 = "如果两个参数都是字符串，运算符会创建一个新字符串，将两个字符串的内容连接起来。如果两个参数都是数组，"
Arithmetic_DESC1 Line0003 = "运算符创建了一个连接两个数组内容的新数组。"
Arithmetic_SYM2 = "-"
Arithmetic_OP2 = "减"
Arithmetic_DESC2 = "二进制减法和一元减法。仅适用于数值。"
Arithmetic_SYM3 = "*"
Arithmetic_OP3 = "乘法"
Arithmetic_DESC3 = "将两个操作数相乘。仅适用于数值。"
Arithmetic_SYM4 = "/"
Arithmetic_OP4 = "除法"
Arithmetic_DESC4 = "将第一个操作数除以第二个。仅适用于数值。"
Arithmetic_SYM5 = "MOD"
Arithmetic_OP5 = "模数（基本语法）"
Arithmetic_DESC5 = "计算第一个操作数除以第二个操作数的余数。适用于整数和实数值。"
Arithmetic_SYM6 = "%"
Arithmetic_OP6 = "模数（C/C++/C# 语法）"
Arithmetic_DESC6 = "计算第一个操作数除以第二个操作数的余数。适用于整数和实数值。"
Arithmetic_SYM7 = "++"
Arithmetic_OP7 = "增量"
Arithmetic_DESC7 Line0001 = "先递增或后递增。将操作数中的值增加 1.0。您可以将运算符放在操作数之前或之后。"
Arithmetic_DESC7 Line0002 = "如果将运算符放在操作数之前，表达式的值就是操作数的新值。"
Arithmetic_DESC7 Line0003 = "如果将运算符放在操作数之后，表达式的值就是操作数的原始值。"
Arithmetic_DESC7 Line0004 = "例如，如果 Locals.x 为 3.0，则在计算以下表达式后，Locals.x 为 4.0，Locals.y 为 14.0。\n"
Arithmetic_DESC7 Line0005 = " Locals.y = ++Locals.x + 10.0\n"
Arithmetic_DESC7 Line0006 = "另一方面，在计算以下表达式后，Locals.x 为 4.0，Locals.y 为 13.0。\n"
Arithmetic_DESC7 Line0007 = " Locals.y = Locals.x++ + 10.0"
Arithmetic_DESC7 Line0008 = "\n对于 TestStand 变量，此操作相对于其他执行线程是原子的。在操作执行时，其他线程无法访问或更改操作数。"
Arithmetic_SYM8 = "--"
Arithmetic_OP8 = "递减"
Arithmetic_DESC8 Line0001 = "前减或后减。将操作数中的值减 1.0。您可以将运算符放在操作数之前或之后。"
Arithmetic_DESC8 Line0002 = "如果将运算符放在操作数之前，表达式的值就是操作数的新值。"
Arithmetic_DESC8 Line0003 = "如果将运算符放在操作数之后，表达式的值就是操作数的原始值。"
Arithmetic_DESC8 Line0004 = "例如，如果 Locals.x 为 3.0，则在计算以下表达式后，Locals.x 为 2.0，Locals.y 为 12.0。\n"
Arithmetic_DESC8 Line0005 = " Locals.y = --Locals.x + 10.0\n"
Arithmetic_DESC8 Line0006 = "另一方面，在计算以下表达式后，Locals.x 为 2.0，Locals.y 为 13.0。\n"
Arithmetic_DESC8 Line0007 = " Locals.y = Locals.x-- + 10.0"
Arithmetic_DESC8 Line0008 = "\n对于 TestStand 变量，此操作相对于其他执行线程是原子的。在操作执行时，其他线程无法访问或更改操作数。"
Assignment_SYM1 ="="
Assignment_OP1 = "作业"
Assignment_DESC1 Line0001 = "计算运算符右侧的表达式并将运算符左侧的操作数设置为结果。"
Assignment_DESC1 Line0002 = "对容器属性进行操作时，左右两边子属性名的层次结构必须匹配。对于每个"
Assignment_DESC1 Line0003 = "属性值，赋值尽可能在不同数据类型之间转换，例如，数字到字符串。"
Assignment_SYM2 = "+="
Assignment_OP2 = "加作业"
Assignment_DESC2 Line0001 = "自加法。计算运算符右侧的表达式，并将结果添加到左侧的操作数。"
Assignment_DESC2 Line0002 = "如果运算符右侧的表达式是字符串，则运算符将其转换为数值，然后再将其添加到左侧的操作数。"
Assignment_DESC2 Line0003 = "如果两边都是字符串，则运算符将右侧的字符串附加到左侧的字符串。如果两边都是数组，则运算符将数组的元素附加到右侧"
Assignment_DESC2 Line0004 = "side to the end of the array on the left. 对于作为 TestStand 变量的目标操作数，此运算符相对于其他执行线程是原子的。没有其他线程可以访问或更改目标操作数，而运算符执行。"
Assignment_SYM3 = "-="
Assignment_OP3 = "减去赋值"
Assignment_DESC3 Line0001 = "自减。计算运算符右侧的表达式，并从左侧的操作数中减去结果。"
Assignment_DESC3 Line0002 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM4 = "*="
Assignment_OP4 = "乘法-赋值"
Assignment_DESC4 Line0001 = "自乘。计算运算符右侧的表达式，将结果与左侧的操作数相乘，并将乘积赋给左侧的操作数。"
Assignment_DESC4 Line0002 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM5 = "/="
Assignment_OP5 = "划分作业"
Assignment_DESC5 Line0001 = "自除。计算运算符右侧的表达式，将结果除以左侧的操作数，并将商赋给左侧的操作数。"
Assignment_DESC5 Line0002 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM6 = "%="
Assignment_OP6 = "模数分配"
Assignment_DESC6 Line0001 = "自余数。计算运算符右侧的表达式，将结果除以左侧的操作数，并将余数赋给左侧的操作数。"
Assignment_DESC6 Line0002 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM7 = "^="
Assignment_OP7 = "异或赋值"
Assignment_DESC7 Line0001 = "Self-Bitwise-Xor。使用运算符右侧的表达式值和左侧操作数的值执行按位异或。将结果分配给左侧的操作数"
Assignment_DESC7 Line0002 = "在执行异或之前，运算符将两个值截断为整数值。"
Assignment_DESC7 Line0003 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM8 = "&="
Assignment_OP8 = "与-赋值"
Assignment_DESC8 Line0001 = "Self-Bitwise-And。使用运算符右侧的表达式值和左侧操作数的值执行按位与。将结果分配给左侧的操作数。"
Assignment_DESC8 Line0002 = "在执行异与之前，运算符将两个值截断为整数值。如果两个操作数都是字符串，则运算符将第二个操作数的值附加到第一个操作数。"
Assignment_DESC8 Line0003 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"
Assignment_SYM9 = "|="
Assignment_OP9 = "或-赋值"
Assignment_DESC9 = "自按位或"
Assignment_DESC9 Line0001 = "Self-Bitwise-Or。使用运算符右侧的表达式值和左侧操作数的值执行按位或。将结果分配给左侧的操作数。 "
Assignment_DESC9 Line0002 = "在执行异或之前，运算符将两个值截断为整数值。"
Assignment_DESC9 Line0003 = "对于作为 TestStand 变量的目标操作数，此运算符对于其他执行线程而言是原子的。在运算符执行时，其他线程无法访问或更改目标操作数。"

Comparison_SYM1 = "=="
Comparison_OP1 = "平等"
Comparison_DESC1 Line0001 = "如果左右操作数相等，则计算结果为真。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，则运算符将字符串转换为数值"
Comparison_DESC1 Line0002 = "如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。相等运算符认为 NAN 和 IND 数字是等价的。"
Comparison_SYM2 = "!="
Comparison_OP2 = "不等式（C/C++/C# 语法）"
Comparison_DESC2 Line0001 = "如果左右操作数不相等，则计算结果为 True。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，则运算符将字符串转换为数字价值。 "
Comparison_DESC2 Line0002 = "如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"
Comparison_SYM3 = "<>"
Comparison_OP3 = "不等式（基本语法）"
Comparison_DESC3 Line0001 = "如果左右操作数不相等，则计算结果为 True。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，则运算符将字符串转换为数字价值。 "
Comparison_DESC3 Line0002 = "如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"
Comparison_SYM4 = ">"
Comparison_OP4 = "大于"
Comparison_DESC4 Line0001 = "如果左侧操作数大于右侧操作数，则计算结果为真。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，"
Comparison_DESC4 Line0002 = "运算符将字符串转换为数值。如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"
Comparison_SYM5 = ">="
Comparison_OP5 = "大于等于"
Comparison_DESC5 Line0001 = "如果左侧操作数大于或等于右侧操作数，则计算结果为真。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，"
Comparison_DESC5 Line0002 = "运算符将字符串转换为数值。如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"
Comparison_SYM6 = "<"
Comparison_OP6 = "小于"
Comparison_DESC6 Line0001 = "如果左侧操作数小于右侧操作数，则计算结果为真。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，"
Comparison_DESC6 Line0002 = "运算符将字符串转换为数值。如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"
Comparison_SYM7 = "<="
Comparison_OP7 = "小于等于"
Comparison_DESC7 Line0001 = "如果左侧操作数小于或等于右侧操作数，则计算结果为真。适用于字符串、数字和布尔值。如果一个操作数是字符串而另一个是数字，"
Comparison_DESC7 Line0002 = "运算符将字符串转换为数值。如果两个操作数都是字符串，则比较不区分大小写。如果两个操作数都是数值，则比较使用 14 位精度。"

Bitwise_SYM1 ="与"
Bitwise_OP1 = "和（基本语法）"
Bitwise_DESC1 Line0001 = "计算两个数值的按位与。在应用运算符之前将数值截断为整数。"
Bitwise_DESC1 Line0002 = "如果两个操作数都是字符串，则运算符返回一个字符串，它是两个操作数的串联。"
Bitwise_DESC1 Line0003 = "否则，此运算符返回一个数字。"
Bitwise_SYM2 ="或"
Bitwise_OP2 = "或（基本语法）"
Bitwise_DESC2 Line0001 = "计算两个数值的按位或。在应用运算符之前将数值截断为整数。"
Bitwise_DESC2 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_SYM3 ="不"
Bitwise_OP3 = "补码（基本语法）"
Bitwise_DESC3 Line0001 = "计算数值的二进制补码。在应用运算符之前将数值截断为整数。"
Bitwise_DESC3 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_DESC3 Line0003 = "请注意，如果您对布尔值使用此运算符，您可能会得到意想不到的结果，因为 NOT True 返回 0xFFFFFFFE。"
Bitwise_SYM4 = "异或"
Bitwise_OP4 = "异或（基本语法）"
Bitwise_DESC4 Line0001 = "计算两个数值的按位异或。在应用运算符之前将数值截断为整数。"
Bitwise_DESC4 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_SYM5 = "&"
Bitwise_OP5 = "和（C/C++/C# 语法）"
Bitwise_DESC5 Line0001 = "计算两个数值的按位与。在应用运算符之前将数值截断为整数。"
Bitwise_DESC5 Line0002 = "如果两个操作数都是字符串，则运算符返回一个字符串，它是两个操作数的串联。"
Bitwise_DESC5 Line0003 = "否则，此运算符返回一个数字。"
Bitwise_SYM6 ="|"
Bitwise_OP6 = "或（C/C++/C#语法）"
Bitwise_DESC6 Line0001 = "计算两个数值的按位或。在应用运算符之前将数值截断为整数。"
Bitwise_DESC6 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_SYM7 = "~"
Bitwise_OP7 = "补码（C/C++/C#语法）"
Bitwise_DESC7 Line0001 = "计算数值的二进制补码。在应用运算符之前将数值截断为整数。"
Bitwise_DESC7 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_SYM8 = "^"
Bitwise_OP8 = "异或（C/C++/C# 语法）"
Bitwise_DESC8 Line0001 = "计算两个数值的按位异或。在应用运算符之前将数值截断为整数。"
Bitwise_DESC8 Line0002 = "这个运算符总是返回一个数字。"
Bitwise_SYM9 = ">>"
Bitwise_OP9 = "右移"
Bitwise_DESC9 = "将左侧操作数的值向右移动您在右侧操作数中指定的位数。在应用运算符之前将数值截断为整数。"
Bitwise_SYM10 ="<<"
Bitwise_OP10 = "左移"
Bitwise_DESC10 = "将左侧操作数的值向左移动您在右侧操作数中指定的位数。在应用运算符之前将数值截断为整数。"

Logical_SYM1 = "&&"
Logical_OP1 = "逻辑与"
Logical_DESC1 Line0001 = "如果两个操作数都为 True，则计算结果为 True。如果第一个操作数为 False，则不计算第二个操作数。在应用运算符之前，数字操作数如果非零则转换为 True，如果为零则转换为 False。"
Logical_DESC1 Line0002 = "如果文本为 \"True\" 或包含非零数字的表示，则字符串操作数转换为 True，否则为 False。"
Logical_SYM2 ="||"
Logical_OP2 = "逻辑或"
Logical_DESC2 Line0001 = "如果一个或两个操作数为真，则计算为真。如果第一个操作数为真，则不计算第二个操作数。在应用运算符之前，数字操作数如果非零则转换为真，如果为零则转换为假。 "
Logical_DESC2 Line0002 = "如果文本为 \"True\" 或包含非零数字的表示，则字符串操作数转换为 True，否则为 False。"
Logical_SYM3 ="！"
Logical_OP3 = "逻辑非"
Logical_DESC3 Line0001 = "如果操作数为 False，则计算结果为 True；如果操作数为 True，则计算结果为 False。"
Logical_DESC3 Line0002 = "在应用运算符之前，数字操作数如果非零则转换为 True，如果为零则转换为 False。"
Logical_DESC3 Line0003 = "如果文本为 \"True\" 或包含非零数字的表示，则字符串操作数转换为 True，否则为 False。"

Other_SYM1 = "( )"
Other_OP1 = "括号"
Other_DESC1 = "改变评估顺序。"
Other_SYM2 = "."
Other_OP2 = "点"
Other_DESC2 = "属性字段分隔符。"
Other_SYM3 ="[]"
Other_OP3 = "括号"
Other_DESC3 Line0001= "数组下标。多维语法：数组[1][2][3]\n"
Other_DESC3 Line0002= "注意：您可以使用名称字符串作为命名属性对象的一维数组的索引。通常，您使用名称字符串作为步骤或序列数组的索引。"
Other_DESC3 Line0003= "这允许您通过名称引用特定的步骤或序列，而不依赖于它在数组中的位置。示例：\n"
Other_DESC3 Line0004= " RunState.Sequence.Main[\"开机测试\"]\n"
Other_DESC3 Line0005= " RunState.InitialSelection.SelectedFile.Data.Seq[\"MainSequence\"]"
Other_SYM4 = ","
Other_OP4 = "逗号（分号）"
Other_DESC4 Line0001 = "表达式分隔符。用法：<expr1> , <expr2>。组合表达式的结果是最后一个表达式 expr2 的结果。\n"
Other_DESC4 Line0002 = "您还可以使用逗号分隔传递给表达式函数的参数。\n"
Other_DESC4 Line0003 = "注意：如果启用使用本地化小数点站选项并且系统的本地化小数点字符是逗号，则小数点必须使用逗号。"
Other_DESC4 Line0004 = "在这种情况下，您必须使用分号分隔表达式和函数参数。\n"
Other_DESC4 Line0005 = "当 TestStand 存储表达式时，它始终使用句点作为小数点，使用逗号作为表达式分隔符和参数分隔符。"
Other_DESC4 Line0006 = "根据您的设置，TestStand 在显示表达式时会转换这些字符。"
Other_SYM5 ="？："
Other_OP5 = "有条件的"
Other_DESC5 = "根据布尔表达式的结果，选择其他两个表达式之一进行计算。用法：booleanValue ? <expr1> : <expr2>。booleanValue 可以是表达式的计算结果，该表达式被计算为 True 或 False . 如果 booleanValue 为 True，则返回 expr1。否则，返回 expr2。"
Other_SYM6 = "{element1, element2, etc.}"
Other_OP6 = "数组文字"
Other_DESC6 Line0001= "声明数字、字符串、布尔值、对象引用或容器的一维数组。"
Other_DESC6 Line0002= "如果所有元素都是同一类型，则结果数组是该类型元素的数组。如果所有元素不是同一类型，则结果数组是容器数组。\n"
Other_DESC6 Line0003= "示例：\n"
Other_DESC6 Line0004= " {1, 2.3, 4, 5} // 数字数组\n"
Other_DESC6 Line0005= " {\"Cat\", \"Dog\", \"Fish\"} // 字符串数组\n"
Other_DESC6 Line0006= " Locals.numArray += {3.14} // 添加一个元素到数字数组\n"
Other_SYM7 = "//"
Other_OP7 = "单行注释（C++/C#语法）"
Other_DESC7 Line0001= "指定一行中剩余的字符为注释。示例：\n\n"
Other_DESC7 Line0002= "Locals.Channel += 1 // 前进到下一个频道\n"
Other_SYM8 = "'"
Other_OP8 = "单行注释（基本语法）"
Other_DESC8 Line0001= "指定一行剩余字符为注释。示例：\n\n"
Other_DESC8 Line0002= "Locals.Channel += 1 ' 前进到下一个频道\n"
Other_SYM9 = "/* */"
Other_OP9 = "注释（C/C++/C# 语法）"
Other_DESC9 Line0001= "指定分隔符内的字符为注释。示例：\n\n"
Other_DESC9 Line0002= "/*==========================\n"
Other_DESC9 Line0003= "计算下一个频率\n"
Other_DESC9 Line0004= "============================*/\n"
Other_DESC9 Line0005= "Locals.Frequency = Locals.SweepIndex /* 扫描索引永远不会为零！*/ * Locals.FrequencyStepSize\n"
Other_SYM10 = "&"
Other_OP10 = "获取参考"
Other_DESC10 Line0001= "返回引用操作数的引用。"
Other_SYM11 = "*"
Other_OP11 = "解引用"
Other_DESC11 Line0001 = "返回 Reference 操作数引用的对象。Reference 必须引用支持 TestStand PropertyObject 接口的对象。"
Other_SYM12 = "->"
Other_OP12 = "取消引用和访问字段"
Other_DESC12 Line0001= "返回 Reference 操作数引用的对象的指定子属性。Reference 必须引用支持 TestStand PropertyObject 接口的对象。" 
Other_SYM13 = ".."
Other_OP13 = "范围运算符"
Other_DESC13 Line0001 = "范围运算符。仅在数组下标中使用。用法：array[1..5]、array[1..]、array[..5]、array[<expr1>..<expr2> ]\n"
Other_DESC13 Line0002 = "注意：您可以在 \"..\" 运算符的任一侧指定表达式，它们将被计算。"


Colors_SYM1 = "tsRed"
Colors_OP1 = "颜色常量"
Colors_DESC1 = "红色的符号常量。值：0x000000FF。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM2 = "tsGreen"
Colors_OP2 = "颜色常量"
Colors_DESC2 = "绿色的符号常量。值：0x0000FF00。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM3 = "tsBlue"
Colors_OP3 = "颜色常量"
Colors_DESC3 = "蓝色的符号常量。值：0x00FF0000。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM4 = "tsCyan"
Colors_OP4 = "颜色常量"
Colors_DESC4 = "青色的符号常量。值：0x00FFFF00。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM5 = "tsMagenta"
Colors_OP5 = "颜色常量"
Colors_DESC5 = "品红色的符号常量。值：0x00FF00FF。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM6 = "tsYellow"
Colors_OP6 = "颜色常量"
Colors_DESC6 = "黄色的符号常量。值：0x0000FFFF。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM7 = "tsDarkRed"
Colors_OP7 = "颜色常量"
Colors_DESC7 = "暗红色的符号常量。值：0x00000080。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM8 = "tsDarkGreen"
Colors_OP8 = "颜色常量"
Colors_DESC8 = "深绿色的符号常量。值：0x00008000。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM9 = "tsDarkBlue"
Colors_OP9 = "颜色常量"
Colors_DESC9 = "深蓝色的符号常量。值：0x00800000。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM10 = "tsDarkCyan"
Colors_OP10 = "颜色常量"
Colors_DESC10 = "暗青色的符号常量。值：0x00808000。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM11 = "tsDarkMagenta"
Colors_OP11 = "颜色常量"
Colors_DESC11 = "深洋红色的符号常量。值：0x00800080。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM12 = "tsDarkYellow"
Colors_OP12 = "颜色常量"
Colors_DESC12 = "深黄色的符号常量。值：0x00008080。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM13 = "tsWhite"
Colors_OP13 = "颜色常量"
Colors_DESC13 = "白色的符号常量。值：0x00FFFFFF。颜色值采用小端格式。使用 ConvertColor 函数更改为大端格式。"
Colors_SYM14 = "tsLightGray"
Colors_OP14 = "颜色常量"
Colors_DESC14 = "浅灰色的符号常量。值：0x00C0C0C0。"
Colors_SYM15 = "tsGray"
Colors_OP15 = "颜色常量"
Colors_DESC15 = "灰色的符号常量。值：0x00A0A0A0。"
Colors_SYM16 = "tsDarkGray"
Colors_OP16 = "颜色常量"
Colors_DESC16 = "深灰色的符号常量。值：0x00808080。"
Colors_SYM17 = "tsBlack"
Colors_OP17 = "颜色常量"
Colors_DESC17 = "黑色的符号常量。值：0x00000000。"
Colors_SYM18 = "tsDefaultColor"
Colors_OP18 = "颜色常量"
Colors_DESC18 = "项目默认颜色的符号常量。此常量仅适用于具有默认颜色的项目。值：0xFFFFFFFF。"

3Other_SYM1 = "1.23e-4"
3Other_OP1 = "浮点常量"
3Other_DESC1 Line0001 = "Range 1.7E-308 to 1.7E+308 with 15 significant digits. 注意：您在浮点数中使用的小数点字符由您的操作系统设置和使用本地化小数点决定"
3Other_DESC1 Line0002 = "站点选项对话框的本地化页面上的复选框。\n\n"
3Other_DESC1 Line0003 = "您还可以使用以下特殊浮点常量：\n"
3Other_DESC1 Line0004 = " NAN - 不是数字\n"
3Other_DESC1 Line0005 = " IND - 不确定\n"
3Other_DESC1 Line0006 = " INF - Infinity\n"
3Other_DESC1 Line0007 = "注意：IND是NAN的一种特殊类型，在比较运算中，IND和NAN是等价的。\n"
3Other_SYM2 = "1234, 0xFFFF, 0b1011"
3Other_OP2 = "32 位整数常量"
3Other_DESC2 = "范围 -2147483648 到 4294967295。TestStand 支持使用 0x 和 0b 前缀的十六进制和二进制常量。TestStand 将这些常量的十六进制和二进制版本视为范围为 0 到 4294967295 的无符号值。TestStand在内部将这些常量转换并表示为双精度浮点数。"
3Other_SYM3 = "1234i64, 0xFFFFi64, 0b1011i64"
3Other_OP3 = "64 位有符号整数常量"
3Other_DESC3 = "范围 -9223372036854775808i64 到 9223372036854775807i64。TestStand 支持使用 0x 和 0b 前缀的十六进制和二进制常量，但是，如果设置了高位，常量将被解释为负值。"
3Other_SYM4 = "1234ui64, 0xFFFFui64, 0b1011ui64"
3Other_OP4 = "64 位无符号整数常量"
3Other_DESC4 = "范围从 0ui64 到 18446744073709551615ui64。TestStand 支持十六进制和二进制，这种常量使用 0x 和 0b 前缀。"
3Other_SYM5 = "真/假"
3Other_OP5 = "布尔常量"
3Other_DESC5 = "真或假。"
3Other_SYM6 = "\"1234wxyz\""
3Other_OP6 = "字符串常量"
3Other_DESC6 Line0001 = "将字符串常量括在引号中。\n您可以在字符串常量中使用以下转义序列：\n"
3Other_DESC6 Line0002 = " \\\\ 反斜杠\n \\n 换行\n \\r 回车\n \\xNN 十六进制字符代码\n \\\" 引号\n \\t 制表符"
3Other_SYM7 = "@\"C:\\Windows\\temp\""
3Other_OP7 = "未转义的字符串常量"
3Other_DESC7 = "在引号前添加 \'@\' 以将字符串常量转换为未转义的字符串常量。与常规字符串常量不同，反斜杠保留原样而不是指定转义序列。使用 \"\" 表示 \ "在未转义的字符串常量中。"
3Other_SYM8 = "无"
3Other_OP8 = "对象引用常量"
3Other_DESC8 Line0001 = "您可以通过比较引用与Nothing来判断一个对象引用是否引用了一个对象。您可以释放一个对象引用所引用的对象"
3Other_DESC8 Line0002= "在表达式中将引用的值设置为 Nothing。"
3Other_SYM9 = "PI"
3Other_OP9 = "PI 常量 (3.141592...)"
3Other_DESC9 = "圆的周长与其直径的比值。"
3Other_SYM10 = "南"
3Other_OP10 = "不是数字"
3Other_DESC10 = "一个无效的数值。\n\n注意：IND 是一种特殊类型的 NAN。在比较操作中，IND 和 NAN 是等价的。"
3Other_SYM11 = "IND"
3Other_OP11 = "不确定数字"
3Other_DESC11 = "不确定的数值。"
3Other_SYM12 = "INF"
3Other_OP12 = "无限数"
3Other_DESC12 = "一个无穷大或负无穷大的数值。"
3Other_SYM13 = "枚举"
3Other_OP13 = "提供枚举类型定义的枚举常量"
3Other_DESC13 Line0001 = "Syntax: Enums.<Enumeration-Type-Name>.<Enumerator-Name>.\n\nExample: Enums.Flavors.Chocolate"
3Other_DESC13 Line0002 = "\n\n注意：您也可以使用 Enum() 函数。"

;;译者注意：函数描述第一行的逗号不应该被翻译。
;;例如，不应翻译"Array_DESC1 Line0001"中的逗号，但所有其他逗号，
;;包括 Line0002 等等，应该。
Array_SYM1 = "GetArrayBounds()"
Array_OP1 = "检索数组维度"
Array_DESC1 Line0001 = "Number GetArrayBounds(Array array, [Out] String lowerBounds, [Out] String upperBounds)\n"
Array_DESC1 Line0002 = "判断数组是否包含指定对象。函数将数组边界输出为字符串"
Array_DESC1 Line0003 = "使用语法 \"[i][j][k]\"，对于源的每个维度，在方括号中有一个整数值"
Array_DESC1 Line0004 = "数组。\n"
Array_DESC1 Line0005 = "参数 1：要检查的数组。\n"
Array_DESC1 Line0006 = "参数 2：一个字符串，函数在其中返回数组最小值的索引。\n"
Array_DESC1 Line0007 = "参数 3：一个字符串，函数在其中返回数组最大值的索引。\n"
Array_DESC1 Line0008 = "返回：函数总是返回 0。"
Array_SYM2 = "GetNumElements()"
Array_OP2 = "获取数组的大小"
Array_DESC2 Line0001 = "Number GetNumElements(Array 数组)\n"
Array_DESC2 Line0002 = "此函数返回数组中的数字元素。\n"
Array_DESC2 Line0003 = "参数 1：一个数组\n"
Array_DESC2 Line0004 = "返回：数组中元素的个数。对于多维数组，该函数返回"
Array_DESC2 Line0005 = "表示元素总数的单个值。"
Array_SYM3 = "插入元素()"
Array_OP3 = "将元素插入数组"
Array_DESC3 Line0001 = "InsertElements(Array array, String index, Number numElements)\n"
Array_DESC3 Line0002 = "此函数将新元素插入一维数组。\n"
Array_DESC3 Line0003 = "参数 1：一维数组。\n"
Array_DESC3 Line0004 = "参数 2：插入新元素的索引。您将数组索引指定为带有 "
Array_DESC3 Line0005 = "语法 \"[x]\"，其中 x 是一个整数常量。\n"
Array_DESC3 Line0006 = "参数3：要插入的元素个数，新元素的取值如下：False为"
Array_DESC3 Line0007 = "布尔值，数字为零，字符串为空字符串，引用为空引用，空容器"
Array_DESC3 Line0008 = "用于容器。\n"
Array_DESC3 Line0009 = "返回：此函数始终返回 0。"
Array_SYM4 = "移除元素()"
Array_OP4 = "从数组中删除元素"
Array_DESC4 Line0001 = "RemoveElements(Array array, String index, Number numElements)\n"
Array_DESC4 Line0002 = "此函数从一维数组中删除元素。\n"
Array_DESC4 Line0003 = "参数 1：一维数组。\n"
Array_DESC4 Line0004 = "参数 2：要从中删除元素的索引。将数组索引指定为带有 "
Array_DESC4 Line0005 = "语法 \"[x]\"，其中 x 是一个整数常量。\n"
Array_DESC4 Line0006 = "参数 3：要删除的元素数，包括索引元素。\n"
Array_DESC4 Line0007 = "返回：函数总是返回 0。"
Array_SYM5 = "SetArrayBounds()"
Array_OP5 = "重新定义数组"
Array_DESC5 Line0001 = "Number SetArrayBounds(Array array, String lowerBounds, String upperBounds)\n"
Array_DESC5 Line0002 = "此函数更改数组的边界。您可以使用此函数更改大小和/或"
Array_DESC5 Line0003 = "数组的维数。此函数将元素添加到数组或从数组中删除元素为"
Array_DESC5 Line0004 = "指定边界需要。以这种方式添加的新元素将具有该元素的默认值"
Array_DESC5 Line0005 = "类型，并被添加到数组的末尾。\n"
Array_DESC5 Line0006 = "参数 1：要重新维度的数组。\n"
Array_DESC5 Line0007 = "参数 2：指定新下限索引的字符串。将数组边界指定为"
Array_DESC5 Line0008 = "语法为 \"[i][j][k]\" 的字符串，" 的每个维度在方括号中有一个整数值
Array_DESC5 Line0009 = "源数组。\n"
Array_DESC5 Line0010 = "参数 3：一个字符串，指定新上限的索引。将数组边界指定为"
Array_DESC5 Line0011 = "语法为 \"[i][j][k]\" 的字符串，" 的每个维度在方括号中有一个整数值
Array_DESC5 Line0012 = "源数组。\n"
Array_DESC5 Line0013 = "返回：此函数始终返回 0。"
Array_SYM6 = "SetNumElements()"
Array_OP6 = "设置数组的大小"
Array_DESC6 Line0001 = "Number SetNumElements(Array array, Number numElements)\n"
Array_DESC6 Line0002 = "此函数设置一维数组中元素的数量。它保留下限和"
Array_DESC6 Line0003 = "可以放入新数组的所有元素的值。添加到数组的任何新元素都具有 "
Array_DESC6 Line0004 = "元素类型的默认值并被添加到数组的末尾。\n"
Array_DESC6 Line0005 = "参数 1：要调整大小的一维数组。\n"
Array_DESC6 Line0006 = "参数 2：所需的元素数量。\n"
Array_DESC6 Line0007 = "返回：此函数始终返回 0。"
Array_SYM7 = "FindIndex()"
Array_OP7 = "在数组中查找对象的索引字符串"
Array_DESC7 Line0001 = "String FindIndex(Array array, PropertyObject object, Boolean caseSensitive = True)\n"
Array_DESC7 Line0002 = "此函数在给定数组中搜索指定值的第一个索引。函数 "
Array_DESC7 Line0003 = "将数组边界作为字符串返回，语法为 \"[i][j][k]\"，方括号中为整数值 "
Array_DESC7 Line0004 = "对于源数组的每个维度。注意：要获得数字索引结果，请使用 FindOffset 函数"
Array_DESC7 Line0005 = "而不是 FindIndex。\n"
Array_DESC7 Line0006 = "参数 1：要搜索的数组。\n"
Array_DESC7 Line0007 = "参数 2：要找到的值。\n"
Array_DESC7 Line0008 = "参数 3：对于字符串数组，传递 True 以使用区分大小写的比较。\n"
Array_DESC7 Line0009 = "返回：如果找到，返回值的索引字符串。如果没有找到，返回空字符串。"
Array_SYM8 = "排序()"
Array_OP8 = "对给定的数组进行排序"
Array_DESC8 Line0001 = "Array Sort(Array array, Boolean inPlace, Boolean stable = False, Boolean caseSensitive = True)\n"
Array_DESC8 Line0002 = "此函数对指定数组的元素进行排序。\n"
Array_DESC8 Line0003 = "参数 1：要排序的输入数组。\n"
Array_DESC8 Line0004 = "参数2：传True直接修改输入数组（就地操作）传False修改"
Array_DESC8 Line0005 = "仅返回值，不修改输入数组。\n"
Array_DESC8 Line0006 = "参数 3：传递 True 以运行稳定排序，其中保证具有相同排序优先级的元素 "
Array_DESC8 Line0007 = "排序后保持相同顺序。此选项会影响不区分大小写匹配的字符串值"
Array_DESC8 Line0008 = "在不区分大小写的排序中。\n"
Array_DESC8 Line0009 = "参数 4：传递 True 以使用区分大小写的排序。如果为 True，大写字母优先于小写字母"
Array_DESC8 Line0010 = "排序顺序中的字母。\n"

Array_DESC8 Line0011 = "返回：返回排序后的数组。如果就地排序，返回你传递的数组。否则，返回"
Array_DESC8 Line0012 = "数组的排序副本。"
Array_SYM9 = "FindOffset()"
Array_OP9 = "查找对象在数组中的偏移量"
Array_DESC9 Line0001 = "Number FindOffset(Array array, PropertyObject object, Boolean caseSensitive = True)\n"
Array_DESC9 Line0002 = "返回数组中指定对象的第一个实例的数组偏移量。此函数考虑"
Array_DESC9 Line0003 = "返回偏移量时非零下界。对于多于一维的数组，偏移量"
Array_DESC9 Line0004 = "表示扁平化为一维后在数组中的位置。注：获取字符串"
Array_DESC9 Line0005 = "索引结果如 \"[1][2]\"，使用 FindIndex 函数而不是 FindOffset。\n"

Array_DESC9 Line0006 = "参数 1：要搜索的数组。\n"
Array_DESC9 Line0007 = "参数 2：要搜索的值。\n"
Array_DESC9 Line0008 = "参数 3：对于字符串数组，传递 True 以使用区分大小写的比较。\n"
Array_DESC9 Line0009 = "返回：如果找到指定值，返回值的偏移量。如果指定值不存在"
Array_DESC9 Line0010 = "找到，返回 -1。"
Array_SYM10 = "包含()"
Array_OP10 = "判断数组是否包含你指定的对象或值"
Array_DESC10 Line0001 = "Boolean Contains(Array array, PropertyObject object, Boolean caseSensitive = True)\n"
Array_DESC10 Line0002 = "如果在数组中找到指定的对象或值，则此函数返回 True。注意：要找到 "
Array_DESC10 Line0003 = "对象或值的位置，使用FindIndex或FindOffset函数获取数组索引"
Array_DESC10 Line0004 = "string (eg \"[0][1]\") 或偏移值，分别为。\n"
Array_DESC10 Line0005 = "参数 1：要搜索的数组。\n"
Array_DESC10 Line0006 = "参数 2：要搜索的值。\n"
Array_DESC10 Line0007 = "参数 3：对于字符串数组，传递 True 以使用区分大小写的比较。\n"
Array_DESC10 Line0008 = "返回：如果找到，返回 True。如果没有找到，返回 False。"
Array_SYM11 = "设置元素()"
Array_OP11 = "将值分配给数组的多个元素"
Array_DESC11 Line0001 = "SetElements(Array 数组，PropertyObject 值，[字符串范围])\n"
Array_DESC11 Line0002 = "此函数将传递的值分配给传递数组的所有索引。如果指定了索引范围，"
Array_DESC11 Line0003 = "只有范围内的元素被赋予传递的值。\n"
Array_DESC11 Line0004 = "参数 1：应为其分配值的数组。\n"
Array_DESC11 Line0005 = "参数 2：要分配给数组指定部分的值。\n"
Array_DESC11 Line0006 = "参数 3：一个可选参数，指定范围字符串，指定数组的索引到 "
Array_DESC11 Line0007 = "应该给哪个值赋值。例如范围\"[0..2]\"指定元素[0]、[1]和"
Array_DESC11 Line0008 = "[2]。如果未指定，范围假定为整个数组。请参阅"中的"括号"部分
Array_DESC11 Line0009 = "有关指定索引范围的更多信息，表达式运算符帮助主题。\n"
Array_DESC11 Line0010 = "返回：	此函数始终返回 0。"
Array_SYM12 = "IndexToOffset()"
Array_OP12 = "为传递的数组返回由传递的维度字符串表示的偏移量"
Array_DESC12 Line0001 = "Number IndexToOffset(Array array, String index)\n"
Array_DESC12 Line0002 = "此函数返回等于指定数组索引字符串的数字偏移量。注意："
Array_DESC12 Line0003 = "要从偏移量转换为索引，请使用 OffsetToIndex 函数。\n"
Array_DESC12 Line0004 = "参数 1：一个数组。\n"
Array_DESC12 Line0005 = "参数 2：需要找到相应偏移量的字符串索引。索引的语法为 "
Array_DESC12 Line0006 = "\"[i][j][k]\"，源数组的每个维度在方括号中有一个整数值。\n"
Array_DESC12 Line0007 = "返回：	返回数字偏移量。"
Array_SYM13 = "OffsetToIndex()"
Array_OP13 = "返回表示传递数组的传递偏移量的维度字符串"
Array_DESC13 Line0001 = "String OffsetToIndex(Array array, Number offset)\n"
Array_DESC13 Line0002 = "此函数返回等于指定数字偏移量的数组索引字符串。"
Array_DESC13 Line0003 = "index 的语法为 \"[i][j][k]\"，" 的每个维度在方括号中有一个整数值
Array_DESC13 Line0004 = "源数组。注意：要从索引转换为偏移量，请使用 IndexToOffset 函数。\n"

Array_DESC13 Line0005 = "参数 1：一个数组。\n"
Array_DESC13 Line0006 = "参数 2：需要找到相应字符串索引的偏移量。\n"
Array_DESC13 Line0007 = "返回：	返回字符串数组索引。"

Numeric_SYM1 = "Abs()"
Numeric_OP1 = "绝对值"
Numeric_DESC1 Line0001 = "Number Abs(Number number)\n"


Numeric_DESC1 Line0002 = "返回：您传递的数字的绝对值。"
Numeric_SYM2 = "ACos()"
Numeric_OP2 = "反余弦"
Numeric_DESC2 Line0001 = "Number ACos(Number number)\n"
Numeric_DESC2 Line0002 = "返回：指定参数的反余弦的主要弧度值。不确定的"
Numeric_DESC2 Line0003 = "参数不在 [-1,1] 范围内时的值 (IND) 结果。\n"
Numeric_SYM3 = "升序()"
Numeric_OP3 = "获取字符值"
Numeric_DESC3 Line0001 = "Number Asc(String string)\n"


Numeric_DESC3 Line0002 = "返回：字符串中第一个字符的字符代码值。"
Numeric_SYM4 = "ASin()"
Numeric_OP4 = "反正弦"
Numeric_DESC4 Line0001 = "Number ASin(Number number)\n"
Numeric_DESC4 Line0002 = "返回：指定参数的反正弦的主要弧度值。不确定的"
Numeric_DESC4 Line0003 = "参数不在 [-1,1] 范围内时的值 (IND)。\n"
Numeric_SYM5 = "ATan()"
Numeric_OP5 = "反正切"
Numeric_DESC5 Line0001 = "Number ATan(Number number)\n"
Numeric_DESC5 Line0002 = "返回：指定参数的反正切的主要弧度值。\n"
Numeric_SYM6 = "余弦()"
Numeric_OP6 = "余弦"
Numeric_DESC6 Line0001 = "Number Cos(Number number)\n"
Numeric_DESC6 Line0002 = "返回：数字的余弦值（数字以弧度为单位）。从度数转换"
Numeric_DESC6 Line0003 = "到弧度，将角度乘以 (PI/180)。"
Numeric_SYM7 = "Exp()"
Numeric_OP7 = "指数（以 e 为底）"
Numeric_DESC7 Line0001 = "Number Exp(Number x)\n"
Numeric_DESC7 Line0002 = "返回：数字常量 e 的 x 次方。"

Numeric_SYM8 = "Float64()"
Numeric_OP8 = "将任何类型转换为具有双精度 64 位浮点表示形式的数字"
Numeric_DESC8 Line0001 = "Number Float64(AnyType 值)\n"
Numeric_DESC8 Line0002 = "返回：此函数将任何类型转换为具有双精度 64 位表示形式的数字"
Numeric_DESC8 Line0003 = "浮点数。\n"


Numeric_SYM9 = "Int64()"
Numeric_OP9 = "将任何类型转换为具有符号 64 位整数表示形式的数字"
Numeric_DESC9 Line0001 = "Number {Signed 64-bit Integer} Int64(AnyType value)\n"
Numeric_DESC9 Line0002 = "返回：此函数将任何类型转换为具有符号 64 位整数表示形式的数字。"
Numeric_DESC9 Line0003 = "注意：不要使用它来创建 64 位整数常量。使用 i64 后缀代替，例如，9223372036854775807i64 "
Numeric_DESC9 Line0004 = "or 0x7fffffffffffffffi64. 见表达式中Operators/Functions->Constants->Other下的帮助"
Numeric_DESC9 Line0005 = "更多详细信息的浏览器对话框。\n"
  


Numeric_SYM10 = "日志()"
Numeric_OP10 = "自然对数（以 e 为底）"
Numeric_DESC10 Line0001 = "Number Log(Number number)\n"
Numeric_DESC10 Line0002 = "返回：数字的自然（以 e 为底）对数。数字必须大于 0。\n"


Numeric_SYM11 = "Log10()"
Numeric_OP11 = "对数（以 10 为底）"
Numeric_DESC11 Line0001 = "Number Log10(Number number)\n"
Numeric_DESC11 Line0002 = "返回：数字的以 10 为底的对数。数字必须大于 0。\n"


Numeric_SYM12 = "最大值()"
Numeric_OP12 = "确定最大值"
Numeric_DESC12 Line0001 = "Number Max(Number number1, Number number2, etc.)\n"
Numeric_DESC12 Line0002 = "返回：此函数返回您传递给它的数字集中的最大数字。或者，"
Numeric_DESC12 Line0003 = "你可以使用原型 Max(Array array, [String/Number] [indexOrOffset]) 来使用这个函数来查找 "
Numeric_DESC12 Line0004 = "数组中的最大元素。在这种情况下，您可以选择为第二个传递数字或字符串"
Numeric_DESC12 Line0005 = "用于存储数组中最大元素的数值数组偏移量或数组索引字符串的参数，"

Numeric_DESC12 Line0006 = "分别。"
Numeric_SYM13 = "最小值()"
Numeric_OP13 = "确定最小值"
Numeric_DESC13 Line0001 = "Number Min(Number number1, Number number2, etc.)\n"
Numeric_DESC13 Line0002 = "返回：此函数返回您传递给它的一组数字中的最小数字。或者，"
Numeric_DESC13 Line0003 = "你可以使用原型 Min(Array array, [String/Number] [indexOrOffset]) 来使用这个函数来查找 "
Numeric_DESC13 Line0004 = "数组中的最小元素。在这种情况下，您可以选择为第二个传递数字或字符串"
Numeric_DESC13 Line0005 = "用于存储数组中最小元素的数值数组偏移量或数组索引字符串的参数，"

Numeric_DESC13 Line0006 = "分别。"
Numeric_SYM14 = "Pow()"
Numeric_OP14 = "To the Power Of"
Numeric_DESC14 Line0001 = "Number Pow(Number base, Number exponent)\n"
Numeric_DESC14 Line0002 = "这个函数返回一个基值的指定幂。\n"
Numeric_DESC14 Line0003 = "参数 1：指定基值的数字。\n"
Numeric_DESC14 Line0004 = "参数 2：指定指数值的数字。\n"
Numeric_DESC14 Line0005 = "返回：数字 x 的 y 次方。"
Numeric_SYM15 = "随机()"
Numeric_OP15 = "产生一个随机数"
Numeric_DESC15 Line0001 = "Number Random(Number low, Number high, [Number seed])\n"
Numeric_DESC15 Line0002 = "此函数返回指定低值和高值之间的随机数。\n"
Numeric_DESC15 Line0003 = "参数 1：随机数的下限。\n"
Numeric_DESC15 Line0004 = "参数 2：随机数的上限。\n"
Numeric_DESC15 Line0005 = "参数 3：函数用于确定随机虚拟序列中位置的可选数字"
Numeric_DESC15 Line0006 = "numbers 该函数获得其随机数。当您使用相同的值为 Random 函数播种时，"
Numeric_DESC15 Line0007 = "对 Random 的后续调用返回相同的数字序列。如果传递 0.0 的种子值，"
Numeric_DESC15 Line0008 = "函数根据当前时间生成种子值。如果不传递种子值，函数"
Numeric_DESC15 Line0009 = "返回当前随机数序列中的下一个数字。\n"
Numeric_DESC15 Line0010 = "返回：随机数。"
Numeric_SYM16 = "圆()"
Numeric_OP16 = "四舍五入"
Numeric_DESC16 Line0001 = "Number Round(Number number, Number option = 0)\n"
Numeric_DESC16 Line0002 = "此函数使用指定的舍入方法将数字舍入为整数。\n"
Numeric_DESC16 Line0003 = "参数 1：要舍入的数字。\n"
Numeric_DESC16 Line0004 = "参数 2：可选参数：如何舍入。使用以下值：\n"
Numeric_DESC16 Line0005 = " 0 -（默认）向零舍入\n"
Numeric_DESC16 Line0006 = " 1 - 从零舍入。\n"
Numeric_DESC16 Line0007 = " 2 - 向正无穷大舍入。\n"
Numeric_DESC16 Line0008 = " 3 - 向负无穷大舍入。\n"
Numeric_DESC16 Line0009 = " 4 - 舍入到最接近的整数。如果数字恰好在两个整数之间，则舍入到最接近的 "
Numeric_DESC16 Line0010 = "偶数。\n"
Numeric_DESC16 Line0011 = "返回：四舍五入的数字。"
Numeric_SYM17 = "Sin()"
Numeric_OP17 = "正弦波"
Numeric_DESC17 Line0001 = "Number Sin(Number number)\n"
Numeric_DESC17 Line0002 = "返回：数字的正弦值（数字以弧度为单位）。将度数转换为 "
Numeric_DESC17 Line0003 = "弧度，度数乘以 (PI/180)。"
Numeric_SYM18 = "Sqrt()"
Numeric_OP18 = "平方根"
Numeric_DESC18 Line0001 = "Number Sqrt(Number number)\n"
Numeric_DESC18 Line0002 = "返回：数字的平方根。数字必须 >= 0。\n"


Numeric_SYM19 = "Tan()"
Numeric_OP19 = "正切"
Numeric_DESC19 Line0001 = "Number Tan(Number number)\n"
Numeric_DESC19 Line0002 = "返回：数字的正切（数字以弧度为单位）。从度数转换"
Numeric_DESC19 Line0003 = "弧度乘以 (PI/180)。"
Numeric_SYM20 = "UInt64()"
Numeric_OP20 = "将任何类型转换为具有无符号 64 位整数表示形式的数字"
Numeric_DESC20 Line0001 = "Number {Unsigned 64-bit Integer} UInt64(Any Type value)\n"
Numeric_DESC20 Line0002 = "返回：此函数将任何类型转换为具有无符号 64 位整数表示形式的数字。"
Numeric_DESC20 Line0003 = "注意：不要使用它来创建 64 位整数常量。请改用 ui64 后缀，例如，"
Numeric_DESC20 Line0004 = "18446744073709551615ui64 或 0xffffffffffffffffui64。请参阅 Operators/Functions->Constants->Other 下的帮助"
Numeric_DESC20 Line0005 = "在表达式浏览器对话框中获取更多详细信息。"


Numeric_SYM21 = "Val()"
Numeric_OP21 = "将字符串或枚举值转换为 64 位浮点数"
Numeric_DESC21 Line0001 = "Number Val(String|Enumeration stringOrEnumeration, [Out] [Boolean isValid])\n"

Numeric_DESC21 Line0002 = "参数 1：要转换的字符串或枚举。枚举必须具有默认的数字表示。\n"
Numeric_DESC21 Line0003 = "参数 2：函数设置的可选布尔参数，用于指示第一个参数是否存在"
Numeric_DESC21 Line0004 = "表示一个有效的浮点数。\n"
Numeric_DESC21 Line0005 = "返回：由字符串或枚举表示的 64 位浮点数。如果该项不表示有效的浮点数，则返回 0.0。"
Numeric_DESC21 Line0006 = "\n\n另见：Float64()、Int64()、UInt64()。"

Property_SYM1 = "CommentOf()"
Property_OP1 = "返回属性对象的注释"
Property_DESC1 Line0001 = "String CommentOf(PropertyObject propertyObject)\n"
Property_DESC1 Line0002 = "返回：属性对象的注释。\n"
Property_DESC1 Line0003 = "参数 1：属性对象（字符串、数字、容器等）。\n"


Property_SYM2 = "FindStep()"
Property_OP2 = "查找并返回具有指定唯一 ID 的步骤"
Property_DESC2 Line0001 = "Step FindStep(PropertyObject propertyObject, String uniqueStepId)\n"
Property_DESC2 Line0002 = "此函数搜索 propertyObject，它必须是序列或序列文件，以查找"
Property_DESC2 Line0003 = "由指定的唯一步骤 ID 标识的步骤。\n"
Property_DESC2 Line0004 = "参数 1：Sequence 或 SequenceFile 属性对象。\n"
Property_DESC2 Line0005 = "参数 2：唯一的步骤 ID 字符串。\n"
Property_DESC2 Line0006 = "返回：对 Step 对象的引用（如果找到的话）。否则，不返回任何内容。"
Property_SYM3 = "NameOf()"
Property_OP3 = "返回属性对象的名称"
Property_DESC3 Line0001 = "String NameOf(PropertyObject propertyObject)\n"

Property_DESC3 Line0002 = "参数 1：属性对象（字符串、数字、容器等）。\n"
Property_DESC3 Line0003 = "返回：属性对象的名称。注意：属性对象的名称通常是属性"
Property_DESC3 Line0004 = "name itself. 然而，这个函数对于检索数组元素的名称很有用，例如 "
Property_DESC3 Line0005 = "步骤组中的步骤，或序列文件中的序列。"
Property_SYM4 = "PropertyExists()"
Property_OP4 = "检查属性对象是否存在"
Property_DESC4 Line0001 = "Boolean PropertyExists(String propertyName)\n"
Property_DESC4 Line0002 = "参数 1：要检查的属性的查找字符串。\n"
Property_DESC4 Line0003 = "返回：如果属性存在则返回 True，否则返回 False。"
Property_SYM5 = "TypeOf()"
Property_OP5 = "返回属性对象的类型"
Property_DESC5 Line0001 = "String TypeOf(PropertyObject propertyObject, [Out] [String typeDisplayName], [Out] [PropertyValueTypes "
Property_DESC5 Line0002 = "propertyValueType", [Out] [Boolean isArray], [Out] [String namedType])\n"
Property_DESC5 Line0003 = "此函数返回一个属性对象的类型。注意：参数3、4、5返回相同的信息"
Property_DESC5 Line0004 = "作为 PropertyObject.GetType API 方法。\n"
Property_DESC5 Line0005 = "参数 1：属性对象（字符串、数字、容器等）。\n"
Property_DESC5 Line0006 = "参数 2：返回更详细类型信息的可选字符串。\n"
Property_DESC5 Line0007 = "参数 3：返回 PropertyValueTypes 枚举值的可选数字。参见 TestStand "
Property_DESC5 Line0008 = "帮助获取更多信息。此参数从不返回 PropValType_NamedType。\n"
Property_DESC5 Line0009 = "参数 4：返回属性对象是否为数组的可选布尔值。\n"
Property_DESC5 Line0010 = "参数 5：返回命名类型的可选字符串。如果 "
Property_DESC5 Line0011 = "属性对象不是命名类型的实例。\n"
Property_DESC5 Line0012 = "返回：包含您传递的属性对象的类型名称的字符串。\n"

String_SYM1 = "Chr()"
String_OP1 = "将字符值转换为单字符串。"
String_DESC1 Line0001 = "String Chr(Number 编号)\n"

String_DESC1 Line0002 = "返回：包含具有指定字符代码的字符的字符串。"

String_SYM2 = "DelocalizeExpression()"
String_OP2 = "离域表达式字符串"
String_DESC2 Line0001 = "String DelocalizeExpression(String localizedExpressionString, Number decimalPointOption = 1)\n"
String_DESC2 Line0002 = "此函数将本地化的表达式字符串转换为适合评估的标准形式。"
String_DESC2 Line0003 = "TestStand 需要它通过 Evaluate 表达式函数或 Evaluate 求值的表达式"
String_DESC2 Line0004 = "API 方法采用标准的非本地化形式，以便评估结果不依赖 "
String_DESC2 Line0005 = "在您的计算机的本地化设置上。调用此函数对您获得的表达式进行离域化处理"

String_DESC2 Line0006 = "来自用户输入。该函数替换代表小数的本地化小数点字符"
String_DESC2 Line0007 = "用句点字符指向表达式。如果本地化的小数点字符是逗号"
String_DESC2 Line0008 = "字符，函数也替换代表参数分隔符或表达式分隔符的分号"
String_DESC2 Line0009 = "带逗号。该函数不会更改字符串常量中的字符。\n"
String_DESC2 Line0010 = "参数 1：要转换的本地化表达式字符串。\n"
String_DESC2 Line0011 = "参数 2：一个可选数字，指定函数如何确定它假定的字符"
String_DESC2 Line0012 = "本地化表达式用于本地化小数点。有效值为：\n"

String_DESC2 Line0013 = " 1 - (default) 使用 Station Options 本地化首选项来确定是否使用操作 "
String_DESC2 Line0014 = "系统设置。\n"
String_DESC2 Line0015 = " 2 - 使用操作系统设置。\n"
String_DESC2 Line0016 = " 3 - 使用句点字符。\n"
String_DESC2 Line0017 = " 4 - 使用逗号\n"
String_DESC2 Line0018 = "返回：包含离域表达式的字符串。"
String_SYM3 = "查找()"
String_OP3 = "在字符串中查找子串"
String_DESC3 Line0001 = "Number Find(String string, String stringToSearchFor, Number indexToSearchFrom = 0, Boolean ignoreCase "
String_DESC3 Line0002 = "= False, Boolean searchInReverse = False)\n"
String_DESC3 Line0003 = "此函数在字符串中搜索子字符串。\n"
String_DESC3 Line0004 = "参数 1：一个字符串。\n"
String_DESC3 Line0005 = "参数 2：要查找的子字符串。\n"
String_DESC3 Line0006 = "参数 3：（可选）从零开始搜索的字符索引。默认值为 0。\n"
String_DESC3 Line0007 = "参数 4：（可选）传递 True 以在搜索时忽略字符大小写。默认值为 False。\n"
String_DESC3 Line0008 = "参数5：（可选）传True反向搜索字符串，默认为False。如果搜索"
String_DESC3 Line0009 = "相反，您传递给参数 3 的要搜索的索引相对于最后一个从零开始"
String_DESC3 Line0010 = "字符串中的字符。返回值相对于 " 中的第一个字符保持从零开始
String_DESC3 Line0011 = "原始非反转字符串。\n"
String_DESC3 Line0012 = "返回：从零开始的字符索引，从字符串的开头开始，第一个字符"
" String_DESC3 Line0013 = "在子字符串中。如果没有找到子字符串，函数返回 -1。
String_SYM4 = "左()"
String_OP4 = "从字符串左侧获取子字符串"
String_DESC4 Line0001 = "String Left(String string, Number numberOfCharacters)\n"
String_DESC4 Line0002 = "此函数从指定字符数的字符串的左侧检索子字符串。\n"
String_DESC4 Line0003 = "参数 1：一个字符串。\n"
String_DESC4 Line0004 = "参数 2：从字符串左侧返回的字符数。如果这个数字更大 "
String_DESC4 Line0005 = "超过可用字符数，函数返回整个字符串。\n"
String_DESC4 Line0006 = "返回：一个字符串，它包含从原始左侧算起指定数量的字符"
String_DESC4 Line0007 = "字符串。"
String_SYM5 = "Len()"
String_OP5 = "获取字符串中的字符数"
String_DESC5 Line0001 = "Number Len(String string)\n"
String_DESC5 Line0002 = "返回：字符串中的字符数。\n"




String_SYM6 = "LocalizedDecimalPoint()"
String_OP6 = "返回本地化的小数点字符"
String_DESC6 Line0001 = "String LocalizedDecimalPoint(Number decimalPointOption = 1)\n"
String_DESC6 Line0002 = "此函数返回本地化小数点的值。\n"
String_DESC6 Line0003 = "参数 1：可选数字，指定函数如何确定要使用哪个字符"
String_DESC6 Line0004 = "本地化小数点。有效值为：\n"
String_DESC6 Line0005 = " 1 -（默认）使用 Station Options 本地化首选项来确定是否使用操作 "
String_DESC6 Line0006 = "系统设置。\n"
String_DESC6 Line0007 = " 2 - 使用操作系统设置。\n"
String_DESC6 Line0008 = " 3 - 使用句点字符。\n"
String_DESC6 Line0009 = " 4 - 使用逗号。\n"
String_DESC6 Line0010 = "返回：包含本地化小数点字符的字符串。"
String_SYM7 = "LocalizeExpression()"
String_OP7 = "本地化表达式字符串"
String_DESC7 Line0001 = "String LocalizeExpression(String expressionString, Number decimalPointOption = 1)\n"
String_DESC7 Line0002 = "此函数转换表达式字符串以符合计算机的本地化设置。"
String_DESC7 Line0003 = "在显示之前调用此函数以本地化表达式。该函数替换句点"
String_DESC7 Line0004 = "用本地化的小数点字符表示表达式中的小数点。如果本地化"
String_DESC7 Line0005 = "小数点字符为逗号字符，函数也替换代表参数的逗号"
String_DESC7 Line0006 = "或带分号的表达式分隔符。该函数不更改用作属性字段的句点"
String_DESC7 Line0007 = "分隔符或字符串常量内的任何字符。\n"
String_DESC7 Line0008 = "参数 1：要转换的非本地化表达式字符串。\n"
String_DESC7 Line0009 = "参数 2：一个可选数字，指定函数如何确定哪个字符是本地化的"
String_DESC7 Line0010 = "用于本地化表达式的小数点。有效值为：\n"

String_DESC7 Line0011 = " 1 - (default) 使用 Station Options 本地化首选项来确定是否使用操作 "
String_DESC7 Line0012 = "系统设置。\n"
String_DESC7 Line0013 = " 2 - 使用操作系统设置。\n"
String_DESC7 Line0014 = " 3 - 使用句点字符。\n"
String_DESC7 Line0015 = " 4 - 使用逗号。\n"
String_DESC7 Line0016 = "返回：包含本地化表达式的字符串。"
String_SYM8 = "Mid()"
String_OP8 = "从字符串中间获取子字符串"
String_DESC8 Line0001 = "String Mid(String string, Number startIndex, [Number numberOfCharacters])\n"
String_DESC8 Line0002 = "此函数从指定索引处开始的字符串中检索子字符串。\n"
String_DESC8 Line0003 = "参数 1：一个字符串。\n"
String_DESC8 Line0004 = "参数 2：一个数字，指定要检索的子字符串的从零开始的索引。\n"
String_DESC8 Line0005 = "参数 3：可选数字，指定要检索的字符数。如果省略此参数 "
String_DESC8 Line0006 = "或者传递一个大于起始索引之外的字符串字符数的值，函数"
String_DESC8 Line0007 = "返回从起始索引到字符串结尾的所有字符。\n"
String_DESC8 Line0008 = "返回：一个包含原始字符串中指定字符的新字符串。"
String_SYM9 = "Replace()"
String_OP9 = "替换字符串中的子字符串"
String_DESC9 Line0001 = "Number Replace(String string, Number startIndex, Number numCharsToReplace, String replacementString)\n"
String_DESC9 Line0002 = "此函数用替换字符串替换指定索引处给定数量的字符。"
String_DESC9 Line0003 = "如果您为字符串参数传递一个属性，该函数将更新该属性的内容。\n"
String_DESC9 Line0004 = "参数 1：要替换指定字符的字符串。\n"
String_DESC9 Line0005 = "参数 2：要替换的第一个字符的从零开始的索引。\n"
String_DESC9 Line0006 = "参数 3：要替换的字符数。\n"
String_DESC9 Line0007 = "参数 4：要插入的字符串以代替指定的字符。\n"
String_DESC9 Line0008 = "返回：此函数始终返回 0。\n"
String_SYM10 = "ResStr()"
String_OP10 = "从字符串资源文件中获取字符串"
String_DESC10 Line0001 = "String ResStr(String category, String tag, [String defaultString], [Out] [Boolean found])\n"
String_DESC10 Line0002 = "此函数从语言资源文件中检索字符串。此函数的替代名称 "
String_DESC10 Line0003 = "是 GetResourceString()。\n"
String_DESC10 Line0004 = "参数 1：一个字符串，指定要检索的字符串的类别名称。\n"
String_DESC10 Line0005 = "参数 2：一个字符串，指定要检索的字符串的标签名称。\n"
String_DESC10 Line0006 = "参数 3：一个可选字符串，指定在未找到您请求的字符串时的返回值。\n"
String_DESC10 Line0007 = "参数 4：一个可选的输出值，指示是否找到了字符串。\n"
String_DESC10 Line0008 = "返回：您从语言资源文件请求的字符串。"
String_SYM11 = "Right()"
String_OP11 = "从字符串右侧获取子字符串"
String_DESC11 Line0001 = "String Right(String string, Number numberOfCharacters)\n"
String_DESC11 Line0002 = "此函数从指定字符数的字符串右侧检索子字符串。\n"
String_DESC11 Line0003 = "参数 1：一个字符串。\n"
String_DESC11 Line0004 = "参数2：从字符串右边开始返回的字符数。如果这个数字是"
String_DESC11 Line0005 = "大于可用字符数，函数返回整个字符串。\n"
String_DESC11 Line0006 = "返回：一个字符串，它包含从原始右侧算起的指定数量的字符"
String_DESC11 Line0007 = "字符串。"
String_SYM12 = "SearchAndReplace()"
String_OP12 = "搜索并替换字符串中的一个或多个子字符串"
String_DESC12 Line0001 = "String SearchAndReplace(String string, String searchString, String replacementString, Number startIndex "
String_DESC12 Line0002 = "= 0, Boolean ignoreCase = False, Number maxReplacements = -1, Boolean searchInReverse = False, [Out] "
String_DESC12 Line0003 = "[Number numReplacements])\n"
String_DESC12 Line0004 = "此函数搜索并用替换字符串替换一个或多个子字符串。如果您通过 "
String_DESC12 Line0005 = "字符串参数的属性，函数更新属性的内容。\n"
String_DESC12 Line0006 = "参数 1：要在其中执行子字符串替换的字符串。\n"
String_DESC12 Line0007 = "参数 2：要查找然后替换为替换字符串的子字符串。\n"
String_DESC12 Line0008 = "参数 3：替换字符串。\n"
String_DESC12 Line0009 = "参数 4：可选数字，指定从零开始搜索的字符索引。"
String_DESC12 Line0010 = "默认为 0。\n"
String_DESC12 Line0011 = "参数5：可选布尔值，指定搜索时是否忽略字符大小写。"
String_DESC12 Line0012 = "默认为假。\n"
String_DESC12 Line0013 = "参数 6：可选数字，指定要替换的子字符串的最大出现次数。"
String_DESC12 Line0014 = "值 -1 表示函数替换所有出现的子字符串。默认值为 -1。\n"
String_DESC12 Line0015 = "参数7：可选布尔值，指定是否反向搜索字符串。默认"
String_DESC12 Line0016 = "为False，如果传True，传给参数3的起始索引指定从零开始的索引"
String_DESC12 Line0017 = "开始反向搜索的字符的字符串末尾。\n"
String_DESC12 Line0018 = "参数 8：一个可选的数字，函数在其中存储它替换的子字符串的数量。\n"
String_DESC12 Line0019 = "返回：修改后的字符串。\n"
String_SYM13 = "Str()"
String_OP13 = "将属性值格式化为字符串"
String_DESC13 Line0001 = "String Str(AnyType value, [String formatString], Number decimalPointOption = 1, Boolean useValueFormatIfDefined "
String_DESC13 Line0002 = "= False, [字符串分隔符])\n"
String_DESC13 Line0003 = "此函数将属性值格式化为字符串。\n"
String_DESC13 Line0004 = "参数 1：要格式化的属性。\n"
String_DESC13 Line0005 = "参数 2：可选字符串，指定 C (printf) 样式格式字符串以控制转换。"
String_DESC13 Line0006 = "数值的默认值是 \"%$.13g\"。\n"
String_DESC13 Line0007 = "参数 3：可选数字，指定函数如何确定将哪个字符用作 "
String_DESC13 Line0008 = "本地化小数点。有效值为：\n"
String_DESC13 Line0009 = " 1 - (default) 使用 Station Options 本地化首选项来确定是否使用操作 "
String_DESC13 Line0010 = "系统设置。\n"
String_DESC13 Line0011 = " 2 - 使用操作系统设置。\n"
String_DESC13 Line0012 = " 3 - 使用句点字符。\n"
String_DESC13 Line0013 = " 4 - 使用逗号。\n"
String_DESC13 Line0014 = "参数 4：一个可选的布尔值，指定函数是否使用的固有格式"
String_DESC13 Line0015 = "第一个参数，如果参数值具有非默认数字显示格式。默认为 false。"
String_DESC13 Line0016 = "如果您传递 true 并且值参数具有非默认格式，则该函数使用值格式"
String_DESC13 Line0017 = "而不是你传递给参数 2 的格式。\n"
String_DESC13 Line0018 = "参数 5：可选字符串，用于分隔数组元素的串联字符串中的每个元素"
String_DESC13 Line0019 = "当第一个参数是数组时函数返回。\n"
String_DESC13 Line0020 = "返回：属性值的字符串表示。\n"
String_DESC13 Line0021 = "注意：在格式字符串中的 % 字符后放置一个 $ 字符以删除后面的尾随零"
String_DESC13 Line0022 = "小数点。\n"
String_DESC13 Line0023 = "注意：如果你为参数 2 传递一个\"%s\"风格的格式说明符，第一个参数必须是一个字符串"
String_DESC13 Line0024 = "而不是数字。这允许您格式化字符串和数字。例如：Str(\"Right justified\", "
String_DESC13 Line0025 = "\"%40s\") 计算结果为：\n"
String_DESC13 Line0026 = " \" 右对齐\"\n"
String_DESC13 Line0027 = "注意：如果将数组值传递给参数一，函数将返回一个由串联的字符串组成的字符串"
String_DESC13 Line0028 = "数组元素的值。\n"
String_DESC13 Line0029 = "注意：使用格式代码 %b 来格式化二进制数。\n"
String_DESC13 Line0030 = "注意：使用格式代码%expr来格式化显示的表达式。表达式必须是本地化的"

String_DESC13 Line0031 = "表达式。为参数 3 指定以下值的组合以控制表达式如何"
String_DESC13 Line0032 = "格式化：\n"
String_DESC13 Line0033 = " 0x1 - 将前置条件式表达式格式化为更简单的格式。\n"
String_DESC13 Line0034 = " 0x2 - 为使用唯一步骤 ID 的表达式插入步骤名称注释。\n"
String_DESC13 Line0035 = " 0x4 - 在表达式中使用 RunState.Sequence.<StepGroup>[\"step\"] 的简写。\n"
String_DESC13 Line0036 = " 0x8 - 用步骤名称替换唯一的步骤 ID。\n"

String_SYM14 = "StrComp()"
String_OP14 = "比较字符串"
String_DESC14 Line0001 = "Number StrComp(String stringA, String stringB, Number compareOption = 0, Number maxChars = -1)\n"
String_DESC14 Line0002 = "这个函数比较两个字符串。\n"
String_DESC14 Line0003 = "参数 1：要比较的第一个字符串。\n"
String_DESC14 Line0004 = "参数 2：要比较的第二个字符串。\n"
String_DESC14 Line0005 = "参数 3：一个可选数字，指定如何比较字符串。传递 0 表示区分大小写 "
String_DESC14 Line0006 = "比较（这是默认值）。传递 1 进行不区分大小写的比较。\n"
String_DESC14 Line0007 = "参数 4：可选数字，指定要比较的最大字符数。将 -1 传递给 "
String_DESC14 Line0008 = "比较所有字符（这是默认设置）。\n"
String_DESC14 Line0009 = "返回：如果第一个字符串小于第二个字符串，则返回小于 0 的数字。大于 "
String_DESC14 Line0010 = "如果第一个字符串大于第二个字符串则为 0。如果字符串相等则为 0。"
String_SYM15 = "ToLower()"
String_OP15 = "使字符串小写"
String_DESC15 Line0001 = "String ToLower(String string, Number startIndex = 0, Number numCharacters = -1, Boolean reverse = False)\n"
String_DESC15 Line0002 = "此函数将字符串中的字母字符转换为小写字符。\n"
String_DESC15 Line0003 = "参数 1：要转换的字符串。\n"
String_DESC15 Line0004 = "参数 2：（可选）开始转换的从零开始的字符索引。默认值为 0。\n"
String_DESC15 Line0005 = "参数 3：（可选）要转换的字符数。值为 -1 表示要转换的函数 "
String_DESC15 Line0006 = "所有字符。默认为-1。\n"
String_DESC15 Line0007 = "参数 4：（可选）传 True 将字符串反向转换。在这种情况下，起始索引通过 "
String_DESC15 Line0008 = "to 参数 2 指定从字符串末尾开始的从零开始的索引作为要到达的字符"
String_DESC15 Line0009 = "开始反向转换。默认为False。\n"
String_DESC15 Line0010 = "返回：修改后的字符串。\n"
String_SYM16 = "ToUpper()"
String_OP16 = "使字符串大写"
String_DESC16 Line0001 = "String ToUpper(String string, Number startIndex = 0, Number numCharacters = -1, Boolean reverse = False)\n"
String_DESC16 Line0002 = "此函数将字符串中的字母字符转换为大写字符。\n"
String_DESC16 Line0003 = "参数 1：要转换的字符串。\n"
String_DESC16 Line0004 = "参数 2：（可选）开始转换的从零开始的字符索引。默认值为 0。\n"
String_DESC16 Line0005 = "参数 3：（可选）要转换的字符数。值为 -1 表示要转换的函数"
String_DESC16 Line0006 = "所有字符。默认为-1。\n"
String_DESC16 Line0007 = "参数 4：（可选）传 True 将字符串反向转换。在这种情况下，起始索引通过 "
String_DESC16 Line0008 = "to 参数 2 指定从字符串末尾开始的从零开始的索引作为要"
String_DESC16 Line0009 = "开始反向转换。默认为False。\n"
String_DESC16 Line0010 = "返回：修改后的字符串。\n"
String_SYM17 = "CheckStrLimit()"
String_OP17 = "比较字符串"
String_DESC17 Line0001 = "String CheckStrLimit(String stringA, String stringB, String comparisonType, Number maxChars = -1)\n"
String_DESC17 Line0002 = "此函数使用比较法将两个字符串或一个字符串与正则表达式模式进行比较"
String_DESC17 Line0003 = "您指定的类型。\n"
String_DESC17 Line0004 = "参数 1：要比较的第一个字符串。\n"
String_DESC17 Line0005 = "参数 2：要比较的第二个字符串或模式。\n"
String_DESC17 Line0006 = "参数3：一个字符串，指定如何比较字符串。有效值为\"LOG\", \"IgnoreCase\", "
String_DESC17 Line0007 = "\"CaseSensitive\"、\"RegularExpressionIgnoreCase\" 和 \"RegularExpressionCaseSensitive\"。\n"
String_DESC17 Line0008 = "参数 4：（可选）一个数字，指定要比较的最大字符数。传递 -1 "
String_DESC17 Line0009 = "比较所有字符。默认为-1。对于正则表达式情况，它匹配第一个maxChars "
String_DESC17 Line0010 = "给定模式的字符串字符。\n"
String_DESC17 Line0011 = "返回：\"Passed\" 如果比较表明字符串匹配或者比较类型为 \"LOG\"。 "
String_DESC17 Line0012 = "\"否则失败\"。"
String_SYM18 = "Split()"
String_OP18 = "围绕定界符拆分字符串"
String_DESC18 Line0001 = "Array Split(String string, String/Array delimiters)\n"
String_DESC18 Line0002 = "此函数使用指定的分隔符从指定的字符串生成一个字符串数组。\n"
String_DESC18 Line0003 = "参数 1：要拆分的字符串。\n"
String_DESC18 Line0004 = "参数 2：分隔符列表。通过传递一个字符串来指定分隔符，其中每个字符 "
String_DESC18 Line0005 = "该字符串是一个分隔符，或者通过传递一个字符串数组，其中数组中的每个字符串都是"
String_DESC18 Line0006 = "分隔符。\n"
String_DESC18 Line0007 = "返回：包含标记的字符串数组。\n"
String_SYM19 = "Trim()"
String_OP19 = "从字符串中删除所有前导和尾随空格"
String_DESC19 Line0001 = "String Trim(String untrimmedString, [String charsToTrim])\n"
String_DESC19 Line0002 = "此函数从字符串中删除所有前导和尾随空格或指定字符。\n"
String_DESC19 Line0003 = "参数 1：要修剪的字符串。\n"
String_DESC19 Line0004 = "参数 2：（可选）传递一个包含要删除的特定字符的字符串，而不是空格。\n"
String_DESC19 Line0005 = "返回：修剪后的字符串。\n"
String_SYM20 = "TrimStart()"
String_OP20 = "从字符串中删除所有前导空格或指定字符。"
String_DESC20 Line0001 = "String TrimStart(String untrimmedString, [String charsToTrim])\n"
String_DESC20 Line0002 = "此函数从字符串中删除所有前导空格或指定字符。\n"
String_DESC20 Line0003 = "参数 1：要修剪的字符串。\n"
String_DESC20 Line0004 = "参数 2：（可选）传递一个包含要删除的特定字符的字符串，而不是空格。\n"
String_DESC20 Line0005 = "返回：修剪后的字符串。\n"
String_SYM21 = "TrimEnd()"
String_OP21 = "从字符串中删除所有尾随空格或指定字符。"
String_DESC21 Line0001 = "String TrimEnd(String untrimmedString, [String charsToTrim])\n"
String_DESC21 Line0002 = "此函数从字符串中删除所有尾随空格或指定字符。\n"
String_DESC21 Line0003 = "参数 1：要修剪的字符串。\n"
String_DESC21 Line0004 = "参数 2：（可选）传递一个包含要删除的特定字符的字符串，而不是空格。\n"
String_DESC21 Line0005 = "返回：修剪后的字符串。\n"
String_SYM22 = "MatchPattern()"
String_OP22 = "检查字符串是否匹配正则表达式。"
String_DESC22 Line0001 = "Boolean MatchPattern(String string, String stringPatternToMatchFor, [Boolean ignoreCase = False], [Out] "
String_DESC22 Line0002 = "[字符串子模式数组])\n"
String_DESC22 Line0003 = "此函数检查字符串是否匹配正则表达式模式。\n"
String_DESC22 Line0004 = "参数 1：要与模式进行比较的字符串。\n"
String_DESC22 Line0005 = "参数 2：要匹配的正则表达式模式。\n"
String_DESC22 Line0006 = "参数3：（可选）布尔值，指定搜索时是否忽略字符大小写。"
String_DESC22 Line0007 = "默认为假。\n"
String_DESC22 Line0008 = "参数 4：（可选）函数存储子模式的空字符串数组。\n"
String_DESC22 Line0009 = "返回：如果字符串与模式匹配则返回真。否则返回假。"
String_SYM23 = "FindPattern()"
String_OP23 = "搜索与正则表达式匹配的子字符串。"
String_DESC23 Line0001 = "Number FindPattern(String string, String stringPatternToSearchFor, [Number indexToSearchFrom = 0], [Boolean "
String_DESC23 Line0002 = "ignoreCase = False], [Out] [Number patternLength])\n"
String_DESC23 Line0003 = "此函数搜索与正则表达式模式匹配的子字符串。\n"
String_DESC23 Line0004 = "参数 1：要与模式进行比较的字符串。\n"
String_DESC23 Line0005 = "参数 2：要搜索的正则表达式模式。\n"
String_DESC23 Line0006 = "参数 3：（可选）一个数字，指定从零开始搜索的字符索引。"
String_DESC23 Line0007 = "默认为 0。\n"
String_DESC23 Line0008 = "参数4：（可选）布尔值，指定搜索时是否忽略字符大小写。"
String_DESC23 Line0009 = "默认为 False。\n"
String_DESC23 Line0010 = "参数 5：（可选）表示与模式匹配的子串长度的数字。\n"
String_DESC23 Line0011 = "返回：包含与模式匹配的第一个子字符串的起始索引的数字。如果 "，则返回 -1
String_DESC23 Line0012 = "未找到模式。"
String_SYM24 = "SearchPatternAndReplace()"
String_OP24 = "在与正则表达式匹配的字符串中搜索并替换一个或多个子字符串。"
String_DESC24 Line0001 = "String SearchPatternAndReplace(String string, String searchPattern, String replacementString, [Number "
String_DESC24 Line0002 = "startIndex = 0], [Boolean ignoreCase = False], [Number maxReplacements = -1], [Out] [Number numReplacements])\n"
String_DESC24 Line0003 = "此函数搜索并替换一个或多个与正则表达式模式匹配的子字符串。\n"
String_DESC24 Line0004 = "参数 1：执行子字符串替换的字符串。\n"
String_DESC24 Line0005 = "参数 2：要查找并替换为替换字符串的正则表达式模式。\n"
String_DESC24 Line0006 = "参数 3：替换字符串。\n"
String_DESC24 Line0007 = "参数 4：（可选）一个数字，指定从零开始搜索的字符索引。"
String_DESC24 Line0008 = "默认为 0。\n"
String_DESC24 Line0009 = "参数5：（可选）布尔值，指定搜索时是否忽略字符大小写。"
String_DESC24 Line0010 = "默认为假。\n"
String_DESC24 Line0011 = "参数6：（可选）一个数字，指定子字符串出现的最大次数"
String_DESC24 Line0012 = "替换。值为 -1 表示函数替换所有出现的子字符串。默认 "
String_DESC24 Line0013 = "是-1。\n"
String_DESC24 Line0014 = "参数7：（可选）替换次数。\n"
String_DESC24 Line0015 = "返回：修改后的字符串。"

Time_SYM1 = "Date()"
Time_OP1 = "获取当前日期"
Time_DESC1 Line0001 = "String Date(Boolean longFormat = False, [Out] [Number year], [Out] [Number month], [Out] [Number monthDay], "
Time_DESC1 Line0002 = "[Out] [Number weekDay], [Number timeStampInSeconds], [Boolean baseTimeIsInitTime])\n"
Time_DESC1 Line0003 = "此函数返回当前日期。\n"
Time_DESC1 Line0004 = "参数 1：（可选）传递 True 以返回长格式的日期（默认为 False）。\n"
Time_DESC1 Line0005 = "参数 2：（可选输出）包含当前年份。\n"
Time_DESC1 Line0006 = "参数 3：（可选输出）当前月份（从 1 到 12）。\n"
Time_DESC1 Line0007 = "参数 4：（可选输出）一个月中的第几天（从 1 到 31）。\n"
Time_DESC1 Line0008 = "参数 5：（可选输出）星期几（从 1（星期日）到 7（星期六））。\n"
Time_DESC1 Line0009 = "参数 6：（可选）函数用来代替当前时间的时间戳。传递一个时间值"
Time_DESC1 Line0010 = "你从表达式函数 Seconds() 中获得。\n"
Time_DESC1 Line0011 = "参数 7：（可选）指定您传递给参数 6 的时间戳的基准时间。传递 True "
Time_DESC1 Line0012 = "如果基准时间是应用程序初始化 TestStand 引擎的时间。如果 "
Time_DESC1 Line0013 = "基准时间为 1970 年 1 月 1 日午夜，通用协调时间 (UTC)。UTC 也称为格林威治时间"
Time_DESC1 Line0014 = "平均时间 (GMT)。\n"
Time_DESC1 Line0015 = "返回：包含本地化格式的当前日期的字符串。"
Time_SYM2 = "Seconds()"
Time_OP2 = "获取经过的秒数"
Time_DESC2 Line0001 = "Number Seconds(Boolean returnSecondsSinceStartup = True)\n"
Time_DESC2 Line0002 = "此函数返回自初始基准时间以来经过的秒数。\n"
Time_DESC2 Line0003 = "注意：在某些情况下，TestStand Seconds(True) 函数返回不正确的经过时间值 "
Time_DESC2 Line0004 = "当操作系统定时器运行速度比实际时间慢时。访问 ni.com/info 并输入信息 "
Time_DESC2 Line0005 = "代码 tstime 以获得关于此问题的更多信息。\n"
Time_DESC2 Line0006 = "参数 1：（可选）指定函数确定当前时间的基准时间"
Time_DESC2 Line0007 = "秒。如果传默认参数True或不传参数，函数返回"
Time_DESC2 Line0008 = "自应用程序初始化 TestStand Engine 以来的秒数。此选项提供 "
Time_DESC2 Line0009 = "最高分辨率的时间数字表示。时间分辨率通常为一毫秒 "
Time_DESC2 Line0010 = "或更小，可以小到cpu时钟间隔。如果传False，函数返回"
Time_DESC2 Line0011 = "自 1970 年 1 月 1 日午夜以来经过的秒数，通用协调时间 (UTC)。UTC 也是 "
Time_DESC2 Line0012 = "称为格林威治标准时间 (GMT)。此选项提供了一个绝对时间，您可以将其与时间进行比较"
Time_DESC2 Line0013 = "您在其他应用程序会话或其他计算机上录制。时间分辨率不小于"
Time_DESC2 Line0014 = "一毫秒。"
Time_SYM3 = "时间()"
Time_OP3 = "获取当前时间"
Time_DESC3 Line0001 = "String Time(Boolean force24HourFormat = False, [Out] [Number hours], [Out] [Number minutes], [Out] [Number "
Time_DESC3 Line0002 = "seconds", [Out] [Number milliseconds], [Number timeStampInSeconds], [Boolean baseTimeIsInitTime])\n"
Time_DESC3 Line0003 = "这个函数返回当前时间。\n"
Time_DESC3 Line0004 = "参数 1：一个可选的布尔值，指定函数是否返回 24 小时制的时间字符串"
Time_DESC3 Line0005 = "格式（默认为假）。\n"
Time_DESC3 Line0006 = "参数 2：可选数字，返回自午夜以来的小时数（从 0 到 23）。\n"
Time_DESC3 Line0007 = "参数 3：可选数字，返回小时后的分钟数（从 0 到 59）。\n"
Time_DESC3 Line0008 = "参数 4：一个可选数字，返回分钟后的秒数（从 0 到 59）。\n"
Time_DESC3 Line0009 = "参数 5：可选数字，返回秒后的毫秒数（从 0 到 999）。\n"
Time_DESC3 Line0010 = "参数 6：可选数字，指定函数使用的时间戳来代替当前时间"
Time_DESC3 Line0011 = "时间。传递您从表达式函数 Seconds() 获得的时间值。\n"
Time_DESC3 Line0012 = "参数 7：一个可选的布尔值，指定传递给参数的时间戳的基准时间"
Time_DESC3 Line0013 = "6. 如果基准时间是应用程序初始化 TestStand 引擎的时间，则传递 True。"
Time_DESC3 Line0014 = "如果基准时间是 1970 年 1 月 1 日午夜，通用协调时间 (UTC)，则传递 False。UTC 也是 "
Time_DESC3 Line0015 = "称为格林威治标准时间 (GMT)。\n"
Time_DESC3 Line0016 = "返回：包含本地化格式的当前时间的字符串。"


Switching_SYM1 = "SwitchConnect()"
Switching_OP1 = "连接指定交换路径的路径"
Switching_DESC1 Line0001 = "SwitchConnect(String device, String connectRoutes, Number multiConnectMode = 1, Number lifetime = 4, "
Switching_DESC1 Line0002 = "Boolean waitForDebounce = True)\n"
Switching_DESC1 Line0003 = "此函数连接 National Instruments 中定义的设备中指定路由的路径 "
Switching_DESC1 Line0004 = "切换执行。\n"
Switching_DESC1 Line0005 = "参数 1：执行切换操作的虚拟设备。\n"
Switching_DESC1 Line0006 = "参数 2：您正在连接的路由。表达式必须是有效的路由规范字符串 "

Switching_DESC1 Line0007 = "为您定义的由National Instruments Switch Executive 配置的虚拟设备名称"
Switching_DESC1 Line0008 = "正在使用。该字符串可以是路由组别名、路由名称和物理路由的组合"
Switching_DESC1 Line0009 = "paths. Example: 'MyRouteGroup & MyRoute & [Dev1/CH3->CH4,CH4->R0]'\n"
Switching_DESC1 Line0010 = "参数 3：（可选）定义发生多个连接操作时的行为的值 "

Switching_DESC1 Line0011 = "在特定路线上。	有效值为：\n"
Switching_DESC1 Line0012 = " 	0 - 无多重连接：一条路线只能连接一次。任何试图重新连接已经存在的路线的尝试

Switching_DESC1 Line0013 = "连接导致错误。\n"
Switching_DESC1 Line0014 = " 	1 - Multiconnect Routes (default): 一个路由可以连接多次。路由必须包含 "

Switching_DESC1 Line0015 = "相同的端点和路径。National Instruments Switch Executive 自动参考路由计数。"

Switching_DESC1 Line0016 = "如果您对特定路由发出多个连接操作，则该路由不会在物理上断开连接"

Switching_DESC1 Line0017 = "直到发生相同数量的断开连接操作。您可以手动发出断开连接操作"

Switching_DESC1 Line0018 = "或者使用路由的生命周期设置。DisconnectAll 函数断开路由，即使路由"
Switching_DESC1 Line0019 = "引用计数大于一。\n"
Switching_DESC1 Line0020 = " 	-1 - Use Default Setting for Routes：使用 Switch Executive 中为路由定义的设置。（仅 "

Switching_DESC1 Line0021 = "Switch Executive 2.0 或更高版本支持。）\n"
Switching_DESC1 Line0022 = "参数 4：（可选）指定 TestStand 应用于指定路由的生命周期的值 "

Switching_DESC1 Line0023 = "用于连接操作。您可以指定是否希望路由存在直到手动断开连接"

Switching_DESC1 Line0024 = "later, or until the sequence, thread, or execution completes. 如果你使用多连接模式，路由"
Switching_DESC1 Line0025 = "如果另一个步骤为同一路由指定了自己的生命周期，则可以存在更长时间。选择生命周期"

Switching_DESC1 Line0026 = "除非手动保证路由保持连接，只要步骤、序列、线程或"
Switching_DESC1 Line0027 = "您连接的执行仍在执行。如果您手动断开之前的路由"

Switching_DESC1 Line0028 = "使用非手动生命周期设置连接，TestStand 释放对路由的引用"
Switching_DESC1 Line0029 = "为该路由执行连接操作的最后一步。\n"

Switching_DESC1 Line0030 = "	有效值为：\n"
Switching_DESC1 Line0031 = " 	0 - 手动\n"
Switching_DESC1 Line0032 = " 	1 - 执行\n"
Switching_DESC1 Line0033 = " 	2 - 线程\n"
Switching_DESC1 Line0034 = " 	3 - 序列\n"
Switching_DESC1 Line0035 = " 	4 - 步骤（默认）\n"
Switching_DESC1 Line0036 = "参数5：（可选）指定操作是否等待所有开关去抖后再返回"

Switching_DESC1 Line0037 = "to TestStand。等待去抖发生在连接操作完成后。默认值为"
Switching_DESC1 Line0038 = "真。\n"
Switching_DESC1 Line0039 = "返回：此函数始终返回 0。"

Switching_SYM2 = "SwitchConnectDisconnect()"
Switching_OP2 = "连接和断开指定交换路径的路径"
Switching_DESC2 Line0001 = "SwitchConnectDisconnect（字符串设备，字符串连接路由，字符串断开连接路由，数字多连接模式"
Switching_DESC2 Line0002 = "= 1, Number operationOrder = 1, Number lifetime = 4, Boolean waitForDebounce = True)\n"
Switching_DESC2 Line0003 = "此函数为国家定义的设备中的指定路由连接和断开路径"
Switching_DESC2 Line0004 = "仪器开关执行器。\n"
Switching_DESC2 Line0005 = "参数 1：执行切换操作的虚拟设备。\n"
Switching_DESC2 Line0006 = "参数 2：您正在连接的路由。表达式必须是有效的路由规范字符串 "

Switching_DESC2 Line0007 = "为您定义的由National Instruments Switch Executive配置的虚拟设备名称"
Switching_DESC2 Line0008 = "正在使用。该字符串可以是路由组别名、路由名称和物理路由的组合"
Switching_DESC2 Line0009 = "路径。示例：'MyRouteGroup & MyRoute & [Dev1/CH3->CH4,CH4->R0]'\n"
Switching_DESC2 Line0010 = "参数 3：要断开的路由。表达式必须是有效的路由规范字符串 "

Switching_DESC2 Line0011 = "为您定义的由National Instruments Switch Executive 配置的虚拟设备名称"
Switching_DESC2 Line0012 = "正在使用。\n"

Switching_DESC2 Line0013 = "参数 4：（可选）定义发生多个连接操作时的行为的值 "
Switching_DESC2 Line0014 = "在特定路线上。	有效值为：\n"

Switching_DESC2 Line0015 = " 	0 - 无多重连接：一条路线只能连接一次。任何试图重新连接已经存在的路线的尝试

Switching_DESC2 Line0016 = "连接导致错误。\n"
Switching_DESC2 Line0017 = " 	1 - Multiconnect Routes (default): 一个路由可以连接多次。路由必须包含 "

Switching_DESC2 Line0018 = "相同的端点和路径。National Instruments Switch Executive 自动参考路由计数。"

Switching_DESC2 Line0019 = "如果您为特定路由发出多个连接操作，则该路由不会在物理上断开连接"

Switching_DESC2 Line0020 = "直到发生相同数量的断开连接操作。您可以手动发出断开连接操作"

Switching_DESC2 Line0021 = "或者使用路由的生命周期设置。DisconnectAll 函数断开路由，即使路由"
Switching_DESC2 Line0022 = "引用计数大于一。\n"
Switching_DESC2 Line0023 = " 	-1 - 使用默认路由设置：使用 Switch Executive 中为路由定义的设置。（仅 "

Switching_DESC2 Line0024 = "Switch Executive 2.0 或更高版本支持。）\n"
Switching_DESC2 Line0025 = "参数 5：（可选）指定 Disconnect 操作发生在 Connect 之前还是之后 "

Switching_DESC2 Line0026 = "操作。有效值为：\n"
Switching_DESC2 Line0027 = " 	1 - Disconnect Before Connect（默认）：在连接任何路由之前断开指定路由。"
Switching_DESC2 Line0028 = "这是典型的操作模式。\n"

Switching_DESC2 Line0029 = " 	2 - Connect Before Disconnect: 在断开任何路由之前连接指定的路由。使用这个 "

Switching_DESC2 Line0030 = "切换电流并希望确保始终连接负载时的操作模式"
Switching_DESC2 Line0031 = "到你的来源。\n"
Switching_DESC2 Line0032 = "参数 6：（可选）指定 TestStand 应用于指定路由的生命周期的值 "

Switching_DESC2 Line0033 = "用于连接操作。您可以指定是否希望路由存在直到手动断开连接"

Switching_DESC2 Line0034 = "稍后，或直到序列、线程或执行完成。如果您使用多连接模式，路由"
Switching_DESC2 Line0035 = "如果另一个步骤为同一路由指定了自己的生命周期，则可以存在更长时间。选择生命周期"

Switching_DESC2 Line0036 = "除了手动保证路由保持连接外，只要步骤、序列、线程或"
Switching_DESC2 Line0037 = "您连接的执行仍在执行。如果您手动断开之前的路由"

Switching_DESC2 Line0038 = "使用非手动生命周期设置连接，TestStand 释放对路由的引用"
Switching_DESC2 Line0039 = "为该路由执行连接操作的最后一步。有效值为：\n"


Switching_DESC2 Line0040 = " 	0 - 手动\n"
Switching_DESC2 Line0041 = " 	1 - 执行\n"
Switching_DESC2 Line0042 = " 	2 - 线程\n"
Switching_DESC2 Line0043 = " 	3 - 序列\n"
Switching_DESC2 Line0044 = " 	4 - 步骤（默认）\n"
Switching_DESC2 Line0045 = "参数7：（可选）指定操作是否等待所有开关去抖后再返回"

Switching_DESC2 Line0046 = "到 TestStand。等待去抖发生在连接和断开操作完成之后。"
Switching_DESC2 Line0047 = "默认值为真。\n"
Switching_DESC2 Line0048 = "返回：此函数始终返回 0。"

Switching_SYM3 = "SwitchDisconnect()"
Switching_OP3 = "断开指定路由的路径"
Switching_DESC3 Line0001 = "SwitchDisconnect(String device, String disconnectRoutes, Boolean waitForDebounce = True)\n"
Switching_DESC3 Line0002 = "此函数断开 National Instruments 中定义的设备中指定路由的路径 "
Switching_DESC3 Line0003 = "切换执行。\n"
Switching_DESC3 Line0004 = "参数 1：执行切换操作的虚拟设备。\n"
Switching_DESC3 Line0005 = "参数 2：您要断开的路由。表达式必须是有效的路由规范字符串 "

Switching_DESC3 Line0006 = "为您定义的由National Instruments Switch Executive 配置的虚拟设备名称"
Switching_DESC3 Line0007 = "正在使用。该字符串可以是路由组别名、路由名称和物理路由的组合"
Switching_DESC3 Line0008 = "路径。示例：'MyRouteGroup & MyRoute & [Dev1/CH3->CH4,CH4->R0]'\n"
Switching_DESC3 Line0009 = "参数3：（可选）指定操作是否等待所有开关去抖后再返回"

Switching_DESC3 Line0010 = "to TestStand。等待去抖发生在断开操作完成后。默认值"
Switching_DESC3 Line0011 = "为真。\n"
Switching_DESC3 Line0012 = "返回：此函数始终返回 0。"

Switching_SYM4 = "SwitchDisconnectAll()"
Switching_OP4 = "为指定设备断开 SwitchExecutive 中的所有路由"
Switching_DESC4 Line0001 = "SwitchDisconnectAll(String device, Boolean waitForDebounce = True)\n"
Switching_DESC4 Line0002 = "此函数断开在 National Instruments Switch Executive 中定义的设备中的所有路径。\n"
Switching_DESC4 Line0003 = "参数 1：执行切换操作的虚拟设备。\n"
Switching_DESC4 Line0004 = "参数 2：一个可选的布尔值，指定操作是否等待所有开关去抖"

Switching_DESC4 Line0005 = "在返回 TestStand 之前。等待去抖发生在断开操作完成之后。"
Switching_DESC4 Line0006 = "默认值为真。\n"
Switching_DESC4 Line0007 = "返回：此函数始终返回 0。"

Switching_SYM5 = "SwitchFindRoute()"
Switching_OP5 = "找到两个切换通道之间的现有或潜在路径"
Switching_DESC5 Line0001 = "String SwitchFindRoute(String device, String channel1, String channel2, Boolean raiseError = True, [Out] "
Switching_DESC5 Line0002 = "[号码能力])\n"
Switching_DESC5 Line0003 = "此函数在定义的设备中的两个通道之间找到现有的或潜在的路由"
Switching_DESC5 Line0004 = "National Instruments 开关执行器。\n"
Switching_DESC5 Line0005 = "参数 1：执行切换操作的虚拟设备。\n"
Switching_DESC5 Line0006 = "参数 2：要查找的路由端点之一的通道名称。通道名称必须是"

Switching_DESC5 Line0007 = "是通道别名或由 Switch Executive 定义的 Device/IviChannel 语法中的名称。示例："
Switching_DESC5 Line0008 = "'Dev1/CH2'\n"
Switching_DESC5 Line0009 = "参数 3：要查找的路由端点之一的通道名称。通道名称必须是"

Switching_DESC5 Line0010 = "是通道别名或由 Switch Executive 定义的 Device/IviChannel 语法中的名称。示例："
Switching_DESC5 Line0011 = "'Dev1/CH3'\n"
Switching_DESC5 Line0012 = "参数 4：一个可选的布尔值，指定如果路由不可用，函数是否出错 "
Switching_DESC5 Line0013 = "或不存在。默认值为真。\n"
Switching_DESC5 Line0014 = "参数 5：一个可选的输出数字，表示在之间找到有效路由的能力"
Switching_DESC5 Line0015 = "两个通道。\n"
Switching_DESC5 Line0016 = "有效的返回值是：\n"
Switching_DESC5 Line0017 = " 	1 - 路径可用\n"
Switching_DESC5 Line0018 = " 	2 - 路径已经存在，没有可能的路径\n"
Switching_DESC5 Line0019 = " 	3 - 路径不受支持，没有可能的路径\n"
Switching_DESC5 Line0020 = " 	4 - 路径可能但所需资源正在使用中，没有可能的路径\n"
Switching_DESC5 Line0021 = " 	5 - 两个通道都是源，没有路由可能\n"
Switching_DESC5 Line0022 = " 	6 - 通道不能是端点，不可能有路由\n"
Switching_DESC5 Line0023 = "返回：此函数返回可用或已经存在的路由字符串。"


2Other_SYM1 = "AllOf()"
2Other_OP1 = "Logical And with unlimited parameters"
2Other_DESC1 Line0001 = "Boolean AllOf(Boolean parameter1, Boolean parameter2, Boolean paramete3, etc.)\n"
2Other_DESC1 Line0002 = "返回：任意数量的布尔参数的逻辑与。此函数使用短路评估，"
2Other_DESC1 Line0003 = "即如果函数遇到False参数，函数会立即返回False而不求值"
2Other_DESC1 Line0004 = "其余参数。"


2Other_SYM2 = "AnyOf()"
2Other_OP2 = "无限制参数的逻辑或"
2Other_DESC2 Line0001 = "Boolean AnyOf(Boolean parameter1, Boolean parameter2, Boolean parameter3, etc.)\n"
2Other_DESC2 Line0002 = "返回：所有参数的逻辑或。此函数使用短路评估，即如果 "
2Other_DESC2 Line0003 = "函数遇到一个True参数，函数立即返回True而不评估剩余"
2Other_DESC2 Line0004 = "参数。"


2Other_SYM3 = "CheckLimits()"
2Other_OP3 = "将一个值与一组限制进行比较"
2Other_DESC3 Line0001 = "String CheckLimits(Number value, Number high, Number low, String comparisonType, Boolean doNotCopyToResults = True, Number nominal = 0, String thresholdType = \"PERCENTAGE\")\n"
2Other_DESC3 Line0002 = "此函数评估一个值是否在指定范围内\n"
2Other_DESC3 Line0003 = "参数 1：要与限制进行比较的数字。\n"
2Other_DESC3 Line0004 = "参数 2：指定上限的数字，或 EQT 比较类型的上限阈值。\n"
2Other_DESC3 Line0005 = "参数 3：指定下限的数字，或 EQT 比较类型的下限阈值。\n"
2Other_DESC3 Line0006 = "参数 4：指定如何将值与限制进行比较。有效值为 EQ、EQT、NE、GT、LT、GE、LE、GTLT、GELE、GELT、GTLE、LTGT、LEGE、LTGE、LEGT和 LOG。比较与数字极限测试步骤的相应比较相同。\n"
2Other_DESC3 Line0007 = "参数 5：（可选）传递 True 以在传递给比较中未使用的高参数和低参数的属性上设置 DontCopyToResults 属性标志。此默认值为 True。\n"
2Other_DESC3 Line0008 = "参数 6：（可选）指定标称值的数字。此参数仅用于 EQT 比较类型。\n"
2Other_DESC3 Line0009 = "参数 7：（可选）指定如何计算 EQT 比较类型的下限和上限。有效值为 PERCENTAGE、PPM 和 DELTA。阈值类型与数值限制测试步骤的相应阈值类型相同.\n"
2Other_DESC3 Line0010 = "返回：如果值在限制范围内或比较类型为 LOG，则为\"通过\"。否则返回\"失败\"。\n"

2Other_SYM4 = "ConvertColor()"
2Other_OP4 = "在小端格式 (Windows/ActiveX) 和大端格式 (LabVIEW, CVI) 之间转换颜色值"
2Other_DESC4 Line0001 = "Number ConvertColor(Number color)\n"
2Other_DESC4 Line0002 = "此函数在大端和小端颜色值格式之间进行转换。颜色值是"
2Other_DESC4 Line0003 = "存储为四字节整数，以两种常见格式之一表示：小端和大端。Windows "
2Other_DESC4 Line0004 = "和 ActiveX 使用小端格式，而 LabVIEW 和 LabWindows/CVI 使用大端格式。"
2Other_DESC4 Line0005 = "little-endian 格式以 0x00BBGGRR 的形式存储红色、绿色和蓝色分量。big-endian "
2Other_DESC4 Line0006 = "格式以 0x00RRGGBB 的形式存储颜色分量。\n"
2Other_DESC4 Line0007 = "参数 1：数字颜色值。\n"
2Other_DESC4 Line0008 = "返回：转换为相反格式的颜色值。"

2Other_SYM5 = "CurrentUserHasPrivilege()"
2Other_OP5 = "判断当前用户是否有特定权限"
2Other_DESC5 Line0001 = "Boolean CurrentUserHasPrivilege(String privilegeName)\n"
2Other_DESC5 Line0002 = "如果当前用户具有您指定的权限，则此函数返回 True。\n"
2Other_DESC5 Line0003 = "参数1：包含权限名称的字符串。通过\"*\"判断用户当前是否是"
2Other_DESC5 Line0004 = "已登录。\n"
2Other_DESC5 Line0005 = "返回：如果当前用户有权限或用户权限检查被禁用则返回真。返回 "
2Other_DESC5 Line0006 = "否则为假。"

2Other_SYM6 = "Evaluate()"
2Other_OP6 = "计算一个表达式"
2Other_DESC6 Line0001 = "PropertyObject Evaluate(String string)\n"
2Other_DESC6 Line0002 = "此函数返回您在字符串中指定的表达式的值。\n"
2Other_DESC6 Line0003 = "参数 1：要计算的表达式。注意：您必须转义表达式中的任何特殊字符 "
2Other_DESC6 Line0004 = "字符串。有关详细信息，请参阅特殊字符串字符帮助主题。\n"
2Other_DESC6 Line0005 = "返回：计算表达式的结果。"

2Other_SYM7 = "查找文件()"
2Other_OP7 = "查找文件路径"
2Other_DESC7 Line0001 = "Boolean FindFile(String fileToFind, Boolean useCurSeqFileDir = True, [String PathToFile], Number promptFlag "
2Other_DESC7 Line0002 = "= 1, Number searchFlag = 1, [Out] [Boolean canceled], Boolean isCommand = False)\n"
2Other_DESC7 Line0003 = "此函数试图在 TestStand 搜索目录中找到您指定的文件。\n"
2Other_DESC7 Line0004 = "参数 1：包含要搜索的文件名的字符串。\n"
2Other_DESC7 Line0005 = "参数2：（可选）传True搜索当前序列文件目录（如果有的话）。默认值"
2Other_DESC7 Line0006 = "为真。\n"
2Other_DESC7 Line0007 = "参数 3：（可选输出）文件的完整路径，如果找到文件。如果找不到文件，"
2Other_DESC7 Line0008 = "这个参数包含一个空字符串\n"
2Other_DESC7 Line0009 = "参数 4：（可选）指定是否提示用户输入文件的位置，如果不能"
2Other_DESC7 Line0010 = "在搜索目录中找到。有效值为：\n"
2Other_DESC7 Line0011 = " 	1 - (default) 使用引擎的配置选项来决定是否提示用户。\n"
2Other_DESC7 Line0012 = " 2 - 提示用户。\n"
2Other_DESC7 Line0013 = " 	3 - 不提示用户。\n"
2Other_DESC7 Line0014 = "参数 5：（可选）指定"将目录添加到搜索目录列表"检查的行为"
2Other_DESC7 Line0015 = "框，如果您选择提示用户。有效值为：\n"
2Other_DESC7 Line0016 = " 	1 - (default) 取消选中复选框，从而允许用户决定是否附加目录 "
2Other_DESC7 Line0017 = "包含文件到搜索目录列表，如果当前用户有配置引擎权限。\n"
2Other_DESC7 Line0018 = " 	2 - 如果当前用户具有配置引擎权限，则使启用状态的复选框变暗。\n"
2Other_DESC7 Line0019 = " 	3 - 禁用状态下的复选框变暗。\n"
2Other_DESC7 Line0020 = " 	4 - 与 1 相同，但不检查用户权限。\n"
2Other_DESC7 Line0021 = " 	5 - 与 2 相同，但不检查用户权限。\n"
2Other_DESC7 Line0022 = "参数 6：（可选输出）用户是否取消了对文件的搜索。\n"
2Other_DESC7 Line0023 = "参数7：（可选）指定文件是否为命令。如果传递true且fileToFind有"
2Other_DESC7 Line0024 = "没有文件扩展名，然后 FindFile 搜索具有相同基本名称且以通用命令结尾的文件"
2Other_DESC7 Line0025 = "扩展名：.exe、.com 和 .bat。如果在搜索目录中找不到该文件，FindFile 将搜索 "
2Other_DESC7 Line0026 = "已注册应用程序的注册表。默认为 False。\n"
2Other_DESC7 Line0027 = "返回：如果找到文件则返回 True，否则返回 False。"

2Other_SYM8 = "RGB()"
2Other_OP8 = "创建颜色值"
2Other_DESC8 Line0001 = "数字 RGB（数字 redComponent，数字greenComponent，数字 blueComponent）\n"
2Other_DESC8 Line0002 = "返回：一个数字，表示具有您指定的组件的颜色。颜色值采用小端格式"
2Other_DESC8 Line0003 = "格式。使用ConvertColor函数更改为big-endian格式。注意：可以指定常用颜色"
2Other_DESC8 Line0004 = "具有颜色常量的值，例如 tsRed 和 tsWhite。\n"
2Other_DESC8 Line0005 = "参数 1：颜色中红色的数量。范围从 0（无）到 255（最大）。\n"
2Other_DESC8 Line0006 = "参数 2：颜色中绿色的数量。范围从 0（无）到 255（最大）。\n"
2Other_DESC8 Line0007 = "参数 3：颜色中蓝色的数量。范围从 0（无）到 255（最大）。\n"

2Other_SYM9 = "目标名称()"
2Other_OP9 = "获取步骤名称"
2Other_DESC9 Line0001 = "String TargetName(PropertyObject propertyObject, String stepIdOrName, Boolean isExpression = False, Boolean "
2Other_DESC9 Line0002 = "includeStepGroup = False, Number/String stepGroup = -1, Number/String stepGroupToOmit = -1)\n"
2Other_DESC9 Line0003 = "返回描述由步骤名称或唯一步骤 ID 指定的目标的字符串。\n"
2Other_DESC9 Line0004 = "参数 1：Sequence 或 SequenceFile 属性对象。\n"
2Other_DESC9 Line0005 = "参数 2：唯一的步骤 ID 或步骤名称字符串。\n"
2Other_DESC9 Line0006 = "参数 3：（可选）指定 stepIdOrName 是否为字符串表达式。默认值为 False。\n"
2Other_DESC9 Line0007 = "参数4：（可选）指定目标的步骤组是否应该包含在目标中"
2Other_DESC9 Line0008 = "名称。默认值为 False。\n"
2Other_DESC9 Line0009 = "参数5：（可选）指定目标的步组。指定时忽略此参数"
2Other_DESC9 Line0010 = "唯一的步骤 ID。默认值为 -1。\n"
2Other_DESC9 Line0011 = "参数 6：（可选）指定不应显示的步骤组。如果此 [includeStepGroup] "
2Other_DESC9 Line0012 = "为True且目标在该参数指定的步组中，则不添加步组"
2Other_DESC9 Line0013 = "到目标名称。默认值为 -1。\n"
2Other_DESC9 Line0014 = "返回：目标名称字符串。"

2Other_SYM10 = "OutputMessage()"
2Other_OP10 = "创建输出消息并将其发布到输出窗口"
2Other_DESC10 Line0001 = "OutputMessage(String message, String category = \"\", Number severity = 0, [Number textColor], [String "
2Other_DESC10 Line0002 = "图标])\n"
2Other_DESC10 Line0003 = "参数 1：包含要在输出窗口中	显示	的消息的字符串。\n"
2Other_DESC10 Line0004 = "参数2：（	可选）指定消息的类别。		如果不指定类别，则"
2Other_DESC10 Line0005 = "输出消息将被视为未分类。	您可以定义自己的类别。默认值"
2Other_DESC10 Line0006 = "是一个空字符串。\n"
2Other_DESC10 Line0007 = "参数 3：（	可选）指定消息的严重性。有效值为：\n"
2Other_DESC10 Line0008 = " 	0 -（默认）OutputMessageSeverity_Information。\n"
2Other_DESC10 Line0009 = " 	1 - OutputMessageSeverity_Warning。\n"
2Other_DESC10 Line0010 = " 	2 - OutputMessageSeverity_Error。\n"
2Other_DESC10 Line0011 = "参数 4：（	可选）指定用于显示消息的文本颜色。使用颜色常量，例如 "
2Other_DESC10 Line0012 = "作为 tsBlack，或使用 RGB 函数使用组件颜色值指定颜色。\n"
2Other_DESC10 Line0013 = "参数5：（可选）指定	与输出消息相关的图标文件名称。TestStand "
2Other_DESC10 Line0014 = "引擎从	<TestStand>\Components\Icons 和<TestStand Public>\Components\Icons 获取图标"
2Other_DESC10 Line0015 = "目录。	此参数可选，默认图标根据"
2Other_DESC10 Line0016 = "消息。\n"
2Other_DESC10 Line0017 = "返回：		此函数始终返回 0。"

2Other_SYM11 = "GetEngine()"
2Other_OP11 = "访问 TestStand 引擎"
2Other_DESC11 Line0001 = "引擎 GetEngine()\n"
2Other_DESC11 Line0002 = "返回对 TestStand 引擎的引用。表达式通常根据 SequenceContext 进行评估"
2Other_DESC11 Line0003 = "通过其 RunState.Engine 属性提供对引擎访问的对象。但是，表达式"
2Other_DESC11 Line0004 = "可以使用 TestStand API 中的方法在没有 SequenceContext 的情况下进行评估。此函数提供 "
2Other_DESC11 Line0005 = "表达式访问 TestStand 引擎，即使表达式没有根据 SequenceContext 求值。\n"
2Other_DESC11 Line0006 = "返回：		对 TestStand 引擎的引用。"
;;如果有更多指令，我们可能希望将指令作为它们自己的类别而不是其他类别的一部分

2Other_SYM12 = "#NoValidation()"
2Other_OP12 = "禁用评估错误检查\n"
2Other_DESC12 Line0001 = "#NoValidation(表达式表达式)\n"
2Other_DESC12 Line0002 = "禁用部分或全部表达式的评估错误检查。使用此指令来抑制 "
2Other_DESC12 Line0003 = "在编辑时报告的错误不会在运行时发生，例如使用序列创建的变量"
2Other_DESC12 Line0004 = "在运行时通过使用 TestStand API。使用不带参数列表的指令来抑制错误"
2Other_DESC12 Line0005 = "检查表达式的剩余部分，或者将一个单独的表达式作为参数传递给这个"
2Other_DESC12 Line0006 = "仅对参数表达式禁止错误检查的指令。\n"
2Other_DESC12 Line0007 = "参数 1：传递要在编辑时禁用计算错误检查的表达式。"

2Other_SYM13 = "Enum()"
2Other_OP13 = "创建一个枚举实例。\n"
2Other_DESC13 Line0001 = "Enum(String enumType, [String/Number value])\n"
2Other_DESC13 Line0002 = "创建具有指定类型和值的枚举。如果未指定值，则返回的枚举具有默认值。\n"
2Other_DESC13 Line0003 = "参数 1：指定要创建的枚举类型。\n"
2Other_DESC13 Line0004 = "参数 2：（可选）指定枚举的值。\n"
2Other_DESC13 Line0005 = "返回：具有指定类型和值的枚举。\n"


[Adapter Names]
DLL Flexible Prototype Adapter = "C/C++ DLL"
G Flexible VI Adapter = "LabVIEW"
G Std Prototype Adapter= "LabVIEW 标准原型适配器"
Sequence Adapter ="序列"
C/CVI Std Prototype Adapter = "LabWindows/CVI 标准原型适配器"
C/CVI Flexible Prototype Adapter = "LabWindows/CVI"
Automation Adapter= "ActiveX/COM"
None Adapter = "<无>"
HTBasic Adapter= "HTBasic"
DotNet Adapter = ".NET"
C++ Adapter = "C++"
LabVIEW NXG Adapter = "LabVIEW NXG"
Python Adapter = "Python"

[ENGINE_INSTALLATION_WIZARD]
WELCOME_CAPTION = "TestStand 引擎安装向导"
WELCOME_HEADER = "欢迎使用 TestStand 引擎的安装向导。"
WELCOME_FOOTER = "该程序将创建一个简单的自定义 TestStand 引擎设置，其中包含您自己的引擎组件。"

SETUP_SOURCE_CAPTION = "需要文件/目录来创建 TestStand 引擎安装"
SETUP_SOURCE_HEADER = "无法找到构建 TestStand 引擎安装程序所需的以下项目："
SETUP_SOURCE_EXE = "TestStand 引擎设置可执行文件"
SETUP_SOURCE_DIR = "TestStand 引擎设置文件目录"

BROWSE_FOR_FOLDER_CAPTION = "选择目录"

SHOW_USER_FILES_CAPTION = "TestStand 引擎安装向导"
SHOW_USER_FILES_HEADER = "除了 TestStand Engine 安装文件，以下目录内容和文件将包含在安装中："
SHOW_USER_FILES_CUSTOMIZE = "自定义..."

CUSTOMIZE_USER_FILES_CAPTION = "自定义要包含在安装中的文件"
CUSTOMIZE_USER_FILES_LIST = "要包含的目录/文件："
CUSTOMIZE_USER_FILES_INSERT = "添加..."
CUSTOMIZE_USER_FILES_EDIT = "编辑..."
CUSTOMIZE_USER_FILES_DELETE = "删除"
CUSTOMIZE_USER_FILES_MOVE_UP = "上移"
CUSTOMIZE_USER_FILES_MOVE_DOWN = "下移"

SHOW_USER_FILES_COLUMN_HDR_FILES = "文件"
SHOW_USER_FILES_COLUMN_HDR_DESTINATION = "目的地"

BROWSE_USER_FILES_CAPTION = "选择要包含的文件"
BROWSE_USER_FILES_SOURCE_DIR = "来源目录："
BROWSE_USER_FILES_DESTINATION = "目的地的相对路径："
BROWSE_USER_FILES_INCLUDE_FILES = "包含以下文件："
BROWSE_USER_FILES_WILDCARD = "包含与通配符匹配的文件："
BROWSE_USER_FILES_RECURSE = "递归子目录"

SETUP_DESTINATION_CAPTION = "选择 TestStand 引擎安装文件目标"
SETUP_DESTINATION_HEADER = "安装文件（SetupTSEngine.exe 和 TSEngine.cab）将在以下位置创建："
SETUP_DESTINATION_CHANGE = "改变..."
SETUP_DESTINATION_FOOTER = "按下一步接受这个位置。"

MDAC_CAPTION = "选择一个 MDAC 安装程序"
MDAC_HEADER = "请选择一个 MDAC（Microsoft 数据访问组件）安装程序以包含在您的引擎设置中："
MDAC_DEFAULT_CHOICE = "MDAC 2.5 SP1 英文版。这是英文版的 MDAC 2.5 Service Pack 1 可再发行配置。"
MDAC_CUSTOM_CHOICE = "选择不同的 MDAC 安装程序。TestStand 安装 CD 上提供了几种不同的语言版本："
MDAC_NONE_CHOICE = "不要安装 MDAC（请注意 TestStand 2.0.1 数据库组件需要 MDAC 2.5 或更高版本。"
MDAC_READ_EULA = "阅读 MDAC EULA"
MDAC_EULA_CAPTION = "MDAC EULA"
MDAC_EULA_MSG = "在重新分发 MDAC 之前，您必须仔细阅读 MDAC EULA（最终用户许可协议）并同意其条款。"
MDAC_EULA_MISSING_CAPTION = "未找到 MDAC EULA"
MDAC_EULA_MISSING_MSG = "未找到 MDAC EULA（最终用户许可协议）。请务必在重新分发 MDAC 之前查找并仔细阅读。"

START_COPY_CAPTION = "准备创建设置"
START_COPY_HEADER = "TestStand Engine 的 Installation Builder 现在有足够的信息来创建安装。"
START_COPY_FOOTER = "按‘开始’创建安装。"

STATUS_DLG_CAPTION = "TestStand 引擎安装向导"
STATUS_CREATING_USER_CAB = "正在创建用户驾驶室..."
STATUS_CREATING_ENGINE_CAB = "正在创建引擎设置驾驶室..."
STATUS_CANCELING = "正在取消..."
STATUS_BUILD_COMPLETE = "构建完成"
STATUS_FILES_CREATED = "创建了以下文件："

BROWSE_USER_FILES_ERROR = "%s 中的内部错误\r\n%s 失败。"
ERROR_DIALOG_CAPTION = "错误"
CAB_ERROR_OPEN = "打开/读取存储在文件柜中的文件失败。"
CAB_ERROR_OUT_OF_MEMORY = "内存不足。"
CAB_ERROR_TEMP_FILE = "无法创建临时文件。"
CAB_ERROR_CREATE = "无法创建 cabinet 文件。"
CAB_ERROR_COMPRESSING = "压缩数据失败。"
CAB_ERROR_UNKNOWN = "未知错误。"
BAD_ITEMIDLIST_DISPLAY_NAME = "<错误>"
ERROR_CANNOT_DELETE_OLD_CAB = "无法删除之前的 cab 文件 '%s'。"

OK_BTN = "&OK"
BACK_BTN = "&返回"
NEXT_BTN = "&下一步"
BEGIN_BTN = "&开始"
GO_BTN = "&开始"
CANCEL_BTN = "取消"
YES_BTN = "&Yes"
NO_BTN = "&否"
BROWSE_BTN = "浏览..."
DONE_BTN = "&完成"

[REMOTE_ENGINE]
NO_HOST = "未连接"
CONNECTED = "已连接"
REMOTE_HOST = "连接到："
EXECUTING = "正在执行"
START = "远程引擎启动于：%1"
ENGINE_VERSION_MSG = "TestStand 引擎版本 %1"
INIT = "远程引擎初始化"
PROCESS = "远程引擎处理"
ICON_TOOLTIP_HEADER = "NI TestStand 远程引擎"
GENERAL_ERROR_MSG = "在 %1 期间远程引擎发生错误。\n 错误详细信息：%2\n 错误代码：%3"

CONNECTED_EXIT_WARNING_TITLE = "Engine Still Connected - NI TestStand Remote Engine"
CONNECTED_EXIT_WARNING Line0001 = "机器 %1 上的 TestStand 引擎仍然连接到这个远程引擎。"
CONNECTED_EXIT_WARNING Line0002 = "如果此时退出，引擎将无法清理。这可能会离开"
CONNECTED_EXIT_WARNING Line0003 = "引擎状态不佳。\n\n你确定要退出吗？"

EXECUTION_EXIT_WARNING_TITLE = "正在执行 - NI TestStand 远程引擎"
EXECUTION_EXIT_WARNING Line0001 = "机器 %1 上的 TestStand 引擎仍在这台机器上执行序列。"
EXECUTION_EXIT_WARNING Line0002 = "如果此时退出，执行会产生错误，引擎将无法运行"
EXECUTION_EXIT_WARNING Line0003 = "清理。这可能会使引擎处于不良状态。\n\n您确定要退出吗？"
   
[RENGINE_MENU]
ABOUT = "关于"
EXIT = "退出"

[SAVE_AS]
PASSWORD_PROTECTED_TYPES_NOT_SUPPORTED Line0001 = "注意：类型定义锁定是在 TestStand 2012 中引入的。类型 '%1' 具有密码保护设置。\n"
PASSWORD_PROTECTED_TYPES_NOT_SUPPORTED Line0002 = "以前版本的 TestStand 不支持此功能，因此这些设置已丢失。"
PASS_BY_REF_POINTER_PARAM_SAVED_AS_2010 Line0001 = "注意：此步骤从 TestStand 2012 或更高版本转换而来并保存为 TestStand 2010。此步骤使用传递引用指针参数。\n"
PASS_BY_REF_POINTER_PARAM_SAVED_AS_2010 Line0002 = "因为TestStand 2010 SP1是支持传递引用指针参数的最早版本，你将无法打开它\n"
PASS_BY_REF_POINTER_PARAM_SAVED_AS_2010 Line0003 = "TestStand 2010 中的序列文件。您必须改用 TestStand 2010 SP1。"
DOTNET_ADAPTER_2010_INT64 Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤使用 Int64 或 UInt64 数据类型。\n"
DOTNET_ADAPTER_2010_INT64 Line0002 = "以前版本的 .NET 适配器将 Int64 值转换为双精度值，这可能会失去精度（即\n"
DOTNET_ADAPTER_2010_INT64 Line0003 = "如果 Int64 不能精确存储在 Double 中，则为完整范围。此步骤可能无法按预期工作。"
DOTNET_ADAPTER_2010_JAGGED_ARRAY Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤使用锯齿状数组（即数组的数组）。\n"
DOTNET_ADAPTER_2010_JAGGED_ARRAY Line0002 = "以前版本的 TestStand 不支持锯齿状数组。此步骤将无法按预期进行。"
DOTNET_ADAPTER_2010_GENERIC_CLASSNAME Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤调用通用类 '%1' 上的成员。\n"
DOTNET_ADAPTER_2010_GENERIC_CLASSNAME Line0002 = "以前版本的 TestStand 不支持调用泛型类的成员。此步骤将无法按预期工作。"
DOTNET_ADAPTER_2010_GENERIC_TYPE_USED Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤正在使用通用类型 '%1'。\n"
DOTNET_ADAPTER_2010_GENERIC_TYPE_USED Line0002 = "以前版本的 TestStand 不完全支持通用类型。此步骤可能无法按预期工作。"
DOTNET_ADAPTER_2010_UNSUPPORTED_CLASSNAME Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤调用类 '%1' 的成员。\n"
DOTNET_ADAPTER_2010_UNSUPPORTED_CLASSNAME Line0002 = "以前版本的 TestStand 不支持调用此数据类型的成员。此步骤可能无法按预期工作。"
DOTNET_ADAPTER_2010_UINTPTR Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤使用 System.UIntPtr 数据类型。\n"
DOTNET_ADAPTER_2010_UINTPTR Line0002 = "以前版本的 TestStand 没有正确支持这种数据类型作为内置类型，而是把它当作一个\n"
DOTNET_ADAPTER_2010_UINTPTR Line0003 = "struct.TestStand 已经相应地转换了调用，但是它可能需要额外的更改才能运行。"
DOTNET_ADAPTER_2010_TOO_MANY_CALLS Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤最初配置为调用多个成员。\n"
DOTNET_ADAPTER_2010_TOO_MANY_CALLS Line0002 = "以前版本的 TestStand 不支持此功能。对第一个成员以外的成员的其他调用未被转换。"
DOTNET_ADAPTER_2010_INVALID_FIRST_CALL Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤的第一次调用被配置为构造函数、使用现有、创建远程或静态成员调用以外的其他内容。\n"
DOTNET_ADAPTER_2010_INVALID_FIRST_CALL Line0002 = "无法进行等效转换。"
DOTNET_ADAPTER_2010_INVALID_SECOND_CALL Line0001 = "注意：此步骤是从 TestStand 2010 或更高版本转换而来。.NET 步骤的第二次调用被配置为成员调用以外的其他内容。\n"
DOTNET_ADAPTER_2010_INVALID_SECOND_CALL Line0002 = "无法进行等效转换。"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0001 = "注意：此步骤是从 TestStand 2010 SP1 或更高版本转换而来。此 .NET 步骤配置为调用 GAC 中的程序集。\n"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0002 = "自 TestStand 2010 SP1 起，.NET 适配器不再包含强名称中的处理器架构，用于加载\n"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0003 = "来自 GAC 的程序集。此类步骤可能会在早期版本的 TestStand 的模块面板中显示为无法找到\n"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0004 = "程序集，因为早期版本的 TestStand 需要处理器架构。该步骤仍将加载并运行\n"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0005 = "在大多数情况下是正确的，但是如果您需要修改模块规格，则需要选择相应的\n"
DOTNET_ADAPTER_2010SP1_NO_PROCESSOR_ARCHITECTURE Line0006 = "早期版本的 TestStand 期望的 GAC 列表中的强名称。"
FIRST_LINE Line0001 = "发现以下兼容性问题。\n"
FIRST_LINE Line0002 = "原始序列文件版本：%1。\n\n"
PROTECTED_FILE_WARNING = "原始文件已被保护。文件将不再受保护，因为低于 TestStand 3.5 的版本不支持文件保护。\n\n"
DOT_NET_ADP = "注意：此步骤是从 TestStand 3.0 或更高版本转换而来的。其原始适配器是 .Net，在早期版本的 TestStand 中不受支持。"
LV_ADP = "注意：此步骤是从 TestStand 3.0 或更高版本转换而来的。新的 LabVIEW 原型包含以前版本不支持的属性。"
CVI_ADP = "注意：此步骤是从 TestStand 3.0 或更高版本转换而来的。新的 LabWindows/CVI 原型包含以前版本不支持的属性。"
CPP_ADP = "注意：此步骤是从 TestStand 3.0 或更高版本转换而来的。新的 DLL Flexible 原型包含以前版本不支持的属性。"
NEW_STEP_TYPE = "注意：步骤类型 '%1' 是在 TestStand %2 中引入的，以前的 TestStand 版本不支持。在为早期版本的 TestStand 保存文件时，此类型的所有步骤都将替换为标签步骤。"
NEW_TS31_PROP_LOADER_STEP_TYPE = "注意：属性加载器步骤类型在 TestStand 3.1 中进行了修改。当您将包含属性加载器步骤的序列保存为以前版本的 TestStand 时，您必须确保导入的属性是适当的。取决于类型在转换为之前的版本时由步骤导入的属性，它可能会正常工作或引发运行时错误。"
STEP_INFO Line0001 = "步骤名称：%1，序列：%2，步骤组：%3，步骤索引：%4\n"
STEP_INFO Line0002 = "注释：%5\n\n"
SUB_STEP_INFO Line0001 = "步骤名称：%1，对应于步骤类型的子步骤：%2\n"
SUB_STEP_INFO Line0002 = "注释：%3\n\n"
STEPTYPE_INFO Line0001 = "步骤类型名称：%1\n"
STEPTYPE_INFO Line0002 = "注释：%2\n\n"
UNKNOWN_LOCATION_INFO = "位置：%1\n问题：%2\n\n"
STEP_GROUP_MAIN = "主要步骤"
STEP_GROUP_SETUP = "设置"
STEP_GROUP_CLEANUP = "清理"
MSGPOPUP_RESP_EXPR = "注意：此步骤包含初始响应字符串表达式，在早期版本中运行时不会对其进行评估。"
LV_CLUSTERS Line0001 = "注意：此步骤是从 TestStand 3.5 或更高版本转换而来。此步骤最初配置为使用部分簇或部分数组。\n"
LV_CLUSTERS Line0002 = "一些必需的参数值可能在转换过程中丢失了。"
LV_EXPRESS_VI = "注意：此步骤是从 TestStand 3.1 或更高版本转换而来。此步骤最初配置为使用快速 VI，但以前的 TestStand 版本不支持它。"
STRING_VAL_TEST_EXPR Line0001= "注意：此步骤是从 TestStand 4.0 或更高版本转换而来。此步骤最初配置为使用表达式来指定预期的字符串值或比较类型。\n"
STRING_VAL_TEST_EXPR Line0002= "以前版本的 TestStand 不支持此功能。请验证设置是否正确。"
NUM_LIMIT_TEST_EXPR Line0001= "注意：此步骤是从 TestStand 4.0 或更高版本转换而来。此步骤最初配置为使用表达式来指定限制值或比较类型。\n"
NUM_LIMIT_TEST_EXPR Line0002= "以前版本的 TestStand 不支持此功能。请验证设置是否正确。"
MULTI_NUM_LIMIT_TEST_EXPR Line0001= "注意：此步骤是从 TestStand 4.0 或更高版本转换而来。此步骤最初配置为使用表达式来指定限制值或测量的比较类型。\n"
MULTI_NUM_LIMIT_TEST_EXPR Line0002= "以前版本的 TestStand 不支持此功能。请验证设置是否正确。"
PROPERTY_HAD_ATTRIBUTES = "属性 '%1' 有属性。属性是在 TestStand 4.2 中引入的，以前的 TestStand 版本不支持。属性没有保存。\n\n"

PROPERTY_HAD_TYPE_ATTRIBUTES = "属性 '%1' 具有类型属性。类型属性是在 TestStand 4.5 中引入的，以前的 TestStand 版本不支持。类型属性未保存。\n\n"
LV_PROJECT Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 项目。\n"
LV_PROJECT Line0002 = "一些必需的配置可能在转换过程中丢失了。"
LV_PACKED_LIBRARY Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 打包库。\n"
LV_PACKED_LIBRARY Line0002 = "以前版本的 TestStand 不支持 LabVIEW 打包库。"
LV_CALL_TYPE Line0001 = "注意：此步骤/步骤类型是从 TestStand 2012 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 类成员调用。\n"
LV_CALL_TYPE Line0002 = "一些必需的配置可能在转换过程中丢失了。"
LV_PROPERTY_NODE Line0001 = "注意：此步骤/步骤类型是从 TestStand 2013 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 属性节点调用。\n"
LV_PROPERTY_NODE Line0002 = "一些必需的配置可能在转换过程中丢失了。"
LV_64BIT Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 64 位整数参数。\n"
LV_64BIT Line0002 = "在以前版本的 TestStand 中，64 位整数参数将被视为未知类型参数。"
LV_CLASS Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 类参数。\n"
LV_CLASS Line0002 = "在以前版本的 TestStand 中，LabVIEW 类参数将被视为未知类型参数。"
LV_ENUM Line0001 = "注意：此步骤/步骤类型是从 TestStand 2012 或更高版本转换而来。步骤/步骤类型最初是使用 TestStand 2012 或更高版本配置的，并且它具有枚举参数。\n"
LV_ENUM Line0002 = "当在旧版本的 TestStand 中使用 LabVIEW 2012 或更高版本时，传递给枚举参数的值将不会被规范化。"
CVI_DLL_64BIT Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为调用包含 64 位整数或指针/句柄参数的函数 '%1'。\n"
CVI_DLL_64BIT Line0002 = "这些参数类型在以前版本的 TestStand 中不受支持。"
ACTIVEX_64BIT Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为访问包含 64 位整数参数或返回类型的 '%1'。\n"
ACTIVEX_64BIT Line0002 = "这些类型在以前版本的 TestStand 中不受支持。"
ACTIVEX_METHOD = "方法"
ACTIVEX_PROP = "属性"
SEQ_64BIT Line0001 = "注意：此序列调用是从 TestStand 2010 或更高版本转换而来。序列调用包含 64 位整数参数。\n"
SEQ_64BIT Line0002 = "64 位整数参数在以前版本的 TestStand 中不受支持，将被转换为双精度值。\n"
SEQ_64BIT Line0003 = "将 64 位整数转换为双精度可能会导致精度损失。"
DOT_NET_64BIT Line0001 = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来的。被调用的成员包含 64 位整数参数。"
DOT_NET_64BIT Line0002 = ".Net 适配器的 64 位整数参数在 TestStand 的早期版本中在内部被视为双精度数。"
DOT_NET_64BIT Line0003 = "将 64 位整数视为双精度数可能会导致精度损失。"
DEPLOY_LIBRARY_STEP = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 项目。\n"
RUN_VI_ASYNCHRONOUSLY_LVPROJECT = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 项目。\n"
RUN_VI_ASYNCHRONOUSLY_LVPPL = "注意：此步骤/步骤类型是从 TestStand 2010 或更高版本转换而来。步骤/步骤类型最初配置为使用 LabVIEW 打包库。\n"
FAILURE_ACTION_NONE_CONVERSION = "序列 '%1' 中 FailureAction_None 的 Sequence.FailureAction 值在先前版本中不存在。它已被转换为 False 的 Sequence.GotoCleanupOnFailure 值。\n\n"
RECORD_RESULT_OPTION_OVERRIDE_SEQUENCE_SETTING_CONVERSION = "Enabled 的 ResultRecordingOption（Override Sequence Setting）在之前的版本中不存在。它已经被转换为 True 的 RecordResult 值。\n"
STEP = "步骤"
STEP_TYPE = "步骤类型"
SELECT_CASE_COMPARISON_NOT_SUPPORTED = "选择步骤选项'区分大小写（对于字符串值）'在以前的版本中不存在。它已被删除并且比较现在不区分大小写。\n"
NUMERIC_LIMIT_COMPARISON_TYPE_NOT_SUPPORTED = "比较类型 '%1' 在 TestStand 2014 及更早版本中不存在。将比较类型更新为有效值。"
NUMERIC_LIMIT_COMPARISON_TYPE_NOT_SUPPORTED_EXPR = "比较类型由表达式指定，并且可能计算为 TestStand 2014 及更早版本不支持的比较类型。确保表达式始终计算为有效值。"
ENUM_NOT_SUPPORTED Line0001 = "命名类型 '%1' 是一个枚举值类型。之前版本的 TestStand 不支持枚举，因此它已被转换为数字。"
ENUM_NOT_SUPPORTED Line0002 = "默认情况下，先前版本中的 Number 将禁用所有与适配器相关的结构传递设置。\n\n"
ENUM_NOT_SUPPORTED Line0003 = "注意：将枚举数组作为参数的适配器步骤在以前版本的 TestStand 中会失败，因为只支持纯数字数组（不是命名类型）。\n"
LV_ENUM_PARAM Line001 = "注意：此步骤/步骤类型是从 TestStand 2016 或更高版本转换而来。步骤/步骤类型最初是使用 TestStand 2016 或更高版本配置的，它具有枚举参数。\n"
LV_ENUM_PARAM Line002 = "在旧版本的 TestStand 中，字符串和枚举类型不能传递给 LabVIEW 的枚举参数。"
LV_NXG_ADP = "注意：此步骤是从 TestStand 2017 或更高版本转换而来的。其原始适配器是 LabVIEW NXG，在早期版本的 TestStand 中不受支持。"
LV_NXG_VI_ASYNC_SAVE_AS_PREVIOUS = "注意：此步骤从 TestStand 2017 或更高版本转换而来。其原始序列步骤类型为异步运行 LabVIEW NXG VI，并且在早期版本的 TestStand 中不受支持。"
FOR_EACH_STREAMS_NOT_SUPPORTED_BEFORE_2017 = "在 TestStand 2017 之前不支持迭代 InputRecordStreams。在旧版本的 TestStand 中执行此步骤类型将导致运行时错误。"
NEW_CSV_INPUT_STREAM_FEATURES_NOT_SUPPORTED_BEFORE_2019 = "在 TestStand 2019 之前不支持解析记录原型。在旧版本的 TestStand 中执行此步骤类型将无法按预期工作。"
NEW_CSV_OUTPUT_STREAM_FEATURES_NOT_SUPPORTED_BEFORE_2019 = "在 TestStand 2019 之前不支持编写标签和指定字段原型。在旧版本的 TestStand 中执行此步骤类型将无法按预期工作。"
PYTHON_ADP = "此步骤是从 TestStand 2019 或更高版本转换而来的。其原始适配器是 Python，并且在早期版本的 TestStand 中不受支持。"
IOSESSION_NOT_SUPPORTED = "数据类型'NI_IOSession'是在 TestStand 2019 中引入的，不能被适配器使用。\n"
OVERRIDE_BINARY = "注意：此步骤是从 TestStand 2019 或更高版本转换而来的。该步骤最初配置为使用覆盖模块设置，并且在早期版本的 TestStand 中不受支持。"
DISPATCH_PARAMETER_IN_PYTHON_ADP = "此步骤从 TestStand 2020 或更高版本转换而来。原始步骤使用 Python 适配器，其中至少一个参数类型配置为'Dispatch'。这在早期版本的 TestStand 中不受支持。"
ENUM_PARAMETER_IN_PYTHON_ADP = "此步骤是从 TestStand 2020 或更高版本转换而来。原始步骤使用 Python 适配器，其中至少一个参数类型配置为'Enum'。这在早期版本的 TestStand 中不受支持。"
NUMPY_ARRAY_PARAMETER_IN_PYTHON_ADP = "此步骤从 TestStand 2020 或更高版本转换而来。原始步骤使用 Python 适配器，其中至少一种参数类型配置为'NumPy Array'。这在早期版本的 TestStand 中不受支持。"
NUMPY_ARRAY_AS_DEFAULT_ARRAY_TYPE_IN_PYTHON_ADP = "此步骤是从 TestStand 2020 或更高版本转换而来的。原始步骤使用 Python 适配器，并将"将数字数组传递为"配置为"NumPy 数组"。这在早期版本的 TestStand 中不受支持。"
AUTO_POPULATED_PANEL = "此步骤是从 TestStand 2020 或更高版本转换而来。步骤类型 '%1' 使用 TestStand 2020 中引入的 '自定义步骤类型的自动属性面板' 功能，该功能在以前版本的 TestStand 中不受支持. 为较早版本的 TestStand 保存文件时，此类型的所有步骤都将替换为标签步骤。"

[CVI_ADAPTER]
DEFAULT_FUNCTION_BODY_TEXT = "{\n\t//在此处插入函数体。\n}\n"

[DLL_ADAPTER]
DEFAULT_FUNCTION_BODY_TEXT = "{\n\t//在此处插入函数体。\n}\n"
VS_DEFAULT_FUNCTION_BODY_TEXT = "//在此处插入函数体。\r\n"

[LICENSE_DESCRIPTION]
EXPIRATION_SUFFIX = "（过期 %1）"
NO_LICENSE = "无执照"
EVAL_LICENSE = "评估"
BASE_DEPLOY_LICENSE = "基础部署引擎"
DBG_DEPLOY_LICENSE = "调试部署环境"
CUST_EDIT_DEPLOY_LICENSE = "自定义序列编辑器"
DEV_SYS_LICENSE = "开发系统"
TMP_LICENSE_SUFFIX = " - 临时"
OTHER_LICENSE = "其他许可证"

[TIME_LIMIT]
TIME_LIMIT_ZERO_TITLE = "警告时限 = 0"
TIME_LIMIT_ZERO_WARNING = "您正在将时间限制值设置为零。时间限制将立即到期。"

[UNDO]
;;撤销错误信息
CANNOT_CALL_FUNCTION_NOW = "你现在不能调用这个函数。"
CHANGE_COUNT_NOT_INCREMENTED = "您必须增加已编辑文件的更改计数。"
NO_EDITS = "无法创建撤消项，因为尚未进行任何编辑。"
OBJECT_NOT_IN_FILE = "文件 '%2' 中不存在对象 '%1'。"
TYPE_NOT_INSERTED = "类型 '%1' 没有插入到文件 '%2' 的类型使用列表中。"
UNEXPECTED_CHANGE_COUNT Line0001 = "TestStand 无法对文件 '%3' 执行撤消或重做操作 "
UNEXPECTED_CHANGE_COUNT Line0002 = "因为文件的更改计数是 %2 而不是 %1。这通常会发生"
UNEXPECTED_CHANGE_COUNT Line0003 = "当你执行不支持撤销的编辑操作时。例如，"
UNEXPECTED_CHANGE_COUNT Line0004 = "TestStand 不支持撤消对类型的编辑。要撤消或重做最近的更改"
UNEXPECTED_CHANGE_COUNT Line0005 = "到文件，您必须手动编辑文件。"
CHANGE_OBJECT_ON_TOP_LEVEL_OBJECT = "您不能为顶级对象上的 EditKind_ChangeObject 编辑创建撤消项。"
CHANGE_OBJECT_ON_DATA = "您不能为序列文件的数据属性上的 EditKind_ChangeObject 编辑创建撤消项。"

;;撤消项的说明
CHANGE_VALUE_X = "更改 %1 的值"
CHANGE_VALUES = "更改值"
RENAME_X = "重命名 %1"
RENAME = "重命名"
MODIFY_COMMENT_X = "修改 %1 的评论"
MODIFY_COMMENTS = "修改评论"
MODIFY_FLAGS_X = "修改 %1 的标志"
MODIFY_FLAGS = "修改标志"
MODIFY_NUMERIC_FORMAT_X = "修改 %1 的数字格式"
MODIFY_NUMERIC_FORMATS = "修改数字格式"
CHANGE_REPRESENTATION_X = "改变 %1 的表现形式"
CHANGE_REPRESENTATIONS = "改变陈述"
MODIFY_ATTRIBUTES_X = "修改 %1 的属性"
MODIFY_ATTRIBUTES = "修改属性"
INSERT_PROPERTY_X = "插入 %1"
INSERT_PROPERTIES = "插入变量/属性"
DELETE_PROPERTY_X = "删除 %1"
DELETE_PROPERTIES = "删除变量/属性"
DELETE_ARRAY_ELEMENT_X = "删除 %1[%2]"
DELETE_ARRAY_ELEMENTS = "删除元素"
MOVE_PROPERTY_X = "移动 %1"
MOVE_PROPERTIES = "移动变量/属性"
REPLACE_PROPERTY_X = "替换 %1"
REPLACE_PROPERTIES = "替换变量/属性"
INSERT_STEP_X = "插入步骤 %1"
INSERT_STEPS = "插入步骤"
DELETE_STEP_X = "删除步骤 %1"
DELETE_STEPS = "删除步骤"
MOVE_STEP_X = "移动步骤 %1"
MOVE_STEPS = "移动步数"
INSERT_SEQUENCE_X = "插入序列 %1"
INSERT_SEQUENCES = "插入序列"
DELETE_SEQUENCE_X = "删除序列 %1"
DELETE_SEQUENCES = "删除序列"
MOVE_SEQUENCE_X = "移动序列 %1"
MOVE_SEQUENCES = "移动序列"
CHANGE_OBJECT_X = "改变对象 %1"
CHANGE_OBJECTS = "改变对象"
CHANGE_STEP_X = "更改步骤 %1"
CHANGE_STEPS = "改变步骤"
CHANGE_SEQUENCE_PROPERTIES_X = "编辑序列 %1 的属性"
CHANGE_SEQUENCE_PROPERTIES = "编辑序列属性"
CHANGE_SEQUENCE_FILE_PROPERTIES_X = "编辑序列文件 %1 的属性"
CHANGE_SEQUENCE_FILE_PROPERTIES = "编辑序列文件属性"
CHANGE_RUN_MODE_X = "更改 %1 的运行模式"
CHANGE_RUN_MODES = "改变步骤的运行模式"
INSERT_TYPE_X = "插入类型 %1"
INSERT_TYPES = "插入类型"

[UNDO_STACK]
UNDO = "&撤消"
REDO = "&重做"
UNDO_ITEM = "&撤消 %1"
REDO_ITEM = "&重做 %1"
EMPTY_UNDO_STACK = "撤消堆栈为空。"
EMPTY_REDO_STACK = "重做堆栈为空。"
ITEM_ALREADY_ON_STACK = "无法将撤消项压入堆栈，因为撤消项已经在撤消堆栈中。"
UNDO_MODIFIED_STACK = "撤消或重做操作修改了撤消堆栈，使撤消堆栈处于无效状态。因此，撤消堆栈已删除所有项目。"
CANNOT_MODIFY_STACK_DURING_UNDO = "你现在不能修改撤消堆栈，因为撤消堆栈正在执行撤消或重做操作。"
UNDO_ERROR = "在撤消 '%1' 期间发生以下错误:\n\n%2"
REDO_ERROR = "重做 '%1' 期间发生以下错误:\n\n%2"

[OUTPUT_MESSAGE]
MESSAGE = "%消息"
TIME = "%时间"
CATEGORY = "%类别"
SEVERITY = "%严重性"
THREAD = "%线程"
EXECUTION = "%执行"
SEQUENCE_FILE = "%序列文件"
STEP = "%序列"
DBG_MSG = "%步骤"
DBG_MSG = "TS:[%Category] %Message\n"
UNCATEGORIZED = "未分类"

[API_IN_EXPR]
RETURN_VALUE_NAME = "从 %1 返回值"

[LOCATION]
OBJ_NOT_FOUND = "该对象在序列上下文中不存在。"
COULD_NOT_GOTO_FILE_LOCATION = "无法转到文件 %2 中的 %1。"
COULD_NOT_GOTO_EXECUTION_LOCATION = "在执行 %2 时无法转到 %1。"
COULD_NOT_GOTO_TYPE_LOCATION = "无法转到类型 %2 中的 %1。"
EMPTY_LOCATION = "<空位置>"
NO_FILE_SPECIFIED = "<未指定文件>"
NO_EXECUTION_SPECIFIED = "<未指定执行>"
NO_TYPE_SPECIFIED = "<未指定类型>"
COULD_NOT_OPEN_FILE = "%1 无法打开文件。"
OBJ_NOT_EXIST = "位置不存在。"
FILE_NOT_EXIST = "文件不存在。"
EXECUTION_NOT_EXIST = "执行不存在。"
CONTEXT_NOT_EXIST = "栈帧不再存在。"
CANNOT_DISPLAY_EXECUTION = "%1 无法显示执行。"
EXECUTION_NOT_PAUSED = "执行未暂停。"
INVALID_LOCATION_FOR_EXTERNAL_APPLIACTION = "无法前往位置。外部应用程序不支持此类位置。"

[ADDITIONAL_RESULT]
ERR_LOGGING_RESULT = "记录附加结果 '%1' 时发生以下错误：\n%2"
ERR_CANNOT_SET_FOR_PARAMETER = "您不能为参数附加结果设置此属性。"
ERR_CANNOT_SET_FOR_CUSTOM_RESULT_ELEMENT = "您不能为作为 AdditionalResult.Elements 集合成员的附加结果设置此属性。"
ERR_MODIFY_PARAMETER_RESULTS = "您不能从 ParameterResults 集合中添加、移动或删除项目。"
ERR_SET_INDETERMINATE = "您不能将检查状态设置为不确定值。"
ERR_MODIFY_ADDITIONAL_RESULT_ELEMENTS = "您不能从 AdditionalResult.Elements 集合中添加、移动或删除项目。"
ERR_SET_TYPE_WHEN_IS_ANY_TYPE = "你只能在 IsAnyType 为 False 时设置类型。"
ERR_NAME_NOT_SPECIFIED = "附加结果没有名称。您必须指定名称表达式，或者要记录的值表达式必须计算为具有名称的对象。"
ERR_LOG_NAME_NOT_SPECIFIED = "附加结果没有名称。您必须指定一个名称或记录一个有名称的对象。"
ERR_LOG_NO_ACTIVE_RESULT = "无法记录额外的结果，因为该步骤当前未在执行。"
IN_PARAMETER_SUFFIX = " [输入]"
OUT_PARAMETER_SUFFIX = " [输出]"
NON_CLONEABLE_OBJECT_FORMAT_STRING = "%1, ID = %2"
STEP_COMMENT = "步骤评论"
STEP_DESCRIPTION = "步骤描述"
REQUIREMENTS="要求"
VIRTUAL_DEVICE_NAME = "虚拟设备名称"
SWITCH_OPERATION = "开关操作"
ROUTE_GROUP_CONNECT = "路由组连接"
ROUTE_GROUP_DISCONNECT = "路由组断开连接"
MULTICONNECT_MODE = "多连接模式"
OPERATION_ORDER = "操作指令"
CONNECTION_LIFETIME = "连接生命周期"
WAIT_FOR_DEBOUNCE = "等待去抖动"
ADVANCED_LOGGING = "高级日志记录"
ADVANCED_&LOGGING_DIALOG = "高级日志记录..."
LOG_INPUT_ONLY = "仅记录输入值"
LOG_OUTPUT_ONLY = "仅记录输出值"
LOGGING_PARTIALLY_SPECIFIED_OUTPUT_ARRAY = "记录部分指定的输出数组"
MULTIPLE_VALUES = "多个值"

[PROPERTY_OBJECT_TYPE]
ERR_ELEMENT_TYPE_VALUE = "当 PropertyObjectType.ValueType 是 PropValType_Array 时，PropertyObjectType.ElementType 不能为 NULL，而当 PropertyObjectType.ValueType 不是 PropValType_Array 时，PropertyObjectType.ElementType 必须为 NULL。"
ERR_NO_TYPE_NAME = "当 PropertyObjectType.ValueType 为 PropValType_NamedType 时，PropertyObjectType.TypeName 不能为空。"
ERR_TYPE_MUST_BE_OBJECT = "容器、数组和命名类型必须是一个对象。"
ERR_TYPE_NOT_OBJECT = "该类型没有指定对象。"

[HEAP_MEMORY_MANAGER]
WARNING_RESTART_APP = "您的堆内存管理器设置将在下次重新启动您的应用程序时生效。"
WARNING_RESTART_APP_TITLE = "堆内存管理器"

[RESOURCE_USAGE_LOGGER]
RESOURCE_USAGE_OUTPUT_MESSAGE_CATEGORY = "NI 数据 - 资源使用情况"
RESOURCE_MESSAGE_TEXT = "资源\"%1\" - %2"
THREAD_PREFIX = "线程："
EXECUTION_PREFIX = "执行："
SyncState_Blocked = "已阻止"
SyncState_InUse = "使用中"
SyncState_Aborted = "中止"
SyncState_TimedOut = "超时"
SyncState_Completed = "完成"
InvalidSyncState = "<无效的同步状态>"

[PROFILER]
PROFILER_MESSAGE_TEXT = "探查器项目\"%1\" - %2"
OUTPUT_MESSAGE_CATEGORY = "NI 数据 - 分析器"
ProfilerState_Blocked = "已阻止"
ProfilerState_InUse = "使用中"
ProfilerState_Aborted = "中止"
ProfilerState_TimedOut = "超时"
ProfilerState_Completed = "完成"
InvalidProfilerState = "<无效的探查器状态>"	 
NON_EXECUTION_THREAD = "<非执行线程>"

[TYPE_CREATION]
FIELD_DEFAULT_NAME = "字段"

[DIRECTORY_ACCESS]
ERR_INVALID_PATH Line0001 = "无效路径：'%1'\n"
ERR_INVALID_PATH Line0002 = "该方法需要一个有效的绝对路径。"

ERR_UNABLE_TO_CREATE_CFG_DIR Line0001 = "无法访问 TestStand 配置目录：'%1'\n"
ERR_UNABLE_TO_CREATE_CFG_DIR Line0002 = "当 TestStand 无法访问或创建 TestStand 配置目录时会发生此错误。"
ERR_UNABLE_TO_CREATE_CFG_DIR Line0003 = "如果目录已经存在，您必须更改权限，更改配置目录的位置 "
ERR_UNABLE_TO_CREATE_CFG_DIR Line0004 = "在工作站选项对话框的首选项页面上，或更改在以下注册表项中指定的目录：\n"
ERR_UNABLE_TO_CREATE_CFG_DIR Line0005 = " HKEY_LOCAL_MACHINE\\SOFTWARE\\National Instruments\\TestStand\\<version>\\CfgLocation\n"
ERR_UNABLE_TO_CREATE_CFG_DIR Line0006 = "有关 TestStand 配置目录的更多信息，请参阅 TestStand 文档。"

ERR_UNABLE_TO_CREATE_PUBLIC_DIR = "无法访问目录：'%1'\n"
ERR_UNABLE_TO_WRITE_PUBLIC_DIR = "写入文件时出错：'%1'\n"

ERR_UNABLE_TO_WRITE_CREATE_PUBLIC_DIR Line0001 = "当 TestStand 无法访问 TestStand 公共目录时发生此错误。\n"
ERR_UNABLE_TO_WRITE_CREATE_PUBLIC_DIR Line0002 = ""下的\"CustomPublicLocation\"字符串值
ERR_UNABLE_TO_WRITE_CREATE_PUBLIC_DIR Line0003 = "\"HKEY_LOCAL_MACHINE\\SOFTWARE\\National Instruments\\TestStand\\<version>\" 注册表项可以指定自定义公共目录位置。\n"
ERR_UNABLE_TO_WRITE_CREATE_PUBLIC_DIR Line0004 = "如果该值不存在或者它的字符串数据为空，TestStand 使用默认的公共目录。"
ERR_UNABLE_TO_WRITE_CREATE_PUBLIC_DIR Line0005 = "有关 TestStand 公共目录的更多信息，请参阅 TestStand 文档。"

[ATTRIBUTES]
ATTRIBUTES_DIALOG_TITLE = "%1 属性"
DEFAULT_ATTRIBUTE_NAMESPACE_NAME = "属性命名空间"
DEFAULT_ATTRIBUTE_NAME = "属性"
EDIT_ATTRIBUTES = "编辑属性..."
MODIFY_ATTRIBUTES = "编辑属性"

NAMESPACE_EXPLANATION = "为选定的 TestStand 对象指定属性。您可以创建一个容器项作为属性命名空间。NI 建议您创建一个唯一命名的容器或容器层次结构，在其下存储您的属性以避免名称冲突. 例如：CompanyName.AttributeCategory.Attribute。"
ROOT_ATTRIBUTE_NAMED_NI_ERR = "名称 'NI' 在根级别保留给 National Instruments。"
SUBPROP_NAME_CONFLICT_ERR = "容器不能同时具有属性和名为 Attributes 的子属性，或同时具有类型属性和名为 TypeAttributes 的子属性。您应该使用属性而不是子属性，或者为 %1 子属性选择不同的名称。"
EDIT_&ATTRIBUTES = "编辑&属性..."
ERR_EDIT_FILE_ATTRIBUTES = "您不能直接编辑 PropertyObjectFile 的属性。您必须改为编辑 PropertyObjectFile.Data 的属性。"
ERR_EDIT_MULTIPLE_STEP_ATTRIBUTES = "You cannot edit the attributes of a step or step subproperty when more than one step is selected."
ROOT_ATTRIBUTE_NAMED_NI = "NI"

[RESULT_LOGGING]
ASYNC_ERROR_DESCRIPTION = "异步写入记录类型 %1 (%2) 时出错。\n%3"

[RESULTLOGRECORDTYPES]
0 = "ResultLogRecordType_NotARecordType"
1 = "ResultLogRecordType_Begin"
2 = "ResultLogRecordType_End"
3 = "ResultLogRecordType_PreUUT"
4 = "ResultLogRecordType_PostUUT"
5 = "ResultLogRecordType_OnTheFlyStepResults"
6 = "ResultLogRecordType_Deleted"

[PRELOADPROGRESSDISPLAY]
PRELOADINGHEADER = "预加载模块..."
FAILEDTOCREATE_ERROR = "无法创建预加载进度对话框。"
ANALYZING = "准备预加载模块..."
PRELOADING = "预加载模块..."
WAITINGFORFIND = "等待查找文件对话框..."
CANCELED_ERROR = "模块预加载已取消。"
CANCELING = "正在取消..."
SEQUENCEFILEPREFIX = "序列文件\t: "
SEQUENCEPREFIX = "序列\t: "
STEPPREFIX = "步骤\t\t: "
MODULEPREFIX = "模块\t\t: "
MODPATHPREFIX = "模块路径\t: "

[EXECUTION_OUTPUT_RECORD_STREAM]
HEADER_STREAM_NAME = "流名称："
FOOTER_RECORDS_TO_DISPLAY = "要显示的记录："
FOOTER_RECORDS_WRITTEN = "写入记录总数："
FOOTER_UPDATE_DISABLED = "报告视图更新当前已禁用。"
FOOTER_ALL_RECORDS = "全部"
ERR_DUPLICATE_STREAM = "此 ExecutionOutputStream 已包含指定的流。"
ERR_STREAM_NOT_FOUND = "此 ExecutionOutputStream 不包含指定的流。"
ERR_INVALID_NUMBER_OF_ROWS_TO_DISPLAY = "要显示的行数必须为非负数，或 -1 表示'无限制'。值 %1 无效。"

[CSV_FILE_OUTPUT_RECORD_STREAM]
DESCRIPTION = "CSV 文件输出记录流"
ERR_EXPECTED_OUTPUT_RECORD_STREAM_TYPE = "预期的 OutputRecordStream 引用、ExecutionOutputRecordStream 引用或指定流名称的字符串。"
ERR_NEW_CSV_FILE_OUTPUT_RECORD_STREAM = "执行新建 CSV 文件输出记录流步骤时出错。"
ERR_FILE_OPEN_MODE = "文件打开模式表达式错误。"
ERR_OUTPUT_RECORD_STREAM_EXPRESSION = "输出记录流表达式错误。"
ERR_FIELD_HEADERS_EXPRESSION = "字段标题表达式错误。"
ERR_FIELD_HEADER_MAPPING_EXPRESSION = "字段标题映射表达式错误。"
ERR_TAG_EXPRESSION = "标签表达式错误。"
ERR_CSV_FILE_PATH_EXPRESSION = "CSV 文件路径表达式错误。"
ERR_STREAM_NAME_EXPRESSION = "流名称表达式错误。"
ERR_RECORDS_TO_DISPLAY_IN_REPORT_VIEW_EXPRESSION = "报告视图表达式中显示的记录出错。"
ERR_EXECUTION_OUTPUT_RECORD_STREAM_EXPRESSION = "执行输出记录流表达式出错。"
ERR_WRITING_RECORD_PROTOTYPE = "写入记录原型时出错。"
ERR_DUPLICATE_FIELD_NAME_1 = "重复的字段名称：'%1'。"
ERR_WRITING_FIELD_HEADERS = "写入字段标题时出错。"
ERR_IN_FIELD_1 = "写入字段‘%1’时出错。"
ERR_INVALID_SEPARATOR_1 = "分隔符 '%1' 无效。"
ERR_NOT_ENOUGH_FIELDS_TO_SATISFY_RANGE_1_2 = "字段 (%1) 不足以满足范围：%2。"
ERR_EMPTY_RECORD = "无法写入空记录。"

[CSV_FILE_INPUT_RECORD_STREAM]
ERR_TAG_NOT_FOUND_1_2 = "在 CSV 文件 '%2' 中找不到标签 '%1'。"
ERR_SKIPPED_BEYOND_END_OF_FILE_1 = "在尝试跳过 %1 行时到达文件末尾。"
ERR_RANGE_MUST_EMPTY_FOR_STRING_OUTPUT = "CsvFileInputRecordStream 错误：无法为字符串输出记录指定范围。"
ERR_NOT_ENOUGH_FIELDS_TO_FILL_FIELD_MAPPING_INDEX_OUT_OF_RANGE = "CSV 输入行中的输入字段不足以满足指定的字段映射。要求的索引 %1，输入行中只有 %2 个字段。\n字段映射：%3\n输入行：'%4'"
ERR_NOT_ENOUGH_RECORD_ELEMNENTS = "指定的记录没有足够的字段 (%1) 满足请求的输出记录范围：'%2'"
ERR_NOT_ENOUGH_FIELDS_TO_FILL_RECORD_RANGE = "输入字段不足，无法满足指定的输出记录范围。\n记录范围：'%1'\n字段映射：%2\n输入行：'%3'"
ERR_NOT_ENOUGH_FIELDS_TO_FILL_LOOKUP_STRINGS = "输入字段 (%1) 不足以填充所有指定的输出字段 (%2)。\n字段映射：%3\n输入行：'%4'"
ERR_WRITING_TO_FIELD_INDEX_1_2_3 = "写入索引 %1 处的字段时出错。\n来自 CSV 文件的记录 = '%2'\n字段 = '%3'\n"
ERR_WRITING_TO_FIELD_INDEX_1_2_3_4_5 = "写入 %1 字段 '%2'（索引 %3）时出错。\n来自 CSV 文件的记录 = '%4'\n字段 = '%5'\n"
ERR_WRITING_TO_FIELD_1_2 = "写入字段 '%1' 时出错。\n值 = '%2'\n"
ERR_CSV_FILE_INPUT_RECORD_STREAM = "执行新 CSV 文件输入记录流步骤时出错。"
ERR_INPUT_RECORD_STREAM_EXPRESSION = "输入记录流表达式错误。"
ERR_CSV_FILE_PATH_EXPRESSION = "CSV 文件路径表达式错误。"
ERR_FIELD_MAPPING_EXPRESSION = "字段映射表达式错误。"
ERR_SCAN_FOR_TAG_EXPRESSION = "扫描标签表达式时出错。"
ERR_SKIP_LINES_EXPRESSION = "跳过行表达式错误。"
ERR_RECORD_PROTOTYPE_EXPRESSION = "记录原型表达式错误。"
ERR_RECORD_PROTOTYPE_DUPLICATE_FIELD_1_2 = "映射 '%1' 将子属性 '%2' 映射到多个字段。"
ERR_RECORD_INVALID_FIELD_TYPE_1_2 = "属性 '%1' ('%2') 的类型对于 InputRecordStream 字段无效。"
ERR_PROTOTYPE_FIELD_DUPLICATES_1 = "多次指定了原型字段 '%1'。"
ERR_PROTOTYPES_DO_NOT_MATCH = "步骤中指定的原型与文件中的原型不匹配。"
ERR_PROTOTYPE_FIELD_MISMATCH_1_2_3 = "原型字段 '%1' 的类型不匹配。需要 %2，找到 %3。"
ERR_PROTOTYPE_FIELD_MISSING_1 = "字段 '%1' 丢失。"
ERR_UNRECOGNIZED_TYPE_NAME_1 = "'%1' 不是有效的字段类型。\n\n（有效类型为 Boolean、String、Float64、Int64、UInt64 和 Enum：<TYPE NAME>。）"
ERR_FIELD_MAPPING_NOT_SUPPORTED_WTIH_PROTOTYPE = "当流有原型时不支持字段映射。"
ERR_CSV_RECORD_PROTOTYPE_ROWS_DO_NOT_MATCH = "CSV 文件中定义原型的行包含不同数量的列。"
ERR_READING_RECORD_PROTOTYPE = "错误读取记录原型。"
ERR_PARSING_RECORD_PROTOTYPE_1_2 = "解析记录原型时出错。\n\n数据类型：%1\n\n字段名称 %2"
ERR_SETTING_FIELD_MAPPING = "设置字段映射时出错。"
ERR_SKIPPING_LINES = "跳行错误。"
ERR_SCANNING_FOR_TAG = "标签扫描错误。"

[WRITE_RECORD]
ERR_WRITE_RECORD = "执行写入记录步骤时出错。"
ERR_OUTPUT_RECORD_STREAM_EXPRESSION = "输出记录流表达式错误。"
ERR_RECORD_EXPRESSION = "记录表达式错误。"
ERR_FIELD_MAPPING_EXREPSSION = "字段映射表达式错误。"

[STREAM_LOOP]
LOOP_RECORD = "记录"
ERR_FIELD_MAPPING_NOT_ALLOWED_WTIH_TYPE_1 = "只有当记录是容器或数组时才能使用字段映射。（找到 %1。）"

[SWEEP_LOOP]
ERR_SWEEP_PARAMETER_DEFINITION_1 = "扫描参数‘%1’的定义错误。"
ERR_CURRENT_RECORD_EXPRESSION = "当前记录表达式错误。"
ERR_SWEEP_PARAMETER_START = "评估扫描参数开始表达式时出错。"
ERR_SWEEP_PARAMETER_STOP = "评估扫描参数停止表达式时出错。"
ERR_SWEEP_PARAMETER_STEP = "评估扫描参数阶跃表达式时出错。"
ERR_SWEEP_PARAMETER_REPRESENTATION_MISMATCH_1 = "不一致的数字表示。%1 的表示必须匹配开始。"
ERR_SWEEP_PARAMETER_NUM_POINTS = "评估扫描参数点数表达式时出错。"
ERR_SWEEP_PARAMETER_CONSTANT = "评估扫描参数常量表达式时出错。"
ERR_SWEEP_PARAMETER_ARRAY = "评估扫描参数数组表达式时出错。"
ERR_SWEEP_PARAMETER_VALUE = "评估扫描参数值表达式时出错。"
ERR_SWEEP_PARAMETER_STREAM_NOT_ALLOWED = "此处不允许输入流策略。"
ERR_SWEEP_PARAMETER_SOURE_1 = "无效的扫描策略 '%1'。"
ERR_SWEEP_PARAMETER_SPECIFICATION_1 = "无效的扫描规范 '%1'。"
ERR_SWEEP_PARAMETER_OPERATION_1 = "无效的扫描参数操作 '%1'。"
ERR_NEED_AT_LEAST_ONE_PARAMETER = "扫描循环需要至少一个扫描参数。"
ERR_EVALUATING_INPUT_STREAM_FIELD_ID = "评估输入流字段（列）标识符时出错。"
ERR_INPUT_NOT_ENABLED = "策略是输入流，但此步骤未启用输入。"
ERR_CANNOT_PREMUTE_WITH_INPUT_ENABLED = "排列扫描参数时无法从流中读取值。"
ERR_INPUT_STREAM_HAS_FIELD_MAPPING_1 = "输入流具有字段映射'%1'。扫描循环步骤中的输入流无法指定字段映射。"
ERR_CREATING_STRATEGY = "创建扫描参数策略时出错。"
ERR_NUMBER_OF_SWEEP_POINTS_DOES_NOT_MATCH_1_2 = "点数 (%1) 与其他参数 (%2) 不匹配。"
ERR_EXTRA_DATA_IN_STREAM = "循环在到达输入流末尾之前完成。"
ERR_DEFINING_STREAM_PARAMETERS = "从输入流读取的参数定义错误。"
ERR_PARAMETER_VALUES_EXHAUSTED = "扫描参数没有更多值。"
ERR_CANNOT_DETERMINE_TYPE_EMPTY_ARRAY_1 = "无法确定参数 '%1' 的空数组类型。"
SETTING_START = "开始"
SETTING_STOP = "停止"
SETTING_STEP = "步骤"
LINEAR = "线性"
LOGARITHMIC = "对数"
ERR_NAN_1 = "%1 的值不能是 NaN。"
ERR_INF_1 = "%1 的值不能是无穷大。"
ERR_ZERO_1_2 = "%2 参数策略中的 %1 值不能为 0。"
ERR_START_STOP_SIGN_MISMATCH = "起始值和终止值不能有不同的符号。"
ERR_NUM_POINTS_AT_LEAST_TWO_1 = "点数 (%1) 必须等于或大于 2。"
ERR_NUM_POINTS_TOO_LARGE_1_2 = "点数 (%1) 必须小于 %2。"
ERR_STEP_LE_ZERO = "对数参数策略步长值不能小于等于0。"
ERR_STEP_EQ_ONE = "在对数参数策略中步长值不能等于 1。"
ERR_STEP_LE_ONE = "整数对数参数策略步长值不能小于等于1。"
ERR_CALC_NUM_POINTS_EXCEPTION_1_2_3_4 = "在 %4 参数策略中计算设置开始 = %1、停止 = %2 和步骤 = %3 的点数的算术异常。"
LOOP_RECORD = "记录"

[IOCONFIGURATION_RUNTIME_FRAMEWORK]
ERR_SESSION_EXPRESS_INVALID = "会话表达式错误。"
ERR_EXPORT_VARIABLE_EXPRESS_INVALID = "变量表达式错误。"

[STREAM_SWEEP_LOOP_ERRORS]
ERR_INPUT_RECORD_EXPRESSION = "输入记录表达式错误。"
ERR_OUTPUT_RECORD_EXPRESSION = "输出记录表达式错误。"
ERR_INPUT_FIELD_MAPPING_EXPRESSION = "输入字段映射表达式错误。"
ERR_OUTPUT_FIELD_MAPPING_EXPRESSION = "输出字段映射表达式错误。"
ERR_NOT_INPUT_RECORD_STREAM = "对象没有实现 InputRecordStream 接口。"
ERR_INPUT_RECORD_STREAM_EXPRESSION = "输入记录流表达式错误。"
ERR_READING_RECORD = "读取记录错误。"
ERR_ITERATION_EXPRESSION = "迭代表达式错误。"
ERR_OUTPUT_RECORD_STREAM_EXPRESSION = "输出记录流表达式错误。"
ERR_NULL_OUTPUT_RECORD_STREAM_REFERENCE = "指定的输出流为空。"
ERR_NOT_OUTPUT_RECORD_STREAM = "对象没有实现 OutputRecordStream 或 ExecutionOutputRecordStream 接口。"
ERR_WRITING_RECORD = "写入记录时出错。"
ERR_CLOSING_INPUT_STREAM = "关闭输入流时出错。"
ERR_CLOSING_OUTPUT_STREAM = "关闭输出流时出错。"
ERR_UNKNOWN_FIELD_1 = "未知字段‘%1’。"

[PARAMETERIZED_INPUT_RECORD_STREAM]
ERR_EVALUATING_PARAMETER_1 = "评估参数 '%1' 时出错。"
ERR_CANNOT_PREMUTE_WITH_UNBOUNDED_PARAMETER = "无界扫描参数无法改变。"
ERR_OVERFLOW_CALCULATING_NUMBER_OF_SWEEP_POINTS = "计算点数时发生算术溢出。"
ERR_CANNOT_SKIP_BACKWARDS = "要跳过的记录数不能为负数。"

[PYTHON_ADAPTER_INTERNAL]
SUPPORTED_PYTHON_VERSIONS = "3.9、3.8、3.7、3.6、2.7"
