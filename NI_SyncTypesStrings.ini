;; NI_SyncTypesStrings.ini - NI TestStand 同步步骤类型字符串
;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"

[NI_SYNCHRONIZATION_STEP_TYPES]
MENU_NAME = "同步"
ADV_MENU_NAME = "高级"
REMOTE_CONNECT_TO_TSAUTOMGR_FAILED Line0001 = "无法连接到远程机器 '%1' 上的 TestStand TSAutoMgr 服务器。"
REMOTE_CONNECT_TO_TSAUTOMGR_FAILED Line0002 = "您必须在远程主机上安装 TestStand 并通过 dcomcnfg 配置 TSAutoMgr.exe 程序以允许访问。"
REMOTE_CONNECT_TO_TSAUTOMGR_FAILED Line0003 = "程序 dcomcnfg.exe 位于 Windows 系统目录（NT 上为 system32）。"
CONNECT_TO_TSAUTOMGR_FAILED = "无法连接到 TestStand TSAutoMgr 服务器。"
CONNECT_TO_TSSSYNC_FAILED = "无法连接到 TestStand TSSync 服务器。"
ERR_CANT_GET_SYNC_OBJ_WITH_EMPTY_NAME Line0001 = "无法按名称访问同步对象。"
ERR_CANT_GET_SYNC_OBJ_WITH_EMPTY_NAME Line0002 = "您必须通过引用访问具有空名称的同步对象。要使用未命名的同步对象，请在创建对象时，"
ERR_CANT_GET_SYNC_OBJ_WITH_EMPTY_NAME Line0003 = "将生命周期指定为\"使用对象引用\"，并使用该引用而不是名称来对对象执行操作。"
ERR_NAMED_IS_WRONG_TYPE = "\"%1\" 不是 %2。"
ERR_NAMED_DOES_NOT_EXIST = "%1，\"%2\"，不存在。"
ERR_REF_NULL = "对 %1 的引用为空。"
ERR_REF_IS_WRONG_TYPE = "指定的对象引用不是 %1。"
ERR_CANNOT_STORE_TO_PARENTLESS_CONTAINER Line0001 = "无法将数据对象存储到没有父对象的容器对象中。因为来自队列或通知的数据对象是一个"
ERR_CANNOT_STORE_TO_PARENTLESS_CONTAINER Line0002 = "容器对象，目标对象必须是引用对象或容器对象。如果目标对象是引用"
ERR_CANNOT_STORE_TO_PARENTLESS_CONTAINER Line0003 = "object, TestStand 从队列或通知中分配给它一个对数据对象的引用。如果目标对象是一个容器"
ERR_CANNOT_STORE_TO_PARENTLESS_CONTAINER Line0004 = "对象，它必须有一个父对象。在这种情况下，TestStand通过获取目标的父对象来用数据对象替换目标对象"
ERR_CANNOT_STORE_TO_PARENTLESS_CONTAINER Line0005 = "对象，然后从父对象中删除目标对象，并用数据对象替换目标对象。"

[NI_SEMAPHORE_STEP_TYPE]
SEMAPHORE = "信号量"
CREATE = "创建"
ACQUIRE = "获取（递减）"
RELEASE = "释放（增量）"
GET_STATUS = "获取状态"
EDIT_DLG_CAPTION = "信号量步骤配置"
BROWSE_BTN = "浏览..."
SEM_NAME_EXPR_LBL = "信号量&名称表达式："
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
EXISTS_EXPR_LBL = "信号量存在&xists？（可选输出）："
SEM_LIFETIME_LBL = "信号量参考 &Lifetime:"
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
ACQUIRE_LIFETIME_LBL = "获得 &Lifetime:"
NAME_OR_REF_EXPR_LBL = "信号量&名称或引用表达式："
AUTO_RELEASE = "&自动释放"
RELEASE_WARNING Line0001 = "警告：如果您选择自动释放选项，请不要使用释放"
RELEASE_WARNING Line0002 = "获取信号量。要手动释放一个"
RELEASE_WARNING Line0003 = "自动发布获取，将对象引用生命周期指定为"
RELEASE_WARNING Line0004 = "自动释放选项并将对象引用变量设置为'无'到"
RELEASE_WARNING Line0005 = "释放信号量。"

TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
OPERATION_LBL = "操作&操作："
INITIAL_COUNT_IN_LBL = "&Initial Semaphore Count (Maximum Simultaneous Non-Blocking Acquires)\n（将此设置留空以使用现有信号量设置的设置）："
INITIAL_COUNT_OUT_LBL = "初始&信号量计数（可选输出）："
NUM_THREADS_WAITING_LBL = "等待获取信号量的线程数（可选输出）："
CURRENT_COUNT_LBL = "&当前计数（可选输出）："
DEF_STEP_NAME = "信号量"
MENU_ITEM_NAME = "信号灯"
EDIT_STEP_MENU_NAME = "&配置信号量..."
SYNTAX_ERR_SEM_NAME = "'信号量名称'表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_INITIAL_COUNT = "‘初始信号量计数’表达式中的语法错误"
SYNTAX_ERR_SEM_NAME_OR_REF = "'信号量名称或引用'表达式中的语法错误"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_SEM_EXISTS = "'信号量存在'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING = "'等待线程数'表达式中的语法错误"
SYNTAX_ERR_CURRENT_COUNT = "'当前计数'表达式中的语法错误"
ERR_SEM_NOT_EXIST_AND_NO_INITIAL_COUNT Line0001 = "信号量\"%s\"不存在，初始计数为"
ERR_SEM_NOT_EXIST_AND_NO_INITIAL_COUNT Line0002 = "未指定。指定现有信号量的名称或指定"
ERR_SEM_NOT_EXIST_AND_NO_INITIAL_COUNT Line0003 = "创建新信号量的初始计数。"
ERR_SEM_EXISTS_BUT_INITIAL_COUNT_DIFFERS Line0001 = "信号量\"%s\"已经存在，初始值不同"
ERR_SEM_EXISTS_BUT_INITIAL_COUNT_DIFFERS Line0002 = "计数。"
ERR_RELEASE_EXCEEDS_MAX_COUNT = "释放操作超过信号量的最大计数。"

;;额外的结果提示
SEMAPHORE_NAME = "信号量名称或引用表达式"
OPERATION="操作"
ALREADY_EXISTS_HINT = "已经存在？"
SEMAPHORE_REFERENCE_LIFETIME_HINT = "信号量引用生命周期"
INITIAL_SEMAPHORE_COUNT_HINT = "初始信号量计数"
AUTO_RELEASE_HINT = "自动释放"
ACQUIRE_LIFETIME_HINT = "获得生命周期"
TIMEOUT="超时"
DISABLED="禁用"
SEMAPHORE_EXISTS_HINT = "信号量存在？"
NUMBER_OF_THREAD_WAITING_TO_ACQUIRE_THIS_SEMAPHORE_HINT = "等待获取此信号量的线程数"
CURRENT_COUNT_HINT = "当前计数"

[NI_SEMAPHORE_STEP_TYPE_OPER_NAME]
0 = "创建"
1 ="获取"
2 = "释放"
3 = "获取状态"

[NI_BATCH_SYNC_STEP_TYPE]
DEF_STEP_NAME = "批量同步"
MENU_ITEM_NAME = "批量同步"
EDIT_STEP_MENU_NAME = "&配置批量同步..."
EDIT_DLG_CAPTION = "批量同步步骤配置"
EXPLANATION Line0001 = "在创建序列时使用这些操作"
EXPLANATION Line0002 = "支持批处理。这些操作什么都不做"
EXPLANATION Line0003 = "如果它们所在的序列未作为批处理的一部分运行。"
OPERATION_LBL = "操作&操作："
ENTER_SYNC_SECT = "进入同步部分"
EXIT_SYNC_SECT = "退出同步部分"
EXIT_ALL_SYNC_SECT = "退出当前序列中的所有部分"
BROWSE_BTN = "浏览..."
SECTION_NAME_ENTER_LBL = "部分 &Name：\n（留空以指定与步骤相对应的唯一名称。）"
SECTION_NAME_EXIT_LBL = "部分 &Name：\n（留空以退出最嵌套的部分。）"
SECTION_TYPE_LBL = "&章节类型："
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
SECT_TYPE_SERIAL = "串行（一次一个线程）"
SECT_TYPE_PARALLEL = "并行（所有线程同时进入）"
SECT_TYPE_ONE_THREAD_ONLY = "只有一个线程（一个线程进入，其余线程跳到退出）"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_SECT_NAME = "‘节名’表达式中的语法错误"
;;额外的结果提示
SECTION_NAME = "章节名称"
OPERATION="操作"
TIMEOUT="超时"
DISABLED="禁用"
SECTION_TYPE = "章节类型"

[NI_BATCH_SYNC_STEP_TYPE_OPER_NAME]
0 = "进入"
1 ="退出"
2 = "全部退出"

[NI_BATCH_SYNC_STEP_TYPE_SECT_TYPE_NAME]
0 = "无"
1 ="串行"
2 ="并行"
3 = "单线程"

[NI_BATCH_STEP_TYPE]
ONE_THREAD_ONLY_COULD_NOT_JUMP_TO_EXIT Line0001 = "找不到要分支到的有效退出操作。"
ONE_THREAD_ONLY_COULD_NOT_JUMP_TO_EXIT Line0002 = "确认此输入操作存在有效的退出操作，并且没有无效的"
ONE_THREAD_ONLY_COULD_NOT_JUMP_TO_EXIT Line0003 = "进入或退出操作嵌套在它们之间。"
ONE_THREAD_ONLY_THREAD_HAD_RTE Line0001 = "进入单线程同步部分的线程"
ONE_THREAD_ONLY_THREAD_HAD_RTE Line0002 = "线程正在等待报告一个运行时错误，同时在该部分内。"
ONE_THREAD_ONLY_THREAD_NEVER_EXITED Line0001 = "进入单线程同步部分的线程"
ONE_THREAD_ONLY_THREAD_NEVER_EXITED Line0002 = "线程正在等待完成而不退出该部分。如果线程生成运行时错误，就会发生这种情况 "
ONE_THREAD_ONLY_THREAD_NEVER_EXITED Line0003 = "在单线程同步部分中。"
PENDING_ENTER_WITH_SAME_NAME_ALREADY_EXISTS = "一个同名的 Enter 操作已经在等待这个线程。"
BATCH = "批次"
INVALID_EXIT_OPER = "退出操作与最近的进入操作不对应。"
EXIT_NOT_IN_SAME_CONTEXT_AS_ENTER = "退出操作与最近的进入操作不在同一个序列调用堆栈中。"
ERR_PENDING_ENTER_WITH_SAME_NAME_BUT_DIFF_TYPE = "存在一个名称相同但部分类型不同的回车操作。"
DEF_STEP_NAME = "批处理规范"
MENU_ITEM_NAME = "批次说明"
EDIT_STEP_MENU_NAME = "&配置批次规范..."
EDIT_DLG_CAPTION = "批量规范步骤配置"
EXPLANATION Line0001 = "使用这些操作来创建和定义一个批次。"
EXPLANATION Line0002 = "然后您可以同步属于批处理的线程"
EXPLANATION Line0003 = "使用批处理同步步骤或步骤属性。流程模型"
EXPLANATION Line0004 = "通常会创建批次。"
OPERATION_LBL = "操作&操作："
CREATE = "创建"
ADD_THREAD = "添加线程"
REMOVE_THREAD = "删除线程"
GET_STATUS = "获取状态"
BROWSE_BTN = "浏览..."
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
NAME_EXPR_LBL = "批处理名称表达式："
NAME_OR_REF_EXPR_LBL = "批处理名称或参考表达式："
LIFETIME_LBL = "批次参考 &Lifetime:"
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
DEFAULT_BATCH_SYNC_LBL = "&默认批量同步："
DEFAULT_BATCH_SYNC_OUT_LBL = "&默认批量同步（可选输出）："
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
EXISTS_EXPR_LBL = "批量存在(&E)？（可选输出）："
THREAD_REF_LBL = "对象和对线程的引用："
ORDER_NUM_LBL = "&Order Number（最低编号线程最先）："
NUM_THREADS_WAITING_LBL = "在同步部分等待的线程数（可选输出）："
NUM_THREADS_IN_BATCH_LBL = "&Batch 中的线程数（可选输出）："
SYNTAX_ERR_NAME = "‘批次名称’表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_NAME_OR_REF = "'批次名称或参考'表达式中的语法错误"
SYNTAX_ERR_THREAD_REF = "'Reference to Thread' 表达式中的语法错误"
SYNTAX_ERR_EXISTS = "'批次存在'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING = "'等待线程数'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_IN_BATCH = "'批处理线程数'表达式中的语法错误"
SYNTAX_ERR_ORDER_NUM = "'订单号'表达式中的语法错误"
SYNTAX_ERR_DEFAULT_BATCH_SYNC = "'默认批同步'表达式中的语法错误"
ERR_OBJECT_SPECIFIED_IS_NOT_A_THREAD = "线程引用表达式中指定的对象不是线程。"
;;额外的结果提示
OPERATION="操作"
BATCH_NAME_HINT = "批次名称或参考表达式"
ALREADY_EXISTS_HINT = "已经存在？"
BATCH_REFERENCE_LIFETIME_HINT = "批次引用生命周期"
DEFAULT_BATCH_SYNCHRONIZATION_HINT = "默认批量同步"
THREAD_REFERENCE_HINT = "话题参考"
ORDER_NUMBER_HINT = "订单号"
BATCH_EXISTS_HINT = "批次存在？"
NUMBER_OF_THREAD_WAITING_AT_SYCHRONIZED_SECTIONS_HINT = "在同步部分等待的线程数"
NUMBER_OF_THREADS_IN_BATCH_HINT = "批处理线程数"

[NI_BATCH_DEFAULT_BATCH_SYNC_LBLS]
0 ="不同步"
1 ="串行（一次一个线程）"
2 = "并行（所有线程同时进入）"
3 ="仅一个线程（一个线程执行步骤，其余线程跳过）"
UNKNOWN = "<未知设置>"

[NI_BATCH_STEP_TYPE_OPER_NAME]
0 = "创建"
1 = "添加线程"
2 = "删除线程"
3 = "获取状态"

[NI_MUTEX_STEP_TYPE]
MUTEX = "锁定"
DEF_STEP_NAME = "锁定"
MENU_ITEM_NAME = "锁定"
EDIT_STEP_MENU_NAME = "&配置锁..."
CREATE = "创建"
LOCK = "锁定"
UNLOCK = "提前解锁"
GET_STATUS = "获取状态"
EDIT_DLG_CAPTION = "锁步配置"
OPERATION_LBL = "操作&操作："
BROWSE_BTN = "浏览..."
UNLOCK_MSG Line0001 = "使用此操作可以在锁操作生命周期指定的时间之前解锁锁。"
UNLOCK_MSG Line0002 = "在嵌套锁定操作的情况下，该操作适用于最近的锁定操作。"
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
NUM_THREADS_WAITING_LBL = "Number of Threads &Waiting to Lock 锁（可选输出）："
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
MUTEX_NAME_EXPR_LBL = "锁定表达式并命名："
CREATE_IF_DOES_NOT_EXIST_LBL = "&Create If Does not Exist (Uses 'Same as Execution' Lock Reference Lifetime)"
MUTEX_LIFETIME_LBL = "锁定参考 &Lifetime:"
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
NAME_OR_REF_EXPR_LBL = "锁定名称或参考表达式："
NAME_OR_REF_EXPR_LOCK_LBL = "锁定 &Name 或引用表达式（传递一个数组以锁定多个锁）："
LOCK_LIFETIME_LBL = "锁定操作 &Lifetime：（注意：这与 Lock Reference Lifetime 不同。）"
EXISTS_EXPR_LBL = "锁定存在&xists？（可选输出）："
SYNTAX_ERR_MUTEX_NAME = "'锁定名称'表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_MUTEX_NAME_OR_REF = "'锁定名称或引用'表达式中的语法错误"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_MUTEX_EXISTS = "'锁定存在'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING = "'等待线程数'表达式中的语法错误"
ERR_UNLOCKED_MUTEX_BUT_DIDNT_OWN = "试图解锁未被该线程锁定的锁。"
ERR_DEADLOCK = "检测到死锁。锁上的锁操作中止。以下锁和线程受到影响：\n"
FULL_DEADLOCK_DISPLAY_NAME_FMT = "进程 %3 中机器 '%2' 上的'%1'"
PROCESS_DEADLOCK_DISPLAY_NAME_FMT = "进程 %2 中的'%1'"
NAME_ONLY_DEADLOCK_DISPLAY_NAME_FMT = "'%1'"
DEADLOCK_ELAB_MSG_FMT = "线程 %1 在尝试获取锁 %3 时有锁 %2。"
UNNAMED_MUTEX_NAME = "没有名字"
OWNER_SEPARATOR = ", "
;;额外的结果提示
LOCK_NAME = "锁定名称或引用表达式"
OPERATION="操作"
ALREADY_EXISTS_HINT = "已经存在？"
LOCK_REFERENCE_LIFETIME_HINT = "锁定引用生命周期"
CREATE_LOCK_HINT = "创建锁"
LOCK_OPERATION_LIFETIME_HINT = "锁定操作生命周期"
TIMEOUT="超时"
DISABLED="禁用"
LOCK_EXISTS_HINT = "锁存在？"
NUMBER_OF_THREAD_WAITING_TO_LOCK_THE_LOCK_HINT = "等待获取锁的线程数"

[NI_MUTEX_STEP_TYPE_OPER_NAME]
0 = "创建"
1 ="锁定"
2 = "提前解锁"
3 = "获取状态"

[NI_WAIT_STEP_TYPE]
DEF_STEP_NAME = "等待"
MENU_ITEM_NAME = "等待"
EDIT_STEP_MENU_NAME = "&配置等待..."
EDIT_DLG_CAPTION = "等待步骤配置"
SPEC_BY_SEQCALL_LBL = "通过 &Sequence Call 指定（必须在当前序列中）"
SPEC_BY_THREAD_REF_LBL = "通过对象引用指定线程(&F)"
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
SEQ_CALL_NONE_ITEM = "<当前序列中没有多线程序列调用>"
SEQ_CALL_NONE_SELECTED_ITEM = "<选择序列调用>"
ERR_WAITING_FOR_SEQ_CALL = "等待步骤试图等待尚未运行或不是多线程序列调用的序列调用。"
SYNTAX_ERR_IN_THREAD_REF_EXPR = "'线程引用'表达式中的语法错误"
SYNTAX_ERR_IN_EXE_REF_EXPR = "'执行引用'表达式中的语法错误"
SYNTAX_ERR_IN_TIMEOUT_EXPR = "'超时'表达式中的语法错误"
BROWSE_BTN = "浏览..."
TIME_INTERVAL = "时间间隔"
TIME_MULTIPLE = "时间倍数"
THREAD = "线程"
EXECUTION="执行"
WAIT_FOR_LBL = "&等待："
MULTIPLE = "多个"
TIME_INTERVAL_LBL = "指定要等待的时间（&Amount）（以秒为单位）："
TIME_MULTIPLE_LBL = "指定时间倍数（以秒为单位）："
TIME_MULTIPLE_HELP = "该步骤会一直等待，直到内部计时器的值变成您指定时间的倍数。"
SYNTAX_ERR_IN_TIME_INTERVAL_EXPR = "'时间间隔'表达式中的语法错误"
SYNTAX_ERR_IN_TIME_MULTIPLE_EXPR = "'时间倍数'表达式中的语法错误"
UNSPECIFIED = "未指定"
EXE_REF_LBL = "通过对象引用指定执行(&F)"
ERR_TIME_INTERVAL_NEGATIVE = "时间间隔必须 >= 0。"
ERR_TIME_MULTIPLE_NEGATIVE = "时间倍数必须 >= 0。"
ERR_OBJECT_SPECIFIED_IS_NOT_A_THREAD = "线程引用表达式中指定的对象不是线程。"
ERR_OBJECT_SPECIFIED_IS_NOT_AN_EXEC = "执行引用表达式中指定的对象不是执行。"
;;额外的结果提示
OPERATION="操作"
TIME_TO_WAIT = "等待时间"
;;在主要部分重复 -> TIME_MULTIPLE = "Time Multiple"
WAIT_FOR = "等待"
TIMEOUT="超时"
DISABLED="禁用"

[NI_WAIT_STEP_TYPE_TARGET_NAME]
0 = "时间间隔"
1 = "时间倍数"
2 = "线程"
3 ="执行"

[NI_RENDEZVOUS_STEP_TYPE]
RENDEZVOUS = "会合"
DEF_STEP_NAME = "会合"
MENU_ITEM_NAME = "约会"
EDIT_STEP_MENU_NAME = "&配置会合..."
EDIT_DLG_CAPTION = "集合步骤配置"
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
CREATE = "创建"
GET_STATUS = "获取状态"
OPERATION_LBL = "操作&操作："
BROWSE_BTN = "浏览..."
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
NUM_THREADS_WAITING_LBL = "等待集合的线程数（可选输出）："
RENDEZVOUS_NAME_EXPR_LBL = "会合点 &Name 表达式："
RENDEZVOUS_LIFETIME_LBL = "会合参考 &Lifetime："
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
EXISTS_EXPR_LBL = "会合点 E&Xists? (可选输出):"
NAME_OR_REF_EXPR_LBL = "集合点&名称或参考表达式："
RENDEZVOUS_COUNT_IN_LBL = "Number &of Threads Per Rendezvous\n（留空以使用现有的集合点设置）："
RENDEZVOUS_COUNT_OUT_LBL = "每个集合的线程数量&#（可选输出）："
SYNTAX_ERR_RENDEZVOUS_NAME = "'集合点名称'表达式中的语法错误"
SYNTAX_ERR_RENDEZVOUS_NAME_OR_REF = "'集合点名称或引用'表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_RENDEZVOUS_COUNT = "‘每个集合点的线程数’表达式中的语法错误"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_RENDEZVOUS_EXISTS = "'Rendezvous Exists' 表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING = "'等待线程数'表达式中的语法错误"
ERR_RENDEZ_EXISTS_BUT_COUNT_DIFFERS Line0001 = "集合点，\"%s\"，已经存在，每个集合点的线程数不同 "
ERR_RENDEZ_EXISTS_BUT_COUNT_DIFFERS Line0002 = "设置。"
ERR_RENDEZ_NOT_EXIST_AND_NO_COUNT Line0001 = "集合点\"%s\"不存在，每个集合点的线程数是"
ERR_RENDEZ_NOT_EXIST_AND_NO_COUNT Line0002 = "未指定。指定现有集合点的名称，或指定"
ERR_RENDEZ_NOT_EXIST_AND_NO_COUNT Line0003 = "创建新集合点的每个集合点的线程数。"
ERR_INVALID_RENDEZ_COUNT = "每个集合点的线程数设置无效。该值必须大于零。"
;;额外的结果提示
RENDEZVOUS_NAME = "集合点名称或引用表达式"
OPERATION="操作"
ALREADY_EXISTS_HINT = "已经存在？"
RENDEZVOUS_REFERENCE_LIFETIME_HINT = "会合参考生命周期"
NUMBER_OF_THREADS_PER_RENDEZVOUS_HINT = "每个集合的线程数"
TIMEOUT="超时"
DISABLED="禁用"
RENDEZVOUS_EXISTS_HINT = "会合点存在？"
NUMBER_OF_THREAD_WAITING_TO_LOCK_THE_LOCK_HINT = "等待获取锁的线程数"

[NI_RENDEZVOUS_STEP_TYPE_OPER_NAME]
0 = "创建"
1 ="集合"
2 = "获取状态"

[NI_QUEUE_STEP_TYPE]
QUEUE = "队列"
CREATE = "创建"
ENQUEUE = "排队"
DEQUEUE = "出队"
FLUSH = "同花顺"
GET_STATUS = "获取状态"
DEF_STEP_NAME = "队列"
MENU_ITEM_NAME = "队列"
EDIT_STEP_MENU_NAME = "&配置队列..."
EDIT_DLG_CAPTION = "队列步骤配置"
OPERATION_LBL = "操作&操作："
BROWSE_BTN = "浏览..."
MAX_SIZE_IN_LBL = "&Maximum Number of Elements (A value <= 0 means unbounded)\n（留空以使用现有队列的设置）："
MAX_SIZE_OUT_LBL = "&最大元素数（可选输出）："
CURRENT_SIZE_LBL = "&Elements 的数量（可选输出）："
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
NUM_THREADS_WAITING_ENQUEUE_LBL = "等待入队的线程数&ber（可选输出）："
NUM_THREADS_WAITING_DEQUEUE_LBL = "等待出队的线程数（可选输出）："
LIFETIME_LBL = "队列参考 &Lifetime:"
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
NAME_EXPR_LBL = "队列&名称表达式："
NAME_OR_REF_EXPR_LBL = "队列名称或参考表达式："
NAME_OR_REF_EXPR_LBL_WITH_ARRAY = "队列 &Name 或引用表达式（传递数组以从第一个可用队列中出队）："
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
EXISTS_EXPR_LBL = "队列存在&xists？（可选输出）："
FULL_QUEUE_OPT_LBL = "如果队列已满&:"
BY_REF_LBL = "&S 按引用而不是按值存储"
ENQUEUE_DATA_EXPR_LBL = "要入队的新元素&queue："
DEQUEUE_DATA_EXPR_LBL = "存储元素的位置&cation（可选输出）："
ARRAY_OUT_DATA_EXPR_LBL = "存储队列元素数组的位置&cation（可选输出）："
STATUS_ARRAY_OUT_DATA_EXPR_LBL = "存储和队列元素数组的位置（可选输出）："
FULLQUEUE_WAIT = "等待"
FULLQUEUE_DISCARD_FRONT = "丢弃前面的元素"
FULLQUEUE_DISCARD_BACK = "丢弃返回元素"
FULLQUEUE_DONT_ENQUEUE = "不排队"
ENQUEUE_LOC_LBL = "&插入："
DEQUEUE_LOC_LBL = "出列 &From:"
FRONT_OF_QUEUE = "队列前面"
BACK_OF_QUEUE = "队列后面"
REMOVE_ELEMENT_LBL = "移除元素(&V)"
WHICH_QUEUE_LBL = "&Which Queue?（可选输出）\n（指定多个队列时返回数组偏移量）："
SYNTAX_ERR_NAME = "'队列名称'表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_MAX_SIZE = "'最大元素数'表达式中的语法错误"
SYNTAX_ERR_NAME_OR_REF = "'队列名称或引用'表达式中的语法错误"
SYNTAX_ERR_QUEUE_EXISTS = "'队列存在'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING_ENQUEUE = "'等待入队的线程数'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING_DEQUEUE = "'等待出队的线程数'表达式中的语法错误"
SYNTAX_ERR_NEW_ELEMENT_EXPR = "'新元素'表达式中的语法错误"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_STORAGE_LOC = "'存储元素的位置'表达式中的语法错误"
SYNTAX_ERR_WHICH_QUEUE = "'哪个队列'中的语法错误？表达"
SYNTAX_ERR_ELEMENTS_STORAGE_LOC = "'存储元素的位置'表达式中的语法错误"
SYNTAX_ERR_CURRENT_SIZE = "'元素数'表达式中的语法错误"
ERR_QUEUE_EXISTS_BUT_SIZE_LIMITS_DIFFERS Line0001 = "队列，\"%s\"，已经存在，具有不同的'最大元素数' "
ERR_QUEUE_EXISTS_BUT_SIZE_LIMITS_DIFFERS Line0002 = "设置。"
ERR_QUEUE_NOT_EXIST_AND_NO_SIZE_LIMIT Line0001 = "队列\"%s\"不存在，'最大元素数'设置为"
ERR_QUEUE_NOT_EXIST_AND_NO_SIZE_LIMIT Line0002 = "未指定。指定现有队列的名称，或指定"
ERR_QUEUE_NOT_EXIST_AND_NO_SIZE_LIMIT Line0003 = "创建新队列的最大元素数。"
ERR_LOCATION_TO_STORE_QUEUE_ELEMENTS_TYPE_MISMATCH Line0001 = "为了将队列的元素存储在一个数组中，该数组和"
ERR_LOCATION_TO_STORE_QUEUE_ELEMENTS_TYPE_MISMATCH Line0002 = "所有队列元素必须具有相同的基本类型。"
ERR_LOCATION_TO_STORE_QUEUE_ELEMENTS_NOT_ARRAY = "存储队列元素的属性必须是数组。"
ERR_LOCATION_TO_STORE_ELEMENT_HAS_WRONG_TYPE = "存储队列元素的位置没有兼容的类型。"
ERR_UNEXPECTED_REPRESENTATION = "存储队列元素的位置具有未知或意外的表示。运行 TestStand 版本选择器以确认您使用的是正确版本的 TSSync.dll 或联系 National Instruments 以获得支持。"
;;额外的结果提示
QUEUE_NAME = "队列名称或引用表达式"
OPERATION="操作"
ALREADY_EXISTS_HINT = "已经存在？"
QUEUE_REFERENCE_LIFETIME_HINT = "队列引用生命周期"
NEW_ELEMENT_HINT = "新元素"
TIMEOUT="超时"
DISABLED="禁用"
DEQUEUED_ELEMENT_HINT = "出队元素"
QUEUE_EXISTS_HINT = "队列存在？"
NUMBER_OF_THREAD_WAITING_TO_ENQUEUE_HINT = "等待入队的线程数"
NUMBER_OF_THREAD_WAITING_TO_DEQUEUE_HINT = "等待出列的线程数"
MAXIMUM_NUMBER_OF_ELEMENTS_HINT = "元素的最大数量"
NUMBER_OF_ELEMENTS_HINT = "元素数量"
QUEUE_ELEMENTS_HINT = "队列元素"

[NI_QUEUE_STEP_TYPE_OPER_NAME]
0 = "创建"
1 ="入队"
2 ="出队"
3 ="刷新"
4 = "获取状态"

[NI_NOTIFICATION_STEP_TYPE]
NOTIFICATION = "通知"
DEF_STEP_NAME = "通知"
MENU_ITEM_NAME = "通知"
EDIT_STEP_MENU_NAME = "&配置通知..."
EDIT_DLG_CAPTION = "通知步骤配置"
CREATE = "创建"
SET="设置"
CLEAR = "清除"
PULSE="脉冲"
WAIT="等待"
GET_STATUS = "获取状态"
LIFETIME_LBL = "通知参考 &Lifetime:"
LIFETIME_SEQUENCE = "与序列相同"
LIFETIME_THREAD = "与线程相同"
LIFETIME_REFERENCE = "使用对象引用"
LIFETIME_EXECUTION = "与执行相同"
NAME_EXPR_LBL = "通知&名称表达式："
ALREADY_EXISTS_EXPR_LBL = "已经存在&xists？（可选输出）："
EXISTS_EXPR_LBL = "通知存在(&X)？（可选输出）："
NAME_OR_REF_EXPR_LBL = "通知&名称或引用表达式："
NAME_OR_REF_EXPR_LBL_WITH_ARRAY = "通知名称或引用表达式（传递数组以等待多个通知）："
DATA_EXPR_LBL = "数据和值（可选）："
DATA_OUT_EXPR_LBL = "存储数据的位置&cation（可选输出）："
STATUS_DATA_OUT_EXPR_LBL = "存储数据的位置&数据（可选输出）："
BROWSE_BTN = "浏览..."
OPERATION_LBL = "操作&操作："
BY_REF_LBL = "按引用而不是按值存储数据(&A)"
TIMEOUT_ENABLED_LBL = "&超时已启用"
TIMEOUT_UNITS_LBL = "超时&表达式（秒）"
TIMEOUT_CAUSES_RTE_LBL = "超时导致&运行时错误"
AUTO_CLEAR_LBL = "通知一个线程后自动清除(&C)"
PULSE_ONE = "通知第一个等待线程（如果有的话）"
PULSE_ALL = "通知所有等待线程（如果有的话）"
WHICH_NOTIF_LBL = "&Which Notification?（可选输出）\n（当你指定多个通知时返回数组偏移量）："
NUM_THREADS_WAITING_LBL = "等待通知的线程数（可选输出）："
IS_SET_LBL = "是否&Set？（可选输出）："
IS_AUTOCLEAR_LBL = "A&uto 清除了吗？（可选输出）："
SYNTAX_ERR_NAME = "'通知名称'表达式中的语法错误"
SYNTAX_ERR_ALREADY_EXISTS = "'已经存在'表达式中的语法错误"
SYNTAX_ERR_LIFETIME_REF = "'生命周期引用'表达式中的语法错误"
SYNTAX_ERR_NAME_OR_REF = "'通知名称或引用'表达式中的语法错误"
SYNTAX_ERR_DATA_VALUE = "'数据值'表达式中的语法错误"
SYNTAX_ERR_LOC_STORE_DATA = "'存储数据的位置'表达式中的语法错误"
SYNTAX_ERR_WHICH_NOTIF = "'Which Notification' 表达式中的语法错误"
SYNTAX_ERR_TIMEOUT = "'超时'表达式中的语法错误"
SYNTAX_ERR_NOTIF_EXISTS = "'通知存在'表达式中的语法错误"
SYNTAX_ERR_NUM_THREADS_WAITING = "'等待线程数'表达式中的语法错误"
SYNTAX_ERR_IS_SET = "'Is Set' 中的语法错误？'表达"
SYNTAX_ERR_IS_AUTOCLEAR = "'是自动清除吗？'中的语法错误表达"
ERR_LOCATION_TO_STORE_DATA_HAS_WRONG_TYPE = "存储通知数据的位置没有兼容的类型。"
;;额外的结果提示
NOTIFICATION_NAME = "通知名称或引用表达式"
OPERATION="操作"
ALREADY_EXISTS_HINT = "已经存在？"
NOTIFICATION_REFERENCE_LIFETIME_HINT = "通知参考生命周期"
DATA_VALUE_HINT = "数据值"
AUTO_CLEAR_AFTER_NOTIFYING_ONE_THREAD_HINT = "通知一个线程后自动清除"
THREAD_TO_NOTIFY_HINT = "要通知的线程"
FIRST_WAITING_THREAD_HINT = "第一个等待线程"
ALL_WAITING_THREADS_HINT = "所有等待线程"
DATA_HINT = "数据"
TIMEOUT="超时"
DISABLED="禁用"
NOTIFICATION_EXISTS_HINT = "通知存在？"
NUMBER_OF_THREADS_WAITING_FOR_NOTIFICATION_HINT = "等待通知的线程数"
IS_SET_HINT = "已设置？"
IS_AUTO_CLEAR_HINT = "自动清除吗？"

[NI_NOTIFICATION_STEP_TYPE_OPER_NAME]
0 = "创建"
1 = "设置"
2 ="清除"
3 ="脉冲"
4 ="等待"
5 = "获取状态"

[NI_THREAD_PRIORITY_STEP_TYPE]
DEF_STEP_NAME = "线程优先级"
MENU_ITEM_NAME = "线程优先级"
EDIT_STEP_MENU_NAME = "&配置线程优先级..."
EDIT_DLG_CAPTION = "线程优先级配置"
SET_THREAD_PRIORITY_LBL = "&新线程优先级："
GET_THREAD_PRIORITY_LBL = "&Location to Store Thread Priority (numeric value):"
TIME_CRITICAL_WARNING Line0001 = "改变线程优先级时，确保高优先级线程"
TIME_CRITICAL_WARNING Line0002 = "没有消耗所有可用的 CPU 时间。将线程设置为"
TIME_CRITICAL_WARNING Line0003 = "'时间紧迫'会导致用户界面无响应并且"
TIME_CRITICAL_WARNING Line0004 = "阻止其他线程执行。确保这些线程周期性地产生"
TIME_CRITICAL_WARNING Line0005 = "CPU 时间通过使用等待步骤类型来产生时间，或者将线程优先级设置为"
TIME_CRITICAL_WARNING Line0006 = "尽可能降低设置。"
SET_PRIORITY = "设置线程优先级"
GET_PRIORITY = "获取线程优先级"
BROWSE_BTN = "浏览..."
OPERATION_LBL = "操作&操作："
SYNTAX_ERR_SET_PRIORITY = "'新线程优先级'表达式中的语法错误"
SYNTAX_ERR_GET_PRIORITY = "'存储优先级的位置'表达式中的语法错误"
;;额外的结果提示
OPERATION="操作"
THREAD_PRIORITY = "线程优先级"

[NI_THREAD_PRIORITY_NAMES]
0 ="空闲"
1 ="低"
2 ="低于正常水平"
3 ="正常"
4 ="高于正常水平"
5 ="高"
6 ="时间紧迫（见下面的警告信息）"
UNKNOWN = "<未知优先级>"

[NI_THREAD_PRIORITY_OPER_NAMES]
0 = "设置线程优先级"
1 = "获取线程优先级"

[NI_PROCESSOR_AFFINITY_STEP_TYPE]
DEF_STEP_NAME = "CPU 亲和力"
MENU_ITEM_NAME = "CPU 亲和力"
EDIT_STEP_MENU_NAME = "配置 CPU 关联&n"
EDIT_DLG_CAPTION = "CPU 关联配置"
OPERATION_LBL = "操作&操作："
GET_SYSTEM_AFFINITY_LBL = "&Location to Store System Affinity (numeric value):"
SET_PROCESS_AFFINITY_LBL = "&新进程亲和力："
GET_PROCESS_AFFINITY_LBL = "&Location to Store Process Affinity (numeric value):"
SET_THREAD_AFFINITY_LBL = "&新线程亲和度："
GET_THREAD_AFFINITY_LBL = "&Location to Store Thread Affinity (numeric value):"
GET_SYSTEM_AFFINITY = "获得系统亲和度"
GET_PROCESS_AFFINITY = "获取进程亲和度"
SET_PROCESS_AFFINITY = "设置进程亲和度"
GET_THREAD_AFFINITY = "获取线程亲和性"
SET_THREAD_AFFINITY = "设置线程关联"
SYNTAX_ERR_GET_SYSTEM_AFFINITY = "'存储系统相似性的位置'表达式中的语法错误"
SYNTAX_ERR_GET_PROCESS_AFFINITY = "'存储进程亲和性的位置'表达式中的语法错误"
SYNTAX_ERR_SET_PROCESS_AFFINITY = "'New Process Affinity' 表达式中的语法错误"
SYNTAX_ERR_GET_THREAD_AFFINITY = "'存储线程亲和性的位置'表达式中的语法错误"
SYNTAX_ERR_SET_THREAD_AFFINITY = "'New Thread Affinity' 表达式中的语法错误"
SINGLE_PROCESSOR_LBL = "这些操作在只有一个处理器的系统上不可用。"
PROCESSOR_AFFINITY_INFO Line0001 = "注意：CPU affinity 表示为数值。例如，值 15 (0b00001111) 表示四核中的处理器"
" PROCESSOR_AFFINITY_INFO Line0002 = "系统和值 10 (0b00001010) 表示四核系统中的处理器 2 和 4。
GET_PROCESS_AFFINITY_MASK_API_CALL_FAILED = "GetProcessAffinityMask API 调用失败。"
SET_PROCESS_AFFINITY_MASK_API_CALL_FAILED = "SetProcessAffinityMask API 调用失败。"
SET_THREAD_AFFINITY_MASK_API_CALL_FAILED = "SetThreadAffinityMask API 调用失败。"
NO_VALID_CPUS_FOR_THREAD = "线程关联掩码 %1 没有指定任何有效的 CPU。所有 CPU 的线程关联掩码都是 %2。"
NON_EXISTENT_CPUS_FOR_THREAD = "线程关联掩码 %1 指定了一个不存在的 CPU。所有 CPU 的线程关联掩码都是 %2。"
NO_VALID_CPUS_FOR_PROCESS = "进程关联掩码 %1 没有指定任何有效的 CPU。所有 CPU 的进程关联掩码都是 %2。"
NON_EXISTENT_CPUS_FOR_PROCESS = "进程关联掩码 %1 指定了一个不存在的 CPU。所有 CPU 的进程关联掩码都是 %2。"
;;额外的结果提示
OPERATION="操作"
CPU_AFFINITY = "CPU 亲和力"

[NI_PROCESSOR_AFFINITY_OPER_NAMES]
0 = "获取系统亲和力"
1 = "获取进程亲和力"
2 = "设置进程亲和力"
3 = "获取线程亲和力"
4 = "设置线程亲和力"

[NI_AUTOSCHEDULE_STEP_TYPE]
CONFIGURE_AUTOSCHEDULE = "配置自动计划步骤"
TIMEOUT_ENABLED = "&超时启用"
TIMEOUT_EXPRESSION_(SECONDS) = "超时&表达式（秒）："
TIMEOUT_CAUSES_RUNTIME_ERROR = "超时导致&运行时错误"
DISPLAY_DETAILS_IN_DESCRIPTION = "&Display execution scheduling information in step description"
HELP = "&帮助"
OK = "&好的"
CANCEL = "&取消"
CONFIGURE_USERESOURCE = "配置使用自动计划资源步骤"
LOCK_NAME_OR_REFERENCE_EXPRESSION = "&资源锁名称或引用表达式（传递一个数组来锁定多个锁）："
ALTERNATIVE_LOCKS = "备用锁(&L):"
ADD = "&添加"
DELETE = "&删除"
MOVEUP = "移动&上"
MOVEDOWN = "向下移动(&O)"
SELECTED_LOCK = "Acquired Lock（可选输出字符串）："
AUTOSCHEDULE_DEF_STEP_NAME = "自动计划"
AUTOSCHEDULE_INSERT_MENU_ITEM_NAME = "自动计划"
USERESOURCE_DEF_STEP_NAME = "使用自动调度资源"
USERESOURCE_INSERT_MENU_ITEM_NAME = "使用自动调度资源"
AUTOSCHEDULE_EDIT_MENU = "配置自动调度..."
USERESOURCE_EDIT_MENU = "配置使用自动调度资源..."
ERR_USERESOURCE_OR_END_NOT_NEXT_STEP = "使用资源或结束步骤必须紧跟在自动计划步骤之后。"
ERR_USERESOURCE_NOT_AFTER_END = "使用资源步骤的结束步骤后必须跟另一个使用资源步骤或封闭的自动计划块的结束步骤。"
ERR_USERESOURCE_MUST_BE_IN_AUTOSCHEDULE = "使用资源块必须立即驻留在自动调度块中。"
ERR_DUPLICATE_RESOURCE_EXPRESSION = "以下资源表达式在该自动计划块中的使用资源步骤的替代资源列表中重复："
ERR_RECURSION = "无法递归输入自动调度块。"
ERR_NO_AUTOBLOCKACTIVE = "使用资源步骤需要一个激活的自动调度块。"
ERR_RESOURCE_ALREADY_OWNED = "资源块试图获取它已经拥有的资源。"
ERR_AUTO_SCHEDULE_ALREADY_ACTIVE = "Auto Schedule 块已经在该线程中激活。"
ERR_USERESOURCE_RUNMODE_INVALID = "使用资源步骤的运行模式必须是正常或跳过。"

ERR_EXECUTING_AUTO_SCHEDULE_STEP = "执行'自动计划'步骤时出错。"
ERR_EXECUTING_USE_RESOURCE_STEP = "执行'使用资源'步骤时出错。"
ERR_EXECUTING_END_STEP = "执行'结束'步骤时出错。"

PENDING="待定，"
WAITING_THREADS = "%s \n等待线程："
EMPTY = "<空>"
THIS_THREAD = " <此线程>"
QUEUE_FMT_WITH_TIME = "\n[#%d] id=%d%s，剩余时间=%.3f"
QUEUE_FMT_WITHOUT_TIME = "\n[#%d] id=%d%s"
RESOURCES = "\n\n资源："
ALTERNATIVE_ITEM_FORMAT = "\n[#%d] %s: %s"
ALTERNATIVE_THREAD_FORMAT = "拥有线程：id=%d%s"
FREE = "<免费>"
ACTIVE = "活动"
TIMELEFT_FMT ="剩余时间：%.3f 秒。"
EXTERNAL_WAITERS_FMT = "<等待锁定的外部线程：%d>"
LOCKED_BY_THREADS_BEGIN = "<被线程锁定："
LOCKED_BY_THREADS_END = ">"
TIMEOUT_DESC = "超时："
NO_TIMEOUT = "<无超时>"
REENTRY_WARNING = "警告：这个 AutoSchedule 块之前没有正常完成就退出了，可能是由于一个明确的分支，比如 Goto 步骤。任何之前获取的资源都将被释放，所有的 Use Resource 块将被重新执行。"
REENTRY_DESCRIPTION = "重置先前退出的 AutoSchedule 块"

;;额外的结果提示
TIMEOUT="超时"
DISABLED="禁用"
RESOURCE_LOCK_ALTERNATIVES = "资源锁定选项"
ACQUIRED_LOCK = "获得锁"
