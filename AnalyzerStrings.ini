;; AnalyzerStrings.ini - 分析器的字符串
;;三多汉化QQ:1064331064 ok.show
;;如果要创建新的资源字符串文件或自定义现有资源
;;字符串文件，你必须把它放在 < TestStand Public>\Components\Language 目录中。
;;
;;如果您对资源文件进行了更改，则需要重新启动TestStand应用程序
;;以使更改生效。
;;
;;注意，当添加超过 512 个字符的行时，将它们分成几行，
;;每个少于 512 个字符。每行使用相同的标签名称，后跟
;; " LineNNNN "，其中 NNNN 是零填充行号。例子：
;; TagName Line0001 = "super long string that goes on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0002 = " and on and on and on and on and on and on and on and on and on and on and on"
;; TagName Line0003 = " and on and on and on and on and on and on and on and on and on and on and on"

[TESTSTAND_ANALYZER]
UNKNOWN_ERROR = "发生未知错误。"
MODULE_LOAD_ERROR = "加载模块时出错：\n%1"
MODULE_LOAD_PROTOTYPE_ERROR = "加载模块原型时出错：\n%1"

LVMODULE_PROTOTYPE_PARAM_TYPE_ERROR = "VI '%1' 的原型不正确。需要一个 ActiveX Refnum 输入和一个可选的 Error Out 簇输出。"

LVMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0001 = "VI '%1' 的原型不正确。规则配置模块原型必须具有以下输入和输出：\n"
LVMODULE_CONFIG_MDOULE_PROTOTYPE_ERROR Line0002 = "输入：ActiveX Refnum (RuleConfigurationContext)\n"
LVMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0003 = " Outputs: Error Out cluster OR string (error source), long (error code), and Boolean (错误状态)"

LVMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0001 = "VI '%1' 的原型不正确。分析模块原型必须具有以下输入和输出：\n"
LVMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0002 = "输入：ActiveX Refnum (AnalysisContext)\n"
LVMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0003 = "输出：错误输出簇或字符串（错误源）、长（错误代码）和布尔（错误状态）"

LVNXGMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0001 = "'%2' 中的 VI '%1' 的原型不正确。规则配置模块原型必须具有以下输入和输出：\n"
LVNXGMODULE_CONFIG_MDOULE_PROTOTYPE_ERROR Line0002 = "输入：ActiveX Refnum (RuleConfigurationContext)\n"
LVNXGMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0003 = " Outputs: Error Out cluster OR string (error source), long (错误代码), and Boolean (错误状态)"

LVNXGMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0001 = "'%2' 中的 VI '%1' 的原型不正确。分析模块原型必须具有以下输入和输出：\n"
LVNXGMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0002 = "输入：ActiveX Refnum (AnalysisContext)\n"
LVNXGMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0003 = " Outputs: Error Out cluster OR string (error source), long (错误代码), and Boolean (错误状态)"

DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0001 = "函数 '%1' 的原型不正确。规则配置模块原型必须是以下之一：\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0002 = "void Function(<RuleConfigurationContext> context)\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0003 = " bool Function(<RuleConfigurationContext> context, char errorMessage[])\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0004 = " int Function(<RuleConfigurationContext> context, char errorMessage[])\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0005 = " int Function(<RuleConfigurationContext> context, char errorMessage[], int errorMessageBufferSize)\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0006 = "\n其中 <RuleConfigurationContext> 是以下之一：\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0007 = " TSAnalyzer::RuleConfigurationContext *\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0008 = " CAObjHandle\n"
DLLMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0009 = " IDispatch *\n"

DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0001 = "函数 '%1' 的原型不正确。分析模块原型必须是以下之一：\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0002 = "void Function(<AnalysisContext> context)\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0003 = " bool Function(<AnalysisContext> context, char errorMessage[])\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0004 = " int Function(<AnalysisContext> context, char errorMessage[])\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0005 = " int Function(<AnalysisContext> context, char errorMessage[], int errorMessageBufferSize)\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0006 = "\n其中 <AnalysisContext> 是以下之一：\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0007 = " TSAnalyzer::AnalysisContext *\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0008 = " CAObjHandle\n"
DLLMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0009 = " IDispatch *\n"

DOTNETMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0001 = "方法 '%1' 的原型不正确。分析模块原型必须是以下之一：\n"
DOTNETMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0002 = "void Method(NationalInstrument.TestStand.Interop.SequenceAnalyzer.AnalysisContext context)\n"
DOTNETMODULE_ANALYSIS_MODULE_PROTOTYPE_ERROR Line0003 = " bool Method(NationalInstrument.TestStand.Interop.SequenceAnalyzer.AnalysisContext context, out string errorMessage)\n"


DOTNETMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0001 = "方法 '%1' 的原型不正确。规则配置模块原型必须是以下之一：\n"
DOTNETMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0002 = "void Method(NationalInstrument.TestStand.Interop.SequenceAnalyzer.RuleConfigurationContext 上下文)\n"
DOTNETMODULE_CONFIG_MODULE_PROTOTYPE_ERROR Line0003 = " bool Method(NationalInstrument.TestStand.Interop.SequenceAnalyzer.RuleConfigurationContext context, out string errorMessage)"

RULE_MODULE_LOAD_ERROR = "加载分析模块 '%1' 失败：\n%2"
CONFIG_MODULE_LOAD_ERROR = "无法加载规则 '%1' 的规则配置模块：\n%2"
CONFIG_MODULE_CALL_ERROR = "调用规则 '%1' 的规则配置模块时出错：\n%2"

MODULE_NOT_LOADED_ERROR = "调用模块 '%1' 失败，因为模块未加载。"
MODULE_CALL_ERROR = "模块 '%1' 中发生错误：\n%2"

FUNCTION_RETURNED_FALSE = "函数返回错误"
FUNCTION_RETURNED_ERROR_CODE = "函数返回 %1"
VI_ERROR_OCCURRED = "VI 返回错误代码 %1：\n%2"

CANNOT_MODIFY_MODULE_WHILE_ANALYZING = "分析正在进行时无法编辑分析器模块。"
UNSPECIFIED_DLL_FUNCTION = "<未指定函数>"
UNSPECIFIED_VI = "<未指定的 LabVIEW VI>"
UNSPECIFIED_DLL = "<未指定的 DLL>"
UNSPECIFIED_ASSEMBLY = "<未指定的 .NET 程序集>"
UNSPECIFIED_ASSEMBLY_METHOD = "<未指定类方法>"
UNSPECIFIED_LV_NXG_VI = "<未指定的 LabVIEW NXG VI>"
UNSPECIFIED_LV_NXG_PROJECT = "<未指定的 LabVIEW NXG 项目>"

ANALYZING_FILE_STATUS = "正在分析：%1 (%2)"
ANALYZING_SEQUENCE_STATUS = "正在分析序列：%1"
WORKSPACE_FILE = "工作区文件"
TEMPLATES_FILE = "模板文件"
SEQUENCE_FILE = "序列文件"
TYPE_PALETTE = "类型调色板"
STATION_GLOBALS_FILE = "空间站全局"
ANALYSIS_INITIALIZING_STATUS = "准备分析"
ANALYSIS_COMPLETE_STATUS = "分析完成"
ANALYSIS_STOPPED_STATUS = "分析停止"
ANALYSIS_ABORTED_STATUS = "分析中止"
USERS_FILE = "用户文件"

ORPHANED_CONTEXT = "分析完成后存在对 AnalysisContext 的引用。"
ORPHANED_UTILITIES = "分析完成后存在对 AnalysisUtilities 的引用。"

INITIALIZE_CALLED_TWICE = "已经调用了初始化方法。"
INITIALIZE_NOT_CALLED = "在调用其他方法之前必须先调用 Initialize 方法。"
ANALYSIS_ALREADY_STARTED = "无法开始分析，因为当前正在分析项目。"
MUST_STOP_ANALYSIS_BEFORE_ABORTING = "无法中止分析。中止前必须先停止分析。"
NON_UNIQUE_RULE_ID_FOUND_DURING_ANALYSIS = "在分析过程中发现了相同规则 ID 的多个实例：'%1'"
RULE_ID_NOT_FOUND = "找不到规则 ID：'%1'"
RULE_ID_IN_USE = "无法将规则 ID 设置为 '%1'。其他规则已使用该 ID。"
INVALID_RULE_SEVERITY = "规则严重性 '%1' 不是有效值。"
INVALID_RULE_SETTING_NAME = "找不到规则设置 '%1'。"
INVALID_RULE_SETTING_NAME_FOR_RULE = "找不到规则 '%2' 的规则设置 '%1'。"
UNLOCK_FILE_DIALOG_TITLE = "解锁文件进行分析"

ERROR_READING_FILE = "读取文件时出错：'%1'。"
FATAL_ANALYSIS_ERROR = "分析过程中发生致命错误。"
FATAL_ANALYSIS_ERROR_DESC = "错误代码：%1 (0x%2)\n消息：%3"
NO_ERROR_INFORMATION = "<无可用信息>"
FILE_VERSION_NEWER_ERROR = "该文件保存在较新版本的 TestStand 中，与此版本的 TestStand 不兼容。"

RULE_MODULE_TRANSITION_ERROR = "%2\n（为分析转换 '%1' 调用了分析模块）"
INTERNAL_ANALYSIS_ERROR = "内部错误：%1"
INTERNAL_FILE_OPEN_ANALYSIS_ERROR = "无法加载文件 '%1' 进行分析：\n%2"
INTERNAL_FILE_LOCKED_ANALYSIS_ERROR = "无法解锁文件 '%1' 进行分析。"

CONFORM_MODIFIED_CUSTOM_SETTINGS_MESSAGE = "规则的设置已更改：'%1'"
CONFORM_ADDED_NEW_RULE_MESSAGE = "添加了新规则：'%1'"
CONFORM_DELETED_RULE_ID_MESSAGE = "已删除规则 ID：'%1'"
CONFORM_DELETED_RULE_NAME_MESSAGE = "已删除规则：'%1'（ID：'%2'）"

CLOSING_SEQUENCE_FILES = "正在关闭序列文件..."

INVALID_RULE_SETTING_TYPE = "<无效设置类型>"
RULE_SETTING_TYPE_MISMATCH = "规则设置 '%1' 是 '%2' 类型。应为 '%3'。"
LV_NXG_UNAVAILABLE = "要从分析器调用 LabVIEW NXG 模块，应在机器上安装 LabVIEW NXG 开发系统，并且应将 LabVIEW NXG 适配器设置为使用开发系统。"

[TESTSTAND_ANALYZER_TRANSITIONS]
TRANSITION_SYSTEM = "系统"
TRANSITION_EACH_TYPE_PALETTE = "类型调色板"
TRANSITION_TYPE_PALETTES = "类型调色板"
TRANSITION_FILE_TYPES = "文件类型"
TRANSITION_SEQUENCE_FILE = "序列文件"
TRANSITION_FILE_GLOBALS = "序列文件全局变量"
TRANSITION_SEQUENCES = "序列"
TRANSITION_SEQUENCE = "序列"
TRANSITION_SEQUENCE_VARIABLES = "序列变量"
TRANSITION_SEQUENCE_LOCALS = "序列局部变量"
TRANSITION_SEQUENCE_PARAMETERS = "序列参数"
TRANSITION_STEPS = "步骤"
TRANSITION_SETUP = "设置步骤组"
TRANSITION_MAIN = "主要步骤组"
TRANSITION_CLEANUP = "清理步骤组"
TRANSITION_STEP = "步骤"
TRANSITION_STATION_GLOBALS_FILE = "空间站全局文件"
TRANSITION_STATION_GLOBALS = "车站全局"
TRANSITION_USERS_FILE = "用户文件"
TRANSITION_USERS = "用户"
TRANSITION_USER_GROUPS = "用户组"
TRANSITION_WORKSPACE_FILE = "工作区文件"
TRANSITION_TEMPLATES = "模板"
TRANSITION_TEMPLATES_FILE = "模板文件"

TRANSITION_BEFORE_FORMAT = "在 %1 之前"
TRANSITION_AFTER_FORMAT = "在 %1 之后"

[TESTSTAND_ANALYZER_INSTALL_UTILITY]
COMMAND_LINE_USAGE Line0001 = "用法：%1 [/env <环境路径>] [/U] [/S] <规则文件> [ ...]\n"
COMMAND_LINE_USAGE Line0002 = "/env <环境路径>：指定 TestStand 环境。\n"
COMMAND_LINE_USAGE Line0003 = "/U : 卸载规则文件\n"
COMMAND_LINE_USAGE Line0004 = "/S : Silent\n"
COMMAND_LINE_USAGE Line0005 = "<规则文件>：要安装或卸载的规则文件"

UNRECOGNIZED_OPTION_MESSAGE = "无法识别的命令行选项：%1"
FILE_NOT_FOUND_MESSAGE = "找不到规则文件 '%1'。"
MISSING_ARGUMENT_MESSAGE = "缺少规则文件参数。"

RULE = "规则"
RULE_MODULE = "分析模块"
RULE_SET = "规则集"
ADDED_ITEM_MESSAGE = "已添加 %1：%2"
REPLACED_ITEM_MESSAGE = "已替换 %1：%2"
REMOVED_ITEM_MESSAGE = "已删除 %1：%2"

[TESTSTAND_ANALYZER_APP]
APP_TITLE = "TestStand 序列分析器 %1- %2"
FILES_TAB = "文件"
RULES_TAB = "规则"
OPTIONS_TAB = "选项"
MESSAGES_TAB = "消息"
SUMMARY_TAB = "分析摘要"
ABOUT_DIALOG_TEXT = "版本：%1"

;;菜单
FILE_MENU = "&文件"
NEW_PROJECT_MENU_ITEM = "&New 序列分析器项目"
OPEN_PROJECT_MENU_ITEM = "&打开序列分析器项目..."
CLOSE_MENU_ITEM = "&关闭"
SAVE_MENU_ITEM = "&保存"
SAVE_AS_MENU_ITEM = "另存为..."
EXIT_MENU_ITEM = "退出&退出"
GENERATE_REPORT_MENU_ITEM = "生成分析&报告..."
EDIT_MENU = "&编辑"
PROJECT_MENU = "&项目"
HELP_MENU = "&帮助"
START_ANALYSIS_MENU_ITEM = "&分析"
STOP_ANALYSIS_MENU_ITEM = "&停止分析"
SHOW_HELP_MENU_ITEM = "帮助主题..."
SHOW_TESTSTAND_HELP_MENU_ITEM = "NI TestStand &帮助..."
ABOUT_ANALYZER_APP_MENU_ITEM = "&关于 TestStand 序列分析器..."
OPTIONS_MENU_ITEM = "&序列分析器选项..."
RULES_EDITOR_MENU_ITEM = "可用规则(&R)..."

;;工具栏
NEW_PROJECT_TOOL_ITEM = "新序列分析器项目"
OPEN_PROJECT_TOOL_ITEM = "打开序列分析器项目..."
SAVE_PROJECT_TOOL_ITEM = "保存"
START_ANALYSIS_TOOL_ITEM = "分析"
STOP_ANALYSIS_TOOL_ITEM = "停止分析"
RULES_EDITOR_TOOL_ITEM = "可用规则..."

SEQEDIT_NOT_FOUND = "无法前往位置。未找到序列编辑器：\n'%1'"

ANALYZER_OPTIONS_DIALOG_TITLE = "序列分析器选项"
CACHE_SEQUENCE_FILES = "在分析期间缓存序列文件"

;; BEGIN-COPIED-RESOURCES 这里和END-COPIED-RESOURCES之间的代码是从这里复制过来的
;;将文件添加到此文件的 2012SP1 副本，以便启用 2012SP1 的补丁
;;它向独立分析器应用程序 (AnalyzerApp.exe) 添加了一个命令行界面

CANNOT_WRITE_REPORT_FILE = "无法写入报告文件 '%1'。如果您没有该文件的写入权限，可能会发生这种情况。"

CANNOT_WRITE_PROJECT = "无法保存项目 '%1'。如果您没有写入文件的权限，或者文件被标记为只读，则可能会发生这种情况。"

;;命令行
COMMAND_LINE_USAGE Line0001 = "用法：\n"
COMMAND_LINE_USAGE Line0002 = "AnalyzerApp.exe [/env <环境路径>] [<analyzerProjectPath> [/analyze] [/report [<reportPath>]]] [/save [/clearMessagesOnSave]] [/minimize] [/help] [ /退出]\n\n"
COMMAND_LINE_USAGE Line0003 = "/env <环境路径>：指定 TestStand 环境。\n"
COMMAND_LINE_USAGE Line0004 = "<analyzerProjectPath>：要打开的分析项目。/analyze、/report 和 /save 需要。\n"
COMMAND_LINE_USAGE Line0005 = "<reportPath>：指定生成报告的放置位置和调用内容的路径。如果提供了相对路径，则假定它相对于项目目录。"
COMMAND_LINE_USAGE Line0006 = "如果在命令行上请求报告但没有提供路径，报告将被放置在与项目相同的目录中。\n"
COMMAND_LINE_USAGE Line0007 = "/analyze：对指定项目执行分析。\n"
COMMAND_LINE_USAGE Line0008 = "/report：根据最近的分析生成报告。\n"
COMMAND_LINE_USAGE Line0009 = "/save：保存项目，包括最近的分析。\n"
COMMAND_LINE_USAGE Line0010 = "/clearMessagesOnSave：在保存之前立即删除项目中存在的任何分析消息。只能与 /save 结合使用。\n"
COMMAND_LINE_USAGE Line0011 = "/minimize：启动最小化到任务栏的应用程序。\n"
COMMAND_LINE_USAGE Line0012 = "/help : 打印出命令行用法。\n"
COMMAND_LINE_USAGE Line0013 = "/quit : 当指定的操作完成时关闭应用程序。\n"
COMMAND_LINE_USAGE Line0014 = "请注意，无论指定标志的顺序如何，如果指定了 /analyze，它将完成 "
COMMAND_LINE_USAGE Line0015 = "在 /report 之前，（如果指定）将始终在 /save 之前完成，这（如果指定）将"
COMMAND_LINE_USAGE Line0016 = "总是在 /quit 之前完成。\n"
COMMAND_LINE_USAGE Line0017 = "\n"
COMMAND_LINE_USAGE Line0018 = "如果运行序列分析器出现问题，序列分析器应用程序将返回一个负值，并返回一个正值"
COMMAND_LINE_USAGE Line0019 = "如果分析报告了一项或多项违规行为。以下是有效的返回码，按优先级降序排列：\n"
COMMAND_LINE_USAGE Line0020 = "-2 无效路径：传递了无效路径。\n"
COMMAND_LINE_USAGE Line0021 = "-1 无效标志：传递了一个无效标志。\n"
COMMAND_LINE_USAGE Line0022 = "1 分析器错误：分析项目时报告了一个或多个错误。\n"
COMMAND_LINE_USAGE Line0023 = "2 分析器警告：分析项目时报告了一个或多个警告。\n"
COMMAND_LINE_USAGE Line0024 = "0 成功：没有报告错误或警告。\n"
COMMAND_LINE_USAGE Line0025 = "注意：如果在项目分析期间同时报告警告和错误，则返回值将指示错误。"

INVALID_COMMAND_LINE_PATHS Line0001 = "无效路径：%1。路径可能无效，因为它引用了一个文件或目录"
INVALID_COMMAND_LINE_PATHS Line0002 = "不存在，或者因为在某处提供了一个不期望的路径。"

NEEDED_PROJECT_BUT_DIDNT_GET Line0001 = "必须提供项目路径以使用标志 /analyze /report 和 /save（参见上面的使用信息），但未找到有效的项目路径。"
NEEDED_PROJECT_BUT_DIDNT_GET Line0002 = "这可能意味着您根本没有提供路径，或者您提供的路径没有引用有效的项目文件。"

INVALID_COMMAND_LINE_FLAGS Line0001 = "意外标志：%1。查看上面显示的命令行用法以获取支持的标志列表。"

INVALID_CLEARMESSAGESONSAVE Line0001 = "/clearMessagesOnSave 只能在使用 /save 时使用。"

;;这些字符串必须始终是单个单词，没有空格或换行符
FLAG_HELP = "帮助"
FLAG_ANALYZE = "分析"
FLAG_REPORT = "报告"
FLAG_SAVE = "保存"
FLAG_CLEAR_MESSAGES_ON_SAVE = "clearMessagesOnSave"
FLAG_CLOSE = "退出"
FLAG_HIDE = "最小化"
REPORT_PREFIX = "报告"

;;结束复制资源

[ANALYZER_UI_COMMON]
CLOSE_BUTTON = "关闭"
CANCEL_BUTTON = "取消"
OK_BUTTON = "确定"
HELP_BUTTON = "帮助"
SEVERITY_INFORMATION = "信息"
SEVERITY_WARNING = "警告"
SEVERITY_ERROR = "错误"
SEVERITY_DEFAULT = "默认"
SEVERITY_UNKNOWN = "未知"
SAVE_REPORT_DIALOG_TITLE = "生成分析报告"
FILE_DIALOG_RULES_FILES = "序列分析器规则文件 (*.tsrules)"
FILE_DIALOG_PROJECT_FILES = "序列分析器项目文件 (*.tsaproj)"
FILE_DIALOG_SEQUENCE_FILES = "序列文件 (*.seq)"
FILE_DIALOG_WORKSPACE_FILES = "工作区文件 (*.tsw)"
FILE_DIALOG_REPORT_FILES = "序列分析器报告文件 (*.xml)"
SAVE_CHANGES_MESSAGE = "保存对 %1 的更改？"
APP_TITLE = "TestStand 序列分析器"
CANNOT_CLOSE_PROJECT_WHILE_ANALYZING = "无法关闭项目，因为当前正在分析项目。"
NEW_PROJECT_NAME = "新分析项目"
FILE_IS_READ_ONLY = "文件 '%1' 是只读的，不能保存在这个文件名下。\n\n你想保存到一个不同的文件名吗？"

ANALYZING_STATUS = "分析中"
COMPLETED_STATUS = "完成"
STOPPED_STATUS = "已停止"
NOT_STARTED_STATUS = "未分析"

ENVIRONMENT_LABEL = "环境：%1"
GLOBAL_ENVIRONMENT = "<全局>"

CUSTOM_SETTING_NUMBER_TYPE = "数字"
CUSTOM_SETTING_STRING_TYPE = "字符串"
CUSTOM_SETTING_BOOLEAN_TYPE = "布尔值"

INVALID_ENUM_VALUE = "<无效值>"
PROJECT_RULE_SET_NAME = "<新项目模板>"
GENERIC_PROJECT_DESCRIPTION = "项目"
PROJECT_CONFORM_MODIFICATIONS_MESSAGE = "%1 被修改如下以符合现有的系统规则：\n%2"

NUM_FILES_STATUS_TEXT = "文件数量：%1"
NUM_FILES_IN_PROGRESS_STATUS_TEXT = "文件：%1/%2"
NUM_SEQUENCES_IN_PROGRESS_STATUS_TEXT = "序列：%1/%2"
NUM_MESSAGES_STATUS_TEXT = "消息数量：%1（活动：%2，忽略：%3，修复：%4）"
NO_MESSAGES_STATUS_TEXT = "消息数量：0"
NUM_SELECTED_MESSAGES_STATUS_TEXT = "%1 条选定的消息"
NO_SELECTED_MESSAGES_STATUS_TEXT = "没有选择消息"

UNABLE_TO_EDIT_SEQUENCE_FILE_MESSAGE = "无法编辑序列文件 '%1'"

[ANALYZER_SPECIFY_MODULE_CONTROL]
MODULE_PATH = "路径："
MODULE_FUNCTION = "功能："
MODULE_CLASS = "类别："
MODULE_METHOD = "方法："
MODULE_NAME = "模块限定名称："
NO_FUNCTION_SELECTED = "没有选择功能。"
NO_CLASS_SELECTED = "没有选择类。"
NO_METHOD_SELECTED = "没有选择方法。"
NO_MODULE_NAME_SELECTED = "没有选择 VI。"
MODULE_FILES = "序列分析器模块文件"
USE_LABVIEW_RTE_CHECKBOX = "在 LabVIEW 运行时引擎中运行 VI"
USE_LABVIEW_RTE_DESCRIPTION = "启用此选项后，序列分析器将在 LabVIEW 运行时引擎中运行此 VI，而不管 LabVIEW 适配器的服务器设置如何。TestStand 会自动确定用于运行此程序的 LabVIEW 运行时引擎的正确版本六。"
LV_NXG_UNAVAILABLE = "要从分析器调用 LabVIEW NXG 模块，应在机器上安装 LabVIEW NXG 开发系统，并且应将 LabVIEW NXG 适配器设置为使用开发系统。"

[ANALYZER_PROJECT_MESSAGES_CONTROL]
MESSAGE_SEVERITY_COLUMN = "严重性"
MESSAGE_RULE_COLUMN = "规则"
MESSAGE_LOCATION_COLUMN = "地点"
MESSAGE_TEXT_COLUMN = "文本"
MESSAGE_FILE_COLUMN = "文件"
MESSAGE_CATEGORY_COLUMN = "类别"
MESSAGE_IGNORE_JUSTIFICATION_COLUMN = "忽略的理由"

IGNORE_MENU_ITEM = "在分析器项目中将消息标记为已忽略"
IGNORE_IN_SEQFILE_MENU_ITEM = "在序列文件中将消息标记为已忽略"
;在末尾添加空格，使"Del"快捷方式文本不会离菜单项文本太近
HIDE_MENU_ITEM = "将消息标记为已修复"
MAKE_ACTIVE_MENU_ITEM = "将消息标记为有效"
COPY_MENU_ITEM = "复制"

SHOW_COLUMNS_MENU_ITEM = "列"
GOTO_LOCATION_MENU_ITEM = "转到位置"
CONFIGURE_RULE_MENU_ITEM = "转到规则"
DELETE_MENU_ITEM = "删除消息"
SHOW_LABEL = "显示："
GROUP_BY_LABEL = "分组依据："
ACTIVE_MESSAGES = "活动信息"
PROJECT_IGNORED_MESSAGES = "分析器项目忽略的消息"
SEQFILE_IGNORED_MESSAGES = "序列文件忽略的消息"
FIXED_MESSAGES = "标记为固定的消息"
ANALYZED_FILES = "分析文件"
NONE = "<无>"

DETAILS_MESSAGE_TEXT = "消息"
DETAILS_RULE_DESCRIPTION = "描述"
DETAILS_RULE_NAME = "规则"
DETAILS_FILE = "文件"
DETAILS_LOCATION = "地点"

START_ANALYSIS_BUTTON_TOOLTIP = "重新开始分析"
STOP_ANALYSIS_BUTTON_TOOLTIP = "停止分析"
SAVE_REPORT_BUTTON_TOOLTIP = "生成分析报告"
SHOW_PROJECT_BUTTON_TOOLTIP = "当前序列分析器项目"
SHOW_ANALYZER_OPTIONS_TOOLTIP = "序列分析器选项..."

DELETE_MESSAGES_UNDO_DESCRIPTION = "删除分析消息"
IGNORE_MESSAGES_UNDO_DESCRIPTION = "忽略分析消息"
CHANGE_MESSAGE_STATUS_UNDO_DESCRIPTION = "改变分析消息的状态"
CHANGE_JUSTIFICATION_UNDO_DESCRIPTION = "将理由更改为忽略"

[ANALYZER_PROJECT_ANALYSIS_SUMMARY_CONTROL]
PATH_COLUMN = "路径"
NUM_MESSAGES_COLUMN = "消息"

NUMBER_OF_MESSAGES = "消息总数："
NUM_ACTIVE_MESSAGES = "活跃消息："
NUM_IGNORED_MESSAGES = "忽略的消息："
NUM_FIXED_MESSAGES = "固定消息："
NUMBER_OF_FILES = "文件总数："
NUMBER_OF_STEPS_NOT_ANALYZED = "跳过的步骤未分析："

ANALYSIS_STATUS = "状态："
START_TIME = "开始时间："
ELAPSED_TIME = "经过时间："
USER_NAME = "用户名："
COMPUTER_NAME = "计算机名称："
ANALYZED_FILES = "已分析文件："

[ANALYZER_PROJECT_FILES_CONTROL]
SELECT_DIRECTORIES_DIALOG_TITLE = "选择要分析的目录"
SELECT_FILES_DIALOG_TITLE = "选择要分析的序列文件"
SELECT_WORKSPACE_DIALOG_TITLE = "选择要分析的工作区文件"
BROWSE_FOR_FILE_TOOLTIP = "浏览序列文件..."
BROWSE_FOR_DIRECTORY_TOOLTIP = "浏览目录..."
BROWSE_FOR_WORKSPACE_TOOLTIP = "浏览工作区..."

FILE_DOES_NOT_EXIST_ERROR = "文件不存在"
DIRECTORY_DOES_NOT_EXIST_ERROR = "目录不存在"
FILE_IS_NOT_WORKSPACE_ERROR = "文件不是工作区文件"

PATH_COLUMN = "路径"
SUB_DIRECTORIES_COLUMN = "分析子目录中的文件"

ANALYZE_SUB_DIRECTORIES_TOOLTIP = "分析子目录"
ENTER_PATH = "<输入路径>"

DIRECTORIES = "要分析的目录"
SEQUENCE_FILES = "要分析的序列文件"
WORKSPACE_FILE = "要分析的工作区文件"
OTHER_FILES = "要分析的 TestStand 文件"

NI_TYPE_PALETTES = "NI 类型调色板"
PUBLIC_TYPE_PALETTES = "公共类型调色板"
STATION_GLOBALS = "站全局"
USERS_FILE = "用户文件"
TEMPLATES_FILE = "模板文件"

[ANALYZER_PROJECT_OPTIONS_CONTROL]
ANALYZE_MODEL_FILES = "分析模型序列文件"
ANALYZE_SUBSEQUENCES = "分析子序列"
ANALYZE_SKIPPED_STEPS = "分析跳过的步骤"
AUTO_SAVE_PROJECT = "自动保存项目文件"

[ANALYZER_PROMPT_TO_STOP_DIALOG]
PROMPT_TO_STOP_ON_CLOSE_MESSAGE = "当前正在进行分析。您必须在关闭项目之前停止分析。"
STOP_BUTTON = "停止"
WAITING_FOR_ANALYSIS_TO_STOP_MESSAGE = "等待分析停止..."
STOP_FAILED_MESSAGE = "警告：分析尚未停止。您可以中止分析，这可能会使 TestStand 处于不可靠状态。"
ABORT_BUTTON = "中止"

[ANALYZER_PROJECT_RULES_CONTROL]
RULE_NAME_COLUMN = "规则"
RULE_SEVERITY_COLUMN = "严重性"
RULE_DESCRIPTION_COLUMN = "描述"
RULE_SETTINGS_BUTTON_TOOLTIP = "设置..."
RULE_DEFAULT_SEVERITY_TEXT = "默认 (%1)"

[ANALYZER_SYSTEM_RULES_DIALOG]
SYSTEM_RULES_DIALOG_TITLE = "配置序列分析器可用规则"
EXPORT_ITEMS_TO_FILE_BUTTON = "导出..."
IMPORT_ITEMS_FROM_FILE_BUTTON = "导入..."

[ANALYZER_RULES_EDITOR_CONTROL]
RULES_TAB = "规则"
RULE_MODULES_TAB = "分析模块"
COMPANY_NAME = "<你的公司名称>"
NEW_RULE_ID = "%1_RuleID"
NEW_RULE_SET_NAME = "自定义规则集"
DUPLICATE_NAME_MESSAGE = "该名称已被使用。您必须选择一个唯一的名称。"
BLANK_NAME_MESSAGE = "名字不能为空。"
DUPLICATE_ID_MESSAGE = "规则 ID 已被使用。您必须选择一个唯一的 ID。"
BLANK_ID_MESSAGE = "规则 ID 不能为空。"
COPY_MENU_ITEM = "复制"
CUT_MENU_ITEM = "剪切"
PASTE_MENU_ITEM = "粘贴"
DELETE_MENU_ITEM = "删除"
EDIT_RULE_MENU_ITEM = "编辑规则..."
EDIT_RULE_MODULE_MENU_ITEM = "编辑分析模块..."
INSERT_RULE_MENU_ITEM = "插入规则"
INSERT_RULE_MODULE_MENU_ITEM = "插入分析模块"
EDIT_RULE_BUTTON_TOOLTIP = "编辑规则..."
EDIT_RULE_MODULE_BUTTON_TOOLTIP = "编辑分析模块..."
RULE_ID_COLUMN = "规则编号"
RULE_NAME_COLUMN = "名称"
RULE_CATEGORY_COLUMN = "类别"
RULE_SEVERITY_COLUMN = "严重性"
RULE_DESCRIPTION_COLUMN = "描述"
MODULE_MODULE_COLUMN = "模块"
MODULE_KINDS_COLUMN = "对象的种类"
MODULE_TYPES_COLUMN = "类型"
MODULE_TRANSITIONS_COLUMN = "转场"
RULE_SET_NAME_COLUMN = "名称"
NEW_RULE_BUTTON_TOOLTIP = "新规则..."
NEW_RULE_MODULE_BUTTON_TOOLTIP = "新分析模块..."
NEW_RULE_ITEM_TEXT = "<插入新规则>"
NEW_RULE_MODULE_ITEM_TEXT = "<插入新的分析模块>"
NEW_RULE_DESCRIPTION = "我的规则描述"
NEW_RULE_NAME = "我的规则名称"
NEW_RULE_CATEGORY = "我的规则"
UNLOAD_MODULES_MENU_ITEM = "卸载所有模块"
SEMICOLON_NOT_ALLOWED_IN_CATEGORY_MESSAGE = "类别不能包含分号。"

[ANALYZER_EDIT_RULE_DIALOG]
EDIT_RULE_DIALOG_TITLE = "编辑规则"
RULE_ID_LABEL = "规则编号："
RULE_CATEGORY_LABEL = "类别："
RULE_SEVERITY_LABEL = "严重性："
RULE_NAME_LABEL = "姓名："
RULE_DESCRIPTION_LABEL = "描述："
RULE_RESOURCE_STRING_LABEL = "资源字符串类别："
RULE_PROPERTIES_TAB = "一般"
RULE_MODULE_LIST = "选择实现此规则的模块："
NEW_RULE_MODULE_BUTTON = "新..."
EDIT_RULE_MODULE_BUTTON = "编辑..."
RULE_CONFIG_MODULE_LABEL = "配置模块："
RULE_SPECIFY_CONFIG_MODULE_BUTTON = "指定..."
RULE_MODULE_TAB = "模块"
RULE_ADVANCED_TAB = "高级"
RULE_HAS_CONFIG_MODULE_CHECKBOX = "有配置模块"
RULE_IS_BUILTIN_CHECK_BOX = "内置"
RULE_CONFIGURATION_OPTION = "配置选项"
CONFIG_OPTION_NONE = "无"
CONFIG_OPTION_MODULE = "使用配置模块"
CONFIG_OPTION_SETTINGS = "使用规则设置"

ADD_CONFIG_SETTING_BUTTON = "添加"
REMOVE_CONFIG_SETTING_BUTTON = "移除"
EDIT_ENUMS_BUTTON = "枚举..."

RULE_CUSTOM_SETTING_NAME_COLUMN = "姓名"
RULE_CUSTOM_SETTING_TYPE_COLUMN = "类型"
RULE_CUSTOM_SETTING_DEFAULT_COLUMN = "默认值"

RULE_ID_NOT_UNIQUE_MESSAGE = "规则 ID 已被使用。你必须选择一个唯一的 ID。"
BLANK_RULE_ID_MESSAGE = "规则 ID 不能为空。"
CUSTOM_SETTING_NEW_NAME = "设置 %1"

[ANALYZER_EDIT_ENUMERATIONS_DIALOG]
EDIT_ENUMERATIONS_DIALOG_TITLE = "编辑规则设置枚举"
ENUMERATIONS_LABEL = "规则设置枚举："
ADD_BUTTON = "添加"
REMOVE_BUTTON = "移除"
EDIT_ITEMS_BUTTON = "编辑物品..."
ENUM_NEW_NAME = "枚举"
DUPLICATE_ENUM_NAME_MESSAGE = "规则设置枚举名称已被使用。您必须选择一个唯一的名称。"
BLANK_ENUM_NAME_MESSAGE = "规则设置枚举名称不能为空。"

[ANALYZER_EDIT_ENUMERATION_ITEMS_DIALOG]
EDIT_ENUMERATION_ITEMS_DIALOG_TITLE = "编辑规则设置枚举项"
ENUM_NAME_LABEL = "规则设置枚举名称："
ENUM_ITEMS_LABEL = "物品："
ADD_BUTTON = "添加"
REMOVE_BUTTON = "删除"
EDIT_BUTTON = "编辑"
ENUM_ITEM_NAME_COLUMN = "名称"
ENUM_ITEM_VALUE_COLUMN = "价值"
ENUM_ITEM_NEW_NAME = "枚举项"
DUPLICATE_ENUM_ITEM_NAME_MESSAGE = "规则设置枚举项名称已被使用。您必须选择一个唯一的名称。"
BLANK_ENUM_ITEM_NAME_MESSAGE = "规则设置枚举项名称不能为空。"

[ANALYZER_RULE_MODULE_DIALOG]
EDIT_RULE_MODULE_DIALOG_TITLE = "编辑分析模块"
MODULE_GROUP_BOX = "模块"
MODULE_KINDS_LABEL = "为这些类型的对象调用模块："
MODULE_TYPES_LABEL = "为这些类型的实例调用模块："
MODULE_TRANSITIONS_LABEL = "为这些转换调用模块："
MODULE_BUILTIN_CHECKBOX = "内置"
INSERT_TYPE_TEXT = "<输入类型名称>"

DUPLICATE_TYPE_NAME_MESSAGE = "类型名称 '%1' 已在列表中。"
BLANK_TYPE_NAME_MESSAGE = "类型名称不能为空。"

INSERT_STEP_TYPE_MENU_ITEM = "步骤类型"
INSERT_DATA_TYPE_MENU_ITEM = "数据类型"
BEFORE_MENU_ITEM = "之前"
AFTER_MENU_ITEM = "之后"

ADD_TYPE_TOOLTIP = "从列表中添加类型"
REMOVE_TYPE_TOOLTIP = "移除选定类型"
ADD_TRANSITION_TOOLTIP = "从列表中添加过渡"
REMOVE_TRANSTION_TOOLTIP = "移除选定的过渡"

;;对象种类
KIND_STEPS = "步数"
KIND_SKIPPED_STEPS = "跳过的步骤"
KIND_LABVIEW_STEPS = "LabVIEW 步骤"
KIND_CVI_STEPS = "LabWindows/CVI 步骤"
KIND_DLL_STEPS = "C/C++ Dll 步骤"
KIND_DOTNET_STEPS = ".NET 步骤"
KIND_ACTIVEX_STEPS = "ActiveX/COM 步骤"
KIND_SEQUENCE_STEPS = "序列调用步骤"
KIND_HTBASIC_STEPS = "HT基本步骤"
KIND_NONE_STEPS = "无步骤"
KIND_LABVIEW_NXG_STEPS = "LabVIEW NXG 步骤"
KIND_PYTHON_STEPS = "Python 步骤"
KIND_VARIABLES = "变量"
KIND_LOCALS = "序列局部变量"
KIND_PARAMETERS = "序列参数"
KIND_FILE_GLOBALS = "序列文件全局变量"
KIND_STATION_GLOBALS = "站点全局"
KIND_FILES = "TestStand 文件"
KIND_SEQUENCE_FILES = "序列文件"
KIND_WORKSPACE_FILES = "工作区文件"
KIND_TYPE_PALETTES = "类型调色板"
KIND_USERS_FILE = "用户文件"
KIND_STATION_GLOBALS_FILE = "空间站全局文件"
KIND_TEMPLATES_FILE = "模板文件"
KIND_TYPES = "类型"
KIND_STEP_TYPES = "步骤类型"
KIND_CUSTOM_TYPES = "自定义数据类型"
KIND_BUILTIN_TYPES = "内置数据类型"
KIND_SEQUENCES = "序列"
KIND_TEMPLATES = "模板物品"
KIND_USER_GROUPS = "用户组"
KIND_USERS = "用户"
KIND_WORKSPACE_OBJECTS = "工作区对象"
KIND_SUBPROPERTIES = "上面的子属性"

[ANALYZER_PROJECT_RULE_SETTINGS_DIALOG]
RULE_SETTING_NAME_COLUMN = "设置"
RULE_SETTING_VALUE_COLUMN = "值"
PROJECT_RULE_SETTINGS_DIALOG_TITLE = "规则设置"

[ANALYZER_IMPORT_ITEMS_DIALOG]
IMPORT_FROM_FILE_DIALOG_TITLE = "从文件中导入项目"
SELECT_ITEMS_TO_IMPORT_LABEL = "选择要导入的项目："
RULES_GROUP = "规则"
RULE_MODULES_GROUP = "分析模块"
IMPORT_FILE_PATH = "选择要导入的文件："
IMPORT_BUTTON = "导入"
ITEM_EXISTS_TAG = "（替换此计算机上的现有项目）"

REPLACING_ITEMS_WARNING_MESSAGE Line0001 = "您正在导入一个或多个规则和分析模块规范，它们将替换您计算机上的现有项目。"
REPLACING_ITEMS_WARNING_MESSAGE Line0002 = "如果您不同时更新相应的分析模块，可能会导致错误。"

RULE_MODULES_NOT_FOUND_WARNING_MESSAGE Line0001 = "您正在导入一个或多个在磁盘上找不到分析模块的分析模块规范。"
RULE_MODULES_NOT_FOUND_WARNING_MESSAGE Line0002 = "您必须将分析模块复制到序列分析器可以找到它们的目录中。"

RULE_MODULE_NOT_FOUND_TOOLTIP = "在磁盘上找不到分析模块 '%1'。"

IMPORT_STATUS_MESSAGE = "从文件 %3 中导入了 %1 项（包括 %2 替换项）"
NOTHING_TO_IMPORT_MESSAGE = "没有选择要导入的项目。"
IMPORT_CONFORM_MODIFICATIONS_MESSAGE = "导入的规则集被修改如下以符合现有的系统规则：\n%1"
BROWSE_BUTTON_TOOLTIP = "浏览规则文件..."

[ANALYZER_EXPORT_ITEMS_DIALOG]
EXPORT_TO_FILE_DIALOG_TITLE = "将项目导出到文件"
EXPORT_ITEMS_DIALOG_TITLE = "导出物品"
SELECT_ITEMS_TO_EXPORT_LABEL = "选择要导出的项目："

EXPORT_FILE_PATH = "选择要导出到的文件："
RULES_GROUP = "规则"
RULE_MODULES_GROUP = "分析模块"
EXPORT_BUTTON = "导出"
EXPORT_STATUS_MESSAGE = "已将 %1 项导出到文件 %2"
OVERWRITE_FILE_PROMPT = "覆盖现有文件？"

[SAMPLE_RULE]
Max Name Length="最大步骤名称长度"

[ANALYZER_RULE_CATEGORIES]
GENERAL = "一般"
STATISTICS="统计"
BEST_PRACTICES = "最佳实践"
PERFORMANCE="性能"
INTERNAL = "分析错误"

[ANALYZER_EDIT_JUSTIFICATION_DIALOG]
EDIT_JUSTIFICATION_DIALOG_TITLE = "忽略分析消息"
EDIT_JUSTIFICATION_DIALOG_TITLE_MULTIPLE = "忽略分析消息"
ENTER_JUSTIFICATION_FOR_IGNORING = "输入忽略此消息的理由："
ENTER_JUSTIFICATION_FOR_IGNORING_MULTIPLE = "输入忽略这些消息的理由："

[NI_RULES]
;;内置规则名称和描述。
;;如果您修改了这些描述，请通知技术作者，以便他们更新相应的帮助主题。
INTERNAL_ERROR_NAME = "内部错误"
INTERNAL_ERROR_DESCRIPTION Line0001 = "序列分析器使用此规则报告分析期间发生的内部错误。这些消息\n"
INTERNAL_ERROR_DESCRIPTION Line0002 = "通常表示序列分析器的组件存在严重问题。将信息报告给\n"
INTERNAL_ERROR_DESCRIPTION Line0003 = "组件所有者或 National Instruments。您不能禁用此规则。"

FILE_OPEN_ERROR_NAME = "文件打开错误"
FILE_OPEN_ERROR_DESCRIPTION Line0001 = "序列分析器使用此规则报告在分析过程中打开文件时发生的错误。\n"
FILE_OPEN_ERROR_DESCRIPTION Line0002 = "你不能禁用这个规则。"

FILE_LOCKED_ERROR_NAME = "文件锁定错误"
FILE_LOCKED_ERROR_DESCRIPTION Line0001 = "序列分析器使用此规则报告无法分析的文件错误，因为\n"
FILE_LOCKED_ERROR_DESCRIPTION Line0002 = "文件已锁定且不可查看。您无法禁用此规则。"

INVALID_PROPERTY_NAME = "步骤属性必须有有效值"
INVALID_PROPERTY_DESCRIPTION Line0001 = "所有步骤属性都必须具有有效值。无效的属性值会导致运行时出错。\n"
INVALID_PROPERTY_DESCRIPTION Line0002 = "使用步骤设置窗格将属性设置为有效值。如果属性无效，请忽略此消息\n"
INVALID_PROPERTY_DESCRIPTION Line0003 = "将在运行时动态设置为正确的值。"

UNUSED_VARIABLES_NAME = "应该使用变量"
UNUSED_VARIABLES_DESCRIPTION Line0001 = "未使用的变量和参数给序列文件增加了不必要的复杂性和无关信息。\n"
UNUSED_VARIABLES_DESCRIPTION Line0002 = "如果您从未访问过变量，请删除它们。对于您访问过的变量，您可以忽略此规则\n"
UNUSED_VARIABLES_DESCRIPTION Line0003 = "在代码模块中，或者您使用带有 TestStand API 的查找字符串访问的代码模块。"

FILE_NOT_FOUND_NAME = "文件/目录必须在磁盘上找到"
FILE_NOT_FOUND_DESCRIPTION Line0001 = "文件/目录路径必须引用磁盘上现有的文件/目录。如果不能，TestStand 可以在运行时报告错误\n"
FILE_NOT_FOUND_DESCRIPTION Line0002 = "找到路径指定的文件/目录。通过更正路径或创建来解决问题\n"
FILE_NOT_FOUND_DESCRIPTION Line0003 = "磁盘上的文件/目录。如果文件/目录是在运行时动态创建的，您可以安全地忽略此消息。"

FILE_NOT_FOUND_WARNING_NAME = "文件应该在磁盘上找到"
FILE_NOT_FOUND_WARNING_DESCRIPTION Line0001 = "文件路径应引用磁盘上的现有文件。TestStand 不会在运行时报告错误\n"
FILE_NOT_FOUND_WARNING_DESCRIPTION Line0002 = "这些文件，但找不到指定的路径。通过更改路径以指向正确的路径来纠正问题\n"
FILE_NOT_FOUND_WARNING_DESCRIPTION Line0003 = "文件或通过在磁盘上创建文件。如果文件是在运行时动态创建的，请忽略此消息。"

NORMAL_RUN_MODE_NAME = "步骤应该有正常运行模式"
NORMAL_RUN_MODE_DESCRIPTION Line0001 = "步骤的运行模式选项应设置为正常，而不是强制通过、强制失败或跳过，以确保 "
NORMAL_RUN_MODE_DESCRIPTION Line0002 = "测试正确执行。更正步骤设置窗格的运行选项面板上的设置"
NORMAL_RUN_MODE_DESCRIPTION Line0003 = "在 TestStand 序列编辑器中。如果有意将步骤设置为此运行模式，请忽略此消息。"

EXPRESSION_EVAL_NAME = "表达式的计算结果必须是预期类型的值"
EXPRESSION_EVAL_DESCRIPTION Line0001 = "每个表达式属性不得包含语法错误并且必须求值为该类型的值\n "
EXPRESSION_EVAL_DESCRIPTION Line0002 = "属性预期。语法错误和不正确的值类型会导致运行时出错。\n"
EXPRESSION_EVAL_DESCRIPTION Line0003 = "如果你确定表达式将在运行时正确计算，比如当你动态\n"
EXPRESSION_EVAL_DESCRIPTION Line0004 = "创建变量或传播变量时，在表达式中使用#NoValidation 指令\n"
EXPRESSION_EVAL_DESCRIPTION Line0005 = "抑制错误。"

SUPPRESSED_EVAL_ERRORS_NAME = "查找抑制计算错误的表达式"
SUPPRESSED_EVAL_ERRORS_DESCRIPTION Line0001 = "使用#NoValidation 指令抑制语义评估错误的表达式\n"
SUPPRESSED_EVAL_ERRORS_DESCRIPTION Line0002 = "可能包含实际的运行时错误。"

MODULE_LOADABLE_NAME = "代码模块必须能够加载"
MODULE_LOADABLE_DESCRIPTION Line0001 = "TestStand 必须能够无错地加载所有代码模块。TestStand 在运行时报告错误\n"
MODULE_LOADABLE_DESCRIPTION Line0002 = "无法加载代码模块。通过在序列编辑器中编辑步骤来纠正此问题。"

MODULE_LOAD_WARNINGS_NAME = "代码模块应该在没有警告的情况下加载"
MODULE_LOAD_WARNINGS_DESCRIPTION Line0001 = "TestStand 应该能够在没有警告的情况下加载所有代码模块。模块加载警告是问题\n"
MODULE_LOAD_WARNINGS_DESCRIPTION Line0002 = "在尝试加载可能致命或可能不致命或导致意外行为的代码模块时发生。\n"
MODULE_LOAD_WARNINGS_DESCRIPTION Line0003 = "通过在序列编辑器中编辑步骤来更正此问题。"

PROTOTYPE_COMPATIBLE_NAME = "代码模块必须有预期的原型"
PROTOTYPE_COMPATIBLE_DESCRIPTION Line0001 = "代码模块的原型必须与步骤模块指定的原型相匹配。TestStand 报告\n"
PROTOTYPE_COMPATIBLE_DESCRIPTION Line0002 = "加载带有不兼容原型的代码模块时在运行时出错。更正问题\n"
PROTOTYPE_COMPATIBLE_DESCRIPTION Line0003 = "通过在 TestStand 中编辑步骤模块以匹配代码模块或通过更改代码模块原型\n"
PROTOTYPE_COMPATIBLE_DESCRIPTION Line0004 = "匹配步骤模块。"

REMOTE_HOST_NAME = "远程计算机必须在网络上"
REMOTE_HOST_DESCRIPTION Line0001 = "引用远程计算机的步骤属性必须通过 IP 地址或计算机名称指定有效的网络计算机。\n"
REMOTE_HOST_DESCRIPTION Line0002 = "如果计算机在运行时存在，请忽略此消息。"

BLOCK_ERRORS_NAME = "步骤必须具有预期的块结构"
BLOCK_ERRORS_DESCRIPTION Line0001 = "具有块结构的步骤，例如流程控制步骤和自动计划步骤，必须匹配\n"
BLOCK_ERRORS_DESCRIPTION Line0002 = "结束步骤，结束步骤必须有一个匹配的开始步骤。Select/Case 存在其他块要求\n"
BLOCK_ERRORS_DESCRIPTION Line0003 = "和自动调度/使用自动调度资源步骤。TestStand 在运行时报告无效的错误\n"
BLOCK_ERRORS_DESCRIPTION Line0004 = "块结构。"

UNUSED_SEQUENCE_NAME = "应使用序列"
UNUSED_SEQUENCE_DESCRIPTION Line0001 = "未使用的序列向序列文件添加无关信息并不必要地增加大小\n"
UNUSED_SEQUENCE_DESCRIPTION Line0002 = "文件的。如果你从不使用它们，请删除序列。你可以忽略你调用的序列的这个错误\n"
UNUSED_SEQUENCE_DESCRIPTION Line0003 = "通过表达式或者如果您从未分析的序列文件中调用序列。"

SEQUENCE_PROTOTYPE_NAME = "序列调用应该匹配序列原型"
SEQUENCE_PROTOTYPE_DESCRIPTION Line0001 = "序列调用步骤调用的序列原型应该与原型匹配\n"
SEQUENCE_PROTOTYPE_DESCRIPTION Line0002 = "该步骤指定。对于您打算传递不同的序列调用，您可以忽略此规则\n"
SEQUENCE_PROTOTYPE_DESCRIPTION Line0003 = "参数集，如果您检查调用序列中的参数。"

PROPERTY_COUNT_NAME = "计数属性"
PROPERTY_COUNT_DESCRIPTION Line0001 = "所有分析文件中的属性总数。"

STEP_COUNT_NAME = "计算步数"
STEP_COUNT_DESCRIPTION Line0001 = "所有分析文件中的总步骤数。\n每个序列的计数：%(COUNT_PER_SEQUENCE)\n每个序列文件的计数：%(COUNT_PER_FILE)\n每个分析的计数：%(COUNT_PER_ANALYSIS)"

SEQUENCE_COUNT_NAME = "计数序列"
SEQUENCE_COUNT_DESCRIPTION Line0001 = "所有分析文件中的序列总数。\n每个序列文件的计数：%(COUNT_PER_FILE)\n每个分析的计数：%(COUNT_PER_ANALYSIS)"

SEQUENCE_FILE_COUNT_NAME = "计数序列文件"
SEQUENCE_FILE_COUNT_DESCRIPTION Line0001 = "分析的序列文件总数。"

FILE_BY_EXPRESSION_NAME = "查找表达式指定的文件路径"
FILE_BY_EXPRESSION_DESCRIPTION Line0001 = "路径表达式引用的文件可能不包含在要分析的文件集中。\n"
FILE_BY_EXPRESSION_DESCRIPTION Line0002 = "此规则提供了这些表达式的列表。您可能需要手动添加文件表达式\n"
FILE_BY_EXPRESSION_DESCRIPTION Line0003 = "参考工作区以进行正确部署。"

WATCH_EXPRESSIONS_ENABLED_NAME = "监视表达式已启用"
WATCH_EXPRESSIONS_ENABLED_DESCRIPTION Line0001 = "在执行期间使用监视表达式会对性能产生负面影响并导致速度变慢\n"
WATCH_EXPRESSIONS_ENABLED_DESCRIPTION Line0002 = "执行速度。仅在调试时使用观察表达式。选择调试>>断点/观察表达式\n"
WATCH_EXPRESSIONS_ENABLED_DESCRIPTION Line0003 = "删除未使用的监视表达式。"


ABSOLUTE_PATHS_NAME = "避免使用绝对路径"
ABSOLUTE_PATHS_DESCRIPTION Line0001 = "绝对路径使得在测试系统之间移动文件变得困难。使用相对路径来指定文件。"

FILE_PATHS_VALID_NAME = "所有文件路径必须具有有效格式"
FILE_PATHS_VALID_DESCRIPTION Line0001 = "所有文件路径变量必须包含有效语法。序列分析器只验证\n"
FILE_PATHS_VALID_DESCRIPTION Line0002 = "路径的语法是正确的，并且不确认文件存在于每个位置。"

CODE_MODULE_OUT_OF_DATE_NAME = "代码模块应该是最新的。"
CODE_MODULE_OUT_OF_DATE_DESCRIPTION Line0001 = "代码模块应该是最新的。序列分析器检查文件修改"
CODE_MODULE_OUT_OF_DATE_DESCRIPTION Line0002 = "代码模块的时间比指定的源文件的时间更新"
CODE_MODULE_OUT_OF_DATE_DESCRIPTION Line0003 = " 在适配器步骤中。\n\n"
CODE_MODULE_OUT_OF_DATE_DESCRIPTION Line0004 = "注意：序列分析器只检查在适配器步骤中指定的源代码文件、项目文件和解决方案/工作区文件。"
CODE_MODULE_OUT_OF_DATE_DESCRIPTION Line0005 = "它不对包含的头文件、代码模块使用的其他源文件等执行一般依赖性检查。"

ESCAPE_SEQUENCES_VALID_NAME = "表达式中使用的所有转义序列必须有效"
ESCAPE_SEQUENCES_VALID_DESCRIPTION Line0001 = "序列分析器检查有效转义序列的表达式。转义不当\n"
ESCAPE_SEQUENCES_VALID_DESCRIPTION Line0002 = "路径通常会导致使用无效的转义序列，这很少是故意的。"

DYNAMIC_PROPERTY_DOES_NOT_EXIST_NAME = "缺少动态属性导致的表达式错误"
DYNAMIC_PROPERTY_DOES_NOT_EXIST_DESCRIPTION Line0001 = "使用动态属性的表达式，例如 RunState，将在编辑时计算错误。\n"
DYNAMIC_PROPERTY_DOES_NOT_EXIST_DESCRIPTION Line0002 = "确保引用的变量在运行时存在。当\n"
DYNAMIC_PROPERTY_DOES_NOT_EXIST_DESCRIPTION Line0003 = "由于缺少以 RunState 开头的变量，出现表达式计算错误\n"
DYNAMIC_PROPERTY_DOES_NOT_EXIST_DESCRIPTION Line0004 = "或参数且参数是容器或对象引用。如果此变量\n"
DYNAMIC_PROPERTY_DOES_NOT_EXIST_DESCRIPTION Line0005 = "将在运行时存在，您可以安全地忽略此消息。"

TYPE_VERSION_INVALID_NAME = "类型应该有正确的版本"
TYPE_VERSION_INVALID_DESCRIPTION Line0001 = "确保所有类型的版本都不会与 TestStand 安装的默认版本冲突。这\n"
TYPE_VERSION_INVALID_DESCRIPTION Line0002 = "当您拥有低于 3.1.0.100 的 CommonResults 副本时，可能会出现此消息。National Instruments 建议\n"
TYPE_VERSION_INVALID_DESCRIPTION Line0003 = "如果 CommonResults 不包含子属性，则将其版本设置为默认值 3.1.0.100，如果它包含，则将 CommonResults 的版本设置为大于 3.1.0.100\n"
TYPE_VERSION_INVALID_DESCRIPTION Line0004 = "包含子属性。未能更改版本可能导致加载文件时发生类型冲突。"

LV_CHECKSUM_INVALID_NAME = "调用使用 LabVIEW 7.1.1 或更早版本配置的 LabVIEW 模块的步骤应该重新加载模块原型"
LV_CHECKSUM_INVALID_DESCRIPTION Line0001 = "调用 LabVIEW 代码模块的步骤中存储的原型信息可能与 LabVIEW 2012 或更高版本不兼容。\n"
LV_CHECKSUM_INVALID_DESCRIPTION Line0002 = "调用 LabVIEW 代码模块的步骤会出现此警告，并且该步骤最后使用 LabVIEW 7.1.1 或更早版本配置。\n"
LV_CHECKSUM_INVALID_DESCRIPTION Line0003 = "该步骤正确调用代码模块，但 TestStand 在使用 LabVIEW 2012 或执行该步骤时可能会产生错误。"
LV_CHECKSUM_INVALID_DESCRIPTION Line0004 = "稍后。National Instruments 建议您重新加载该步骤的原型或选择工具>>更新 VI 调用 "
LV_CHECKSUM_INVALID_DESCRIPTION Line0005 = "对任何返回此警告的序列文件运行更新 VI 调用工具。"

NI_PARTIAL_OUTPUT_ARRAY_LOGGED_NAME = "如果您打算记录整个数组，请删除输出数组参数的子元素"
NI_PARTIAL_OUTPUT_ARRAY_LOGGED_DESCRIPTION Line0001 = "如果您在 LabVIEW 或 .NET 步骤上为输出数组参数启用额外的结果记录并且该参数包含子元素，\n"
NI_PARTIAL_OUTPUT_ARRAY_LOGGED_DESCRIPTION Line0002 = "该步骤仅记录子元素而不是整个数组。如果您在以下时间手动添加子元素，则数组参数包含子元素\n"
NI_PARTIAL_OUTPUT_ARRAY_LOGGED_DESCRIPTION Line0003 = "您指定了代码模块，或者如果代码模块是定义数组默认元素值的 LabVIEW VI。记录\n"
NI_PARTIAL_OUTPUT_ARRAY_LOGGED_DESCRIPTION Line0004 = "整个数组，在指定代码模块时删除所有参数子元素。如果您打算只记录，请忽略此消息\n"
NI_PARTIAL_OUTPUT_ARRAY_LOGGED_DESCRIPTION Line0005 = "参数子元素。"

MODEL_SEQUENCES_RESULTS_ENABLED_NAME = "禁用除 MainSequence 回调之外的所有流程模型序列的结果记录"
MODEL_SEQUENCES_RESULTS_ENABLED_DESCRIPTION Line0001= "如果您为除 MainSequence 回调之外的流程模型序列启用结果记录，即时报告可能无法工作\n"
MODEL_SEQUENCES_RESULTS_ENABLED_DESCRIPTION Line0002= "正确。禁用除 MainSequence 回调之外的所有流程模型序列的结果记录。"

INVALID_ENUMERATION_NAME = "枚举值必须有效"
INVALID_ENUMERATION_DESCRIPTION = "枚举类型的每个实例都必须有一个类型定义为有效的值。"

NOT_SUPPORTED_FEATURE = "不支持该功能"
NOT_SUPPORTED_FEATURE_DESC = "您正在使用的 TestStand 的当前位数不支持该功能。"

;;通用的

INVALID_FILE_MSG = "找不到文件 '%1'。"
NOT_SUPPORTED_IN_32BIT = "32 位 TestStand 不支持此功能。"
NOT_SUPPORTED_IN_64BIT = "64 位 TestStand 不支持此功能。"

;;
;;步骤类型

;;字符串值测试
INVALID_STRING_LIMIT_COMPARISON_TYPE_MSG= "无效的比较类型枚举：%1。"

;;多数值极限测试
INVALID_MULTIPLE_NUMERIC_LIMIT_INCONSISTENT_NUM_LIMITS_MSG = "数据源数量 (%1) 与限制数量 (%2) 不一致。"
INVALID_MULTIPLE_NUMERIC_LIMIT_EXTRA_DATA_ACTION_MSG = "无效的额外数据枚举：%1。"
INVALID_MULTIPLE_NUMERIC_LIMIT_EXTRA_MEAS_ACTION_MSG = "无效的额外测量枚举：%1。"
INVALID_MULTIPLE_NUMERIC_LIMIT_MEAS_TO_REPEAT_MSG = "要重复的测量无效：%1。"
INVALID_MULTIPLE_NUMERIC_LIMIT_NO_LIMITS_MSG = "多个数字限制步骤必须至少定义一个限制。"
INVALID_MULTIPLE_NUMERIC_LIMIT_EXPECTED_LIMITS_MSG = "无效的预期测量数 (%1)。Step.ExpectedNumMeas 属性必须与限制数 (%2) 相同。"

;;数值限制
INVALID_NUMERIC_LIMIT_COMPARISON_TYPE_MSG = "无效的比较类型枚举：%1。"
INVALID_NUMERIC_LIMIT_THRESHOLD_TYPE_MSG = "无效的阈值类型枚举：%1。"
LOW_LIMIT_LARGER_MSG = "下限 (%1) 大于或等于上限 (%2)。"

;;消息弹出

NO_BUTTON_TEXT_MSG = "至少一个按钮必须有文本。"
INVALID_NUMBER_OF_LINES_MSG = "可见行数 (%1) 必须是大于 0 的整数。"
INVALID_MAX_RESPONSE_LENGTH_MSG = "最大响应长度 (%1) 必须是大于 0 的整数。"
INVALID_FILE_SOURCE_OPTION_MSG = "无效的文件源枚举：%1。"
INVALID_ACTIVE_CONTROL_MSG = "无效的活动控件枚举：%1。"
INVALID_DEFAULT_BUTTON_MSG = "无效的默认按钮枚举：%1。"
INVALID_TIMEOUT_BUTTON_MSG = "无效的超时按钮枚举：%1。"
INVALID_CANCEL_BUTTON_MSG = "无效的取消按钮枚举：%1。"
INVALID_TIME_TO_WAIT_MSG = "等待时间 (%1) 必须大于 0。"
INVALID_CONTROL_ARRNAGEMENT_MSG = "无效的控制安排枚举：%1。"
INVALID_BUTTON_ALIGNMENT_MSG = "无效的按钮对齐枚举：%1。"
INVALID_BUTTON_LOCATION_MSG = "无效的按钮位置枚举：%1。"
INVALID_RESIZE_OPTION_MSG = "无效的调整大小选项枚举：%1。"

;;调用可执行文件
;;在消息弹出窗口中重复 -> INVALID_TIME_TO_WAIT_MSG ="等待时间 (%1) 必须大于 0。"
INVALID_EXIT_CODE_STATUS_ACTION_MSG = "无效的退出代码失败条件枚举：%1。"
INVALID_EXIT_CODE_ERROR_ACTION_MSG = "无效的退出代码错误条件枚举：%1。"
CONFLICTING_EXIT_CODE_ACTIONS_MSG = "退出代码失败条件 (%1) 和退出代码错误条件 (%2) 重叠，可能会给出不正确的结果。"
INVALID_STDINPUT_TYPE_MSG = "无效的标准输入法枚举：%1。"
INVALID_STDOUTPUT_DEST_MSG = "无效的标准输出目标枚举：%1。"
INVALID_STDERROR_DEST_MSG = "无效的标准错误目标枚举：%1。"
INVALID_STDERROR_ACTION_MSG = "无效的标准错误操作枚举：%1。"
INVALID_WAIT_CONDITION_MSG = "无效的等待条件枚举：%1。"
INVALID_INIT_WINDOW_STATE_MSG = "无效的初始窗口状态枚举：%1。"
INVALID_WORKING_DIR_OPTION_MSG = "无效的工作目录枚举：%1。"
INVALID_REMOTE_FILE_MSG = "远程机器上的文件只对远程调用有效。"

;;字体
FONT_SIZE_INVALID_MSG = "无效的字体大小 (%1)。它必须大于 0。"

;;消息弹出
INVALID_DECIMAL_POINT_OPTION_MSG = "无效的小数点枚举：%1。"
INVALID_FILE_FORMAT_MSG = "无效的文件格式枚举：%1。"
INVALID_START_MARKER_NOT_FOUND_ACTION_MSG = "未找到无效的开始标记枚举：%1。"
INVALID_DATA_LOCATION_MSG = "无效的数据位置枚举：%1。"

;;选择
INVALID_SELECT_CHILD_STEP_MSG = "在 Select 块中发现意外的步骤类型 (%1)。只有 Case 块可以嵌套在 Select 块中。"
TOO_MANY_DEFAULT_CASES_MSG = "找到太多默认案例步骤。每个选择块只能将一个案例标记为默认案例。"

;;继续
INVALID_CONTINUE_PARENT_MSG = "在有效块之外发现了继续步骤。继续步骤必须位于 For 循环、For Each 循环、While 循环或 Do While 循环中。"

;;休息
INVALID_Break_PARENT_MSG = "在有效块之外发现了 Break 步骤。Break 步骤必须位于 For 循环、For Each 循环、While 循环、Do While 循环或 Select 块中。"


;;锁
INVALID_LOCK_REF_LIFETIME_MSG = "无效的锁引用生命周期枚举：%1。"
INVALID_LOCK_OPERATION_LIFETIME_MSG = "无效的锁定操作生命周期枚举：%1。"
INVALID_LOCK_OPERATION_MSG = "无效的锁定操作枚举：%1。"

;;会合
INVALID_RENDEZVOUS_REF_LIFETIME_MSG = "无效的集合点引用生命周期枚举：%1。"
INVALID_RENDEZVOUS_OPERATION_MSG = "无效的会合操作枚举：%1。"

;;队列
INVALID_QUEUE_OPERATION_MSG = "无效的队列操作枚举：%1。"
INVALID_QUEUE_REF_LIFETIME_MSG = "无效的队列引用生命周期枚举：%1。"
INVALID_ENQUEUE_LOCATION_MSG = "无效的插入枚举：%1。"
INVALID_FULL_QUEUE_OPTION_MSG = "无效的完整队列操作枚举：%1。"
INVALID_DEQUEUE_LOCATION_MSG = "从枚举中无效出队：%1。"

;;通知
INVALID_NOTIFICATION_OPERATION_MSG = "无效的通知操作枚举：%1。"
INVALID_NOTIFICATION_REF_LIFETIME_MSG = "无效的通知引用生命周期枚举：%1。"
INVALID_NOTIFICATION_PULSE_NOTIFY_OPTION_MSG = "无效的脉冲通知枚举：%1。"

;;等待
INVALID_WAIT_OPERATION_MSG = "无效的等待操作枚举：%1。"
INVALID_WAIT_SEQUENCE_STEP_GROUP_MSG = "无效步骤组枚举：%1。"
INVALID_WAIT_SEQUENCE_STEP_MSG = "找不到序列调用步骤 (%1)。"
INVALID_WAIT_SEQUENCE_CALL_STEP_ADAPTER_MSG = "步骤 (%1) 不是序列调用。"
INVALID_WAIT_SEQUENCE_CALL_MULTITHREAD_OPTION_MSG = "步骤 (%1) 没有预期的多线程选项（预期 %2，找到 %3）。"

;;批量同步
INVALID_BATCH_SYNC_SECTION_TYPE_MSG = "无效的批同步部分类型枚举：%1。"
INVALID_BATCH_SYNC_OPERATION_MSG = "无效的批处理同步操作枚举：%1。"

;;自动安排
INVALID_AUTOSCHEDULE_CHILD_STEP_MSG = "自动计划块内的步骤 (%1) 无效。自动计划块内仅允许立即使用资源步骤。"

;;使用自动调度的资源
AUTOSCHEDULE_RESOURCE_NO_EXPRESSIONS = "没有使用资源表达式。自动调度资源步骤必须至少有一个资源表达式。"

;;线程优先级
INVALID_THREAD_PRIORITY_OPERATION_MSG = "无效的线程优先级操作枚举：%1。"

;;信号
INVALID_SEMAPHORE_LIFETIME_MSG = "无效的信号量生命周期枚举：%1。"
INVALID_SEMAPHORE_OPERATION_MSG = "无效的信号量操作枚举：%1。"
INVALID_SEMAPHORE_ACQUIRE_LIFETIME_MSG = "无效的信号量获取生命周期枚举：%1。"

;;批量规范
INVALID_BATCH_SPECIFICATION_LIFETIME_MSG = "无效的批次规范生命周期枚举：%1。"
INVALID_BATCH_SPECIFICATION_OPERATION_MSG = "无效的批处理规范操作枚举：%1。"

;;CPU亲和力
INVALID_CPU_AFFINITY_OPERATION_MSG = "无效的 CPU 关联操作枚举：%1。"


;;打开SQL语句
INVALID_OPEN_SQL_CURSOR_TYPE_MSG = "无效的游标类型枚举：%1。"
INVALID_OPEN_SQL_CURSOR_LOCATION_MSG = "无效的游标位置枚举：%1。"
INVALID_OPEN_SQL_MARSHAL_OPTION_MSG = "无效的 Marshal 选项枚举：%1。"
INVALID_OPEN_SQL_LOCK_TYPE_MSG = "无效的 LockType 枚举：%1。"
INVALID_OPEN_SQL_COMMAND_TYPE_MSG = "无效的命令类型枚举：%1。"

;;数据操作
INVALID_DATA_OPERATION_MSG = "无效操作枚举：%1。"
INVALID_RECORD_TO_OPERATE_MSG = "对枚举操作的无效记录：%1。"

;;Dmm
INVALID_DMM_DATA_TYPE_MSG = "无效的数据类型枚举：%1。"
INVALID_DMM_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;范围
INVALID_SCOPE_DATA_TYPE_MSG = "无效的数据类型枚举：%1。"
INVALID_SCOPE_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;F生成
INVALID_FGEN_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;直流电源
INVALID_DCPOWER_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;转变
INVALID_SWITCH_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;IVI 工具
INVALID_IVITOOLS_OPERATION_MSG = "无效的仪器操作枚举：%1。"

;;检查远程系统
INVALID_CHECK_REMOTE_SYSTEM_PORT_NUMBER_MSG = "无效端口号 (%1)。端口必须介于 0 和 65535 之间。"
INVALID_CHECK_REMOTE_TIMEOUT_MSG = "无效的连接超时 (%1)。超时必须大于或等于 0。"

;;运行 VI 异步
INVALID_VI_ASYNC_PORT_NUMBER_MSG= "无效端口号 (%1)。端口必须介于 0 和 65535 之间。"
INVALID_VI_ASYNC_TIMEOUT_MSG = "无效的连接超时 (%1)。超时必须大于或等于 0。"

;;关闭会话
INVALID_CREATE_SESSION_STEP_MSG = "找不到创建 Sesison 和应用配置步骤 (%1)。"
INVALID_CREATE_SESSION_STEP_TYPE_INVALID_MSG = "步骤 (%1) 不是创建 Sesison 和应用配置步骤。"

;;创建和应用会话
INVALID_PLUGIN_ID_MSG = "未找到 ID 为"%1"的 IO 配置插件。"

;;部署库
INVALID_DEPLOY_LIBRARY_OPERATION_MSG = "无效操作枚举：%1。"

;;
;;步骤设置

;;一般的
ICON_NOT_FOUND_MSG = "找不到图标 '%1'。所有图标必须位于 <TestStand>/Components/Icons/ 或 <TestStand Public>/Components/Icons/ 目录中。"
UNMATCHED_BLOCK_MSG = "该步骤打开或关闭一个块，但匹配的步骤不存在。"

;;运行选项
INVALID_LOAD_OPTION_MSG = "无效的加载选项枚举：%1。"
INVALID_UNLOAD_OPTION_MSG = "无效的卸载选项枚举：%1。"
INVALID_RUN_OPTION_MSG = "无效的运行选项枚举：%1。"
INVALID_PRECONDITION_INTERACTIVE_MSG = "交互模式枚举中的无效前提条件评估：%1。"
INVALID_WINDOW_ACTIVATION_ENUMERATION_MSG = "无效的窗口激活枚举：%1。"
INVALID_RESULT_RECORDING_ENUMERATION_MSG = "无效的结果记录选项枚举：%1。"
SKIPPED_OR_FORCED_STEP_MSG = "步骤运行模式设置为 %1。"

;;循环
INVALID_LOOP_TYPE_MSG = "无效循环类型枚举：%1。"
INVALID_PASS_RATE_MSG = "循环结果百分比 (%1) 必须介于 0 和 100 之间。"
INVALID_LOOP_CONFIGURATION_MSG = "循环类型设置与循环表达式不匹配。"
MAX_NUM_LOOPS_LESS_THAN_ITERATIONS_MSG = "最大循环数 (%1) 小于迭代数 (%2)。"

;;发布操作
INVALID_POST_ACTION_TARGET_STEP_MSG = "无法找到后操作目标步骤 (%1)。"
INVALID_POST_ACTION_TARGET_SEQ_MSG = "无法找到后操作目标序列 (%1)。"
INVALID_POST_ACTION_TYPE_MSG = "无效的操作后枚举：%1。"

;;交换
INVALID_VIRTUAL_DEVICE_MSG = "虚拟设备 (%1) 不存在。"
INVALID_SWITCHING_OPERATION_MSG = "无效的切换操作枚举：%1。"
INVALID_MULTICONNECT_MODE_MSG = "无效的多重连接模式枚举：%1。"
INVALID_CONNECTION_LIFETIME_MSG = "无效的连接生存期枚举：%1。"
INVALID_OPERATION_LIFETIME_MSG = "无效的操作订单枚举：%1。"

;;同步
INVALID_BATCH_SYNC_OPTION_MSG = "无效的批同步枚举：%1。"


;;适配器

;;LabVIEW
PROJECT_FILE_PATH_INVALID_MSG = "找不到项目路径 '%1'。"
VI_FILE_PATH_INVALID_MSG = "无法找到 VI 路径 '%1'。"
VI_PROJECT_HAS_CONFLICTS_MSG = "项目 '%1' 有冲突：%2"
LABVIEW_INVALID_PORT_NUMBER_MSG = "无效端口号 (%1)。端口必须介于 0 和 65535 之间。"
LABVIEW_INVALID_CONNECTION_TIMEOUT_MSG = "无效的连接超时 (%1)。超时必须大于或等于 0。"
VI_PROJECT_WITH_EXPRESS_VIS_MSG = "Express VI 不能用于 LabVIEW 项目。"
CLASS_FILE_PATH_INVALID_MSG = "找不到类路径 '%1'。"
PROPERTY_NODE_FILE_PATH_INVALID_MSG = "找不到 VI 路径 '%1'。"
PROPERTY_NODE_UNABLE_TO_EXPORT_VI = "无法为类 '%1' 的属性节点调用导出 VI。"
MEMBER_NAME_INVALID_MSG = "找不到成员名称 '%1'。"

;;LabVIEWNXG
PROJECT_PATH_EMPTY = "未指定项目路径。"
GLL_PATH_EMPTY = "未指定 GLL 路径。"
GLL_GENERATED_DURING_EXECUTION = "未找到 GLL '%1'。它将在执行开始时构建，因为选择了'自动构建缺少的 GLL' 选项。"

;;序列调用
SEQUENCE_PROTOTYPE_WARNING_MSG = "步骤 '%1' 的原型与相应的序列调用不同。"
SEQUENCE_NOT_FOUND_MSG = "序列 '%1' 在指定的文件中不存在。"
SEQUENCE_NOT_ENTRY_POINT_MSG = "序列 '%1' 不是入口点。"

CALLBACK_PROTOTYPE_TYPE_ERROR_MSG = "参数 '%1' 必须与流程模型回调中的参数类型相同，因为此参数已启用类型检查。您必须更改参数类型以匹配流程模型中的参数类型以避免运行-时间错误。"
CALLBACK_PROTOTYPE_TYPE_WARNING_MSG = "参数 '%1' 与流程模型回调中的参数类型不同。由于类型检查被禁用，流程模型在运行时覆盖此参数。National Instruments 建议所有回调使用定义的相同原型在过程模型中。"
CALLBACK_NAME_WARNING_MSG = "参数 '%1' 使用的名称与过程模型定义的名称不同。National Instruments 建议所有回调使用过程模型中定义的相同原型。"
CALLBACK_EXTRA_PARAMETER_MSG = "过程模型没有定义参数 '%1'。当你执行序列时，回调不会传递一个值给这个参数。NI 建议删除这个参数以与过程模型保持一致。"
CALLBACK_MISSING_PARAMETER_MSG = "过程模型定义了参数 '%1'，但回调没有。美国国家仪器公司建议在客户端序列中将此参数添加到过程模型回调中，以与过程模型保持一致。"
CALLBACK_BATCHMODELDATA_MSG Line0001 = "参数 %1 是 NI_BatchModelData 类型，但 TestStand 期望参数是 NI_BatchModelData2 类型。TestStand 2012 将 PreBatch、PostBatch 和 BatchReport 回调的 ModelData 参数类型从 NI_BatchModelData 更改为 NI_BatchModelData2。"
CALLBACK_BATCHMODELDATA_MSG Line0002 = " NI_BatchModelData2 类型不再包含与数据库或报告相关的字段。您现在可以在 ResultProcessingConfiguration 参数中访问此信息。如果回调访问 ModelData 参数的数据库或报告特定字段，则必须更新回调或使用等效的遗留流程模型。"

;;常见的
MODULE_NOT_LOADABLE_MSG = "步骤 '%1' 的模块不可加载。"
MODULE_NOT_LOADABLE_DETAILED_MSG = "步骤 '%1' 的模块不可加载。%2"
PROTOTYPE_INCOMPATIBLE_MSG = "步骤 '%1' 的原型与其模块不兼容。"

PARTIAL_OUTPUT_ARRAY_LOGGED_MSG = "TestStand 没有将参数 '%1' 的输出数组的所有元素记录为附加结果。"

;;表达式中的文件
FILE_BY_EXPRESSION_MSG = "表达式指定的文件：%1。"
UNSAVED_FILE_STRING = "<未保存的文件>"
CODE_MODULE_OUT_OF_DATE_MSG = "源文件 '%1' 比代码模块 '%2' 最近修改。"

;;一般的
UNUSED_SEQUENCE_MSG = "可能未使用的序列：%1。"
UNUSED_VARIABLE_MSG = "可能未使用的变量：%1。"
WATCH_EXPRESSIONS_ENABLED_MSG = "监视表达式当前已启用。"
ABSOLUTE_PATH_MSG = "指定的绝对路径：%1。"
INVALID_ESCAPE_SEQUENCE_MSG = "表达式中的转义序列无效：%1。"
INVALID_ESCAPE_SEQUENCE_PATH_MSG = "表达式 '%1' 是一个路径。使用 '\\\\' 而不是 '\\'。"
INVALID_PATH_MSG = "路径 '%1' 不是有效路径。"
INVALID_TYPE_VERSION_TOO_OLD_MSG = "型号 %1 (%2) 比 %3 旧。"
INVALID_LV_CHECKSUM_MSG = "步骤 '%1' 使用 LabVIEW 7.1.1 或更早版本配置，应重新加载。"
SUPPRESSED_EXPR_ERROR_MSG = "抑制表达式评估错误：%1"
MODEL_RESULTS_ENABLED_ERROR_MSG = "序列 %1 已启用结果记录。禁用除 MainSequence 之外的所有流程模型序列的结果记录。"

;;远程主机
HOST_NOT_FOUND_MSG = "无法找到远程主机 %1。"

;;统计数据

GLOBAL_PROPERTY_COUNT_MSG = "分析的属性总数：%1"
FILE_PROPERTY_COUNT_MSG = "已分析文件 '%1' 中的属性：%2"
SEQUENCE_PROPERTY_COUNT_MSG = "已分析文件 '%2' 中序列 '%1' 的属性：%3"
GLOBAL_STEP_COUNT_MSG = "分析的总步数：%1"
FILE_STEP_COUNT_MSG = "分析文件 '%1' 中的步骤：%2"
SEQUENCE_STEP_COUNT_MSG = "已分析文件 '%2' 中序列 '%1' 中的步骤：%3"
GLOBAL_SEQUENCE_COUNT_MSG = "分析的序列总数：%1"
FILE_SEQUENCE_COUNT_MSG = "已分析文件 '%1' 中的序列：%2"
GLOBAL_SEQUENCE_FILE_COUNT_MSG = "分析的序列文件总数：%1"
COUNT_PER_SEQUENCE = "按序列计数"
COUNT_PER_FILE = "每个序列文件计数"
COUNT_PER_ANALYSIS = "计算整个分析"


;;属性加载器

PROP_LOADER_SOURCE_NAME = "属性加载器源应该是正确的"
PROP_LOADER_SOURCE_DESCRIPTION = "属性加载器源应该存在。源应该符合有效格式。"


;;Python适配器
PYTHON_VERSION_INVALID_MSG = "TestStand 支持 python 2.7+ 和 3.6+。指定具有主要和次要版本号的版本，如'2.7'或'3.6'。确保 python 路径存在于 PATH 环境变量中"
PYTHON_VERSION_EMPTY_MSG = "Python 版本不能为空。"
PYTHON_VIRTUAL_ENV_PATH_NOT_FOUND_MSG = "Python 虚拟环境目录 '%1' 不存在。"
PYTHON_ADAPTER_VERSION_INVALID_MSG = "TestStand 支持具有相同位数的 python 2.7+ 和 3.6+。指定具有主要和次要版本号的版本，如'2.7'或'3.6'。确保 python 路径存在于 PATH 环境变量中。"
PYTHON_ADAPTER_VERSION_EMPTY_MSG = "Python 版本不能为空。Python 适配器配置中的 Python 版本未设置。"
PYTHON_ADAPTER_PYTHON_VERSION_LOAD_FAIL = "无法加载 Python 适配器配置中指定的 python 版本。确保安装了适当位数的 python 并将其添加到 PATH 环境变量中。"
PYTHON_ADAPTER_VIRTUAL_ENV_PATH_NOT_FOUND_MSG = "Python 适配器配置中指定的 Python 虚拟环境目录 '%1' 不存在。"
PYTHON_ADAPTER_INVALID_PYTHON_VIRTUAL_ENV_PATH_MSG = "在 Python 适配器配置中指定的虚拟环境路径无效。TestStand 支持使用'virtualenv'工具创建的虚拟环境。确保可以使用 TestStand 搜索目录找到虚拟环境目录。"
PYTHON_MODULE_PYTHON_VERSION_LOAD_FAIL = "无法加载指定版本的 python。确保安装了适当位数的 python 并将其添加到 PATH 环境变量中。"
PYTHON_ADAPTER_CONFIG_OPENING_MSG = "Python 适配器配置中指定的值无效。"
PYTHON_MODULE_INVALID_PYTHON_VIRTUAL_ENV_PATH_MSG = "无效的虚拟环境路径。TestStand 支持使用 'virtualenv' 工具创建的虚拟环境。确保可以使用 TestStand 搜索目录找到虚拟环境目录。"
PYTHON_MODULE_PATH_EMPTY_MSG = "应指定 Python 模块文件。"
PYTHON_INTERPRETER_REF_EMPTY_MSG = "当 Python 解释器设置为 \"ObjectReference\" 时，解释器引用不能为空"
PYTHON_INVALID_FILE_EXTENSION_MSG = "无效的 Python 文件扩展名。Python 文件的扩展名应为 '.py'。"
PYTHON_CLASSNAME_EMPTY_MSG = "类名不能为空。"
PYTHON_FUNCTIONNAME_EMPTY_MSG = "Python 调用方法操作的函数名称不能为空。"
PYTHON_ATTRIBUTENAME_EMPTY_MSG = "Python 设置或获取属性操作的属性名称不能为空。"
PYTHON_CLASSNAME_NOTFOUND_MSG = "在模块 '%2' 中找不到类 '%1'。"
PYTHON_FUNC_OR_ATTRIB_NAME_NOTFOUND_MSG = "在 '%3' 中找不到 %1 '%2'。"
PYTHON_ATTRIB_NAME_NOTFOUND_FOR_SET_MSG = "执行该步骤将在运行时创建属性。"
PYTHON_STRING_FUNCTION = "函数"
PYTHON_STRING_ATTRIBUTE = "属性"
PYTHON_MODULE_LOAD_FAIL = "无法加载 Python 模块。"
PYTHON_MODULE_INVALID_PATH_DIRECTORY = "无效目录'%1'。确保指定的目录包含 __init__.py 文件。"

;;扫描循环
SWEEP_LOOP_NO_PARAMETERS = "扫描循环步骤需要至少一个扫描参数。"
SWEEP_LOOP_OUTPUT_ENABLED_WITH_NO_SAVED_PARAMETERS = "启用输出时必须至少输出一个扫描参数。"
SWEEP_LOOP_INPUT_ENABLED_WITH_NO_STREAM_PARAMETERS = "输入已启用，但没有扫描参数使用流策略。"
SWEEP_LOOP_STREAM_STRATEGY_WITH_INPUT_DISABLED = "当一个或多个参数使用流策略时，必须启用输入。"
SWEEP_LOOP_STREAM_STRATEGY_WITH_PERMUTE = "当一个或多个参数使用流策略时，不支持置换。"
SWEEP_LOOP_INVALID_START_STOP_STEP = "启动/停止/步进扫描参数设置的指定无效。"
SWEEP_LOOP_INVALID_START_STOP_NUM_POINTS = "开始/停止/num 点扫描参数设置的指定无效。"
SWEEP_LOOP_UNBOUNDED_PERMUTED_PARAMETER = "置换扫描参数不能无限制。"
SWEEP_LOOP_TOO_MANY_VALUES = "值太多。当不排列时，具有有限范围的扫描参数必须具有相同数量的值。"
